# Lengolf Booking System Unification: Backoffice Forms Integration

**Version:** 1.0
**Date:** 2024-07-26

## 1. Introduction

This document outlines the technical specification for modifying the Lengolf Backoffice Forms application (`lengolf-forms`) to align its booking creation process with the standard established by the customer-facing booking application (`@lengolf-booking-refactor`). The primary goal is to ensure that bookings created via the backoffice are stored in the same `bookings` table using a consistent schema and generate Google Calendar events with matching formats.

## 2. Background

Currently, the backoffice application and the customer-facing application create bookings independently. This leads to potential inconsistencies in data storage (different table schemas or fields) and calendar event representation. This project aims to unify the booking creation pathway originating from the backoffice.

**Key Requirements:**

*   Bookings from the backoffice must be inserted into the **primary `bookings` table** used by `@lengolf-booking-refactor`.
*   The data inserted must conform to the **schema of the primary `bookings` table**.
*   Google Calendar events generated by backoffice bookings must follow the **formatting standard** used by `@lengolf-booking-refactor`.
*   Customer email mapping/CRM lookup will be **skipped** for backoffice bookings initially; the `email` field will be stored as `info@len.golf`.
*   LINE notification logic remains **unchanged** for now.
*   `calendar_event_id` will **not** be stored in the database.
*   `package_info` will **not** be stored in the database but derived dynamically for formatting.
*   A fixed `user_id` will be used for all backoffice bookings.

## 3. Current Backoffice Implementation (`lengolf-forms`)

*   **API Endpoint:** `app/api/bookings/create/route.ts`
*   **Database Interaction:** Direct insert into a `bookings` table via `@/lib/supabase`.
*   **Data Structure (`src/types/booking.ts`):**
    ```typescript
    interface Booking {
      employee_name: string;
      customer_name: string;
      contact_number?: string;
      booking_type: string;
      package_name?: string;
      number_of_pax: number;
      booking_date: string; // 'yyyy-MM-dd'
      start_time: string; // 'HH:mm:ss'
      end_time: string; // 'HH:mm:ss'
      bay_number: string; // e.g., 'Bay 1 (Bar)'
      notes?: string;
      booking_source: string;
      is_new_customer: boolean;
      package_id?: string;
    }
    ```
*   **Calendar Formatting (`src/lib/google-calendar.ts`):** Uses `luxon` library.
    *   Summary: `${customer_name} (${contact_number}) (${number_of_pax}) - ${bookingType} at ${bay_number}`
    *   Description: Includes name, contact, type, pax, bay, date, time, booked by, via, notes.
    *   Source: `Via: ${booking_source}`

## 4. Target Implementation (`@lengolf-booking-refactor` Standard)

*   **Database Schema (`bookings` table - Confirmed):**
    *   `id` (text, PK, not nullable)
    *   `user_id` (uuid, not nullable, FK to `profiles`)
    *   `name` (text, not nullable)
    *   `email` (text, not nullable)
    *   `phone_number` (text, not nullable)
    *   `date` (date, not nullable)
    *   `start_time` (text, not nullable, Format: `HH:mm`)
    *   `duration` (integer, not nullable, Unit: hours)
    *   `number_of_people` (integer, not nullable)
    *   `status` (text, not nullable, CHECK ('confirmed', 'cancelled'))
    *   `created_at` (timestamptz, not nullable, default now())
    *   `updated_at` (timestamptz, not nullable, default now())
    *   `bay` (text, nullable, Format: `Bay 1`, `Bay 2`, `Bay 3`)
    *   `customer_notes` (text, nullable)
    *   *(No `calendar_event_id` column)*
    *   *(No `package_info` column)*
    *   *(No `crm_customer_id` column in this table)*
*   **Calendar Formatting (`/api/bookings/calendar/create` - Inferred):** Uses `date-fns`/`date-fns-tz`.
    *   Summary: `${calendarTitle} (${phone_number}) (${number_of_people}) - ${packageInfo} at ${bayDisplayName}`
    *   Description: Includes Customer Name (CRM or "New Customer"), Booking Name, Contact, Email, Type (packageInfo), Pax, Bay, Date (EEEE, MMMM d), Time (HH:mm - HH:mm), Via (Website/Backoffice), Booking ID.
    *   Source: `Via: Website` (Hardcoded in refactor - **needs adjustment for backoffice**)

## 5. Proposed Solution & Implementation Steps

**Core Strategy:** Introduce a *second*, dedicated Supabase client instance within `lengolf-forms` specifically configured to interact with the target `@lengolf-booking-refactor` database (`bisimqmtxjsptehhqpeg`). The existing Supabase client (`@/lib/supabase`) remains unchanged for other parts of the application.

### 5.0. Prerequisite: New Supabase Client Configuration

1.  **Environment Variables:**
    *   Define new environment variables for the target Supabase project connection (e.g., in `.env`, Vercel env vars):
        *   `REFAC_SUPABASE_URL`: The URL of the target Supabase project (`bisimqmtxjsptehhqpeg`).
        *   `REFAC_SUPABASE_ANON_KEY`: The Anon Key for the target Supabase project.
    *   Ensure these variables are added to `env.example` and documented.
2.  **New Client Instance:**
    *   Create a new file (e.g., `src/lib/refac-supabase.ts`).
    *   Initialize a new Supabase client instance in this file using the `REFAC_SUPABASE_URL` and `REFAC_SUPABASE_ANON_KEY` environment variables. This client authenticates anonymously against the target project.
    *   Export this new client instance (e.g., `refacSupabase`).

### 5.1. Database Schema Alignment (via New Client)

The backoffice application must insert data conforming to the target `bookings` schema using the **new Supabase client**.

**Action:** Modify the data object formatting and the API endpoint responsible for insertion.

1.  **Update `formatBookingData` (`src/components/booking-form/submit/submit-handler.ts`):**
    *   Modify the function return type and structure to match the target schema object required for the **database insert**.
    *   Calculate `duration` (integer hours) from `formData.startTime` and `formData.endTime`. Ensure it's an integer.
    *   Map Fields:
        *   `customer_name` -> `name`
        *   `contact_number` -> `phone_number` (ensure it's non-null if target requires)
        *   `booking_date` -> `date` (ensure `yyyy-MM-dd` format)
        *   `start_time` -> `start_time` (ensure `HH:mm` format, removing seconds)
        *   `number_of_pax` -> `number_of_people`
        *   `notes` -> `customer_notes`
        *   `bay_number` -> `bay` (Map display names: `'Bay 1 (Bar)'` -> `'Bay 1'`, `'Bay 3 (Entrance)'` -> `'Bay 3'`, `'Bay 2'` -> `'Bay 2'`).
    *   **Add Fields:**
        *   `id`: Generate a unique booking ID (e.g., adapt `generateBookingId` from refactor or use UUID - ensure it's text).
        *   `email`: Set to the fixed placeholder `'info@len.golf'`.
        *   `duration`: Use the calculated integer duration (hours).
        *   `status`: Set to `'confirmed'`.
        *   `user_id`: Set to the fixed dummy UUID `'059090f8-2d76-4f10-81de-5efe4d2d0fd8'`. (This is independent of the logged-in backoffice user).
    *   **Remove Fields (from the object passed to Supabase for insertion):** `employee_name`, `end_time`, `booking_source`, `is_new_customer`, `package_id`, `booking_type`, `package_name`. (These may still be needed from `formData` to derive values for calendar/LINE formatting).

2.  **Update `Booking` Type (`src/types/booking.ts`):**
    *   Modify the `Booking` interface to reflect the target **database schema structure** that `formatBookingData` will now produce for the insert operation.

3.  **Update API Endpoint (`app/api/bookings/create/route.ts`):**
    *   **Import the new client:** Import the `refacSupabase` client created in step 5.0.
    *   Ensure the endpoint receives the booking data object (formatted by `formatBookingData` on the client).
    *   The **`refacSupabase`** client (not the original one) should perform an `insert` into the `bookings` table using the received data object.
    *   The object passed to `insert` must match the target `bookings` table schema precisely.
    *   Ensure it expects the new `Booking` structure for insertion.
    *   The `insert` call should now work with the correctly formatted object based on the target schema.
    *   Crucially, the API should still return the generated `bookingId` (`data.id`).

### 5.2. Calendar Event Formatting Alignment

**Action:** Modify calendar event generation logic.

1.  **Refactor `formatCalendarEvent` (`src/lib/google-calendar.ts`):**
    *   **Dependencies:** Add `date-fns` and `date-fns-tz` if not already present (`npm install date-fns date-fns-tz`). Update imports. Remove `luxon`.
    *   **Input:** Function should accept the *original* `Booking` object generated by `formatBookingData` (or the necessary raw form data fields) to have access to fields like `employee_name`, `booking_type`, `package_name`, `booking_source` etc., needed for formatting, even if they aren't saved to the DB. Alternatively, modify `formatBookingData` to return *both* the DB-insert object *and* a separate object with all fields needed for formatting. Let's assume the function receives an object containing all necessary fields for now.
    *   **Derive `packageInfo`:** Create a local variable `packageInfo` string based on `booking_type` and `package_name` (e.g., `booking.package_name ? \`\${booking.booking_type} (\${booking.package_name})\` : booking.booking_type;`).
    *   **Summary:** Update the format to `${name} (${phone_number}) (${number_of_people}) - ${packageInfo} at ${bay}`. Ensure `bay` uses the simple format (`Bay 1`, `Bay 2`, `Bay 3`).
    *   **Description:** Replicate the target description structure:
        ```
        Customer Name: ${name} // Use booking name directly
        Booking Name: ${name} // Use booking name
        Contact: ${phone_number}
        Email: info@len.golf // Use placeholder email
        Type: ${packageInfo} // Use derived packageInfo
        Pax: ${number_of_people}
        Bay: ${bay} // Ensure simple bay name/ID
        Date: ${formatInTimeZone(parseISO(startDateIso), 'Asia/Bangkok', 'EEEE, MMMM d')}
        Time: ${formatInTimeZone(parseISO(startDateIso), 'Asia/Bangkok', 'HH:mm')} - ${formatInTimeZone(parseISO(endDateIso), 'Asia/Bangkok', 'HH:mm')}
        Via: Backoffice // Explicitly set source
        Booking ID: ${id} // Use the generated booking ID
        Booked By: ${employee_name} // Use original employee name if available
        ${customer_notes ? `

Notes: ${customer_notes}` : ''}
        ```
        *   Calculate `startDateIso` and `endDateIso` using `date`, `start_time`, `duration` (passed to the function), and `date-fns-tz` for the `Asia/Bangkok` timezone.
    *   **Start/End Times:** Use `dateTime` in `yyyy-MM-dd'T'HH:mm:ssxxx` format using `date-fns-tz`.
    *   **Timezone:** Ensure `Asia/Bangkok` is consistently used.
    *   **Color ID:** Retain existing logic for bay colors (mapping simple bay names like `Bay 1` to colors if needed).

2.  **Update Calendar API Call (`src/components/booking-form/submit/submit-handler.ts`):**
    *   The data sent to `/api/bookings/calendar` needs to contain all the fields required by the updated `formatCalendarEvent` (including potentially fields not saved to the DB like `employee_name`).

### 5.3. Update Booking with Calendar Event ID

**(Removed)** This step is no longer necessary as the `calendar_event_id` is not being stored in the target database schema. The calendar event creation will proceed without updating the database record.

## 6. Data Migration

No data migration is required as this change only affects *new* bookings created via the backoffice. Existing bookings remain untouched.

## 7. Rollout & Testing

1.  Implement changes in a development branch.
2.  Thoroughly test the backoffice booking form:
    *   Verify bookings appear correctly in the Supabase `bookings` table with the new schema.
    *   Verify `email` is `'info@len.golf'`.
    *   Verify `user_id` is the fixed dummy UUID.
    *   Verify Google Calendar events are created with the correct summary, description (including `Via: Backoffice`, derived `packageInfo`, placeholder `email`, `employee_name`), times, and timezone.
    *   Verify LINE notifications are still sent correctly (no changes expected).
3.  Compare backoffice-created bookings/events with those created via the customer-facing app to ensure consistency (apart from expected differences like `email` and `Via:` source).
4.  Deploy changes.

## 8. Future Considerations

*   **Client Usage Clarity:** Maintain clear code conventions to distinguish usage between the original (`supabase`) and the new (`refacSupabase`) clients.
*   **Authentication:** The insertion into the target DB uses a fixed `user_id` and the target project's Anon Key via `refacSupabase`, independent of the backoffice employee's session.
*   **Employee Mapping:** (Less critical now with fixed UUID) Revisit if proper user tracking for backoffice actions becomes necessary.
*   **CRM Integration:** Explore adding CRM lookup for backoffice bookings if needed later.
*   **Shared Logic:** Consider extracting shared logic (like ID generation, date formatting, calendar formatting) into a common library/package accessible by both applications if possible to reduce code duplication.
*   **Error Handling:** Review and enhance error handling for the updated flows (database inserts, calendar creation).
*   **Dummy User ID:** Replace the dummy `user_id` with a proper solution when feasible.

---

## Appendix: File Overview

This section outlines the primary files involved in this merge process within the `lengolf-forms` project and key reference files from the `@lengolf-booking-refactor` project.

### Files to be Modified in `lengolf-forms`

*   **Configuration:**
    *   `.env` (or equivalent): Add `REFAC_SUPABASE_URL`, `REFAC_SUPABASE_ANON_KEY`.
    *   `env.example`: Document `REFAC_SUPABASE_URL`, `REFAC_SUPABASE_ANON_KEY`.
    *   `package.json`: Add `date-fns`, `date-fns-tz` dependencies.
*   **New Files:**
    *   `src/lib/refac-supabase.ts`: Initialize the new Supabase client instance (`refacSupabase`).
*   **Core Logic:**
    *   `src/types/booking.ts`: Update `Booking` interface for DB schema.
    *   `src/lib/google-calendar.ts`: Refactor `formatCalendarEvent` (use `date-fns`, align format, derive `packageInfo`).
    *   `src/components/booking-form/submit/submit-handler.ts`: Implement ID generation, update `formatBookingData`, orchestrate submit flow (`handleFormSubmit`).
*   **API Routes:**
    *   `app/api/bookings/create/route.ts`: Use `refacSupabase` client for insert.
    *   `app/api/bookings/calendar/route.ts`: Adjust response handling (minor).
*   **Testing:**
    *   Associated unit/integration test files.

### Key Reference Files in `@lengolf-booking-refactor`

*   **Booking Creation/Schema:**
    *   `app/api/bookings/create/route.ts`: Target DB interaction logic, ID generation pattern, bay format usage.
*   **Calendar Formatting:**
    *   `app/api/bookings/calendar/create/route.ts`: Target calendar summary/description format, `date-fns-tz` usage.
    *   `lib/bookingCalendarConfig.ts`: Confirms simple bay keys (`'Bay 1'`, `'Bay 2'`, `'Bay 3'`).
    *   `lib/bayConfig.ts`: Potential source for color IDs or display names used in calendar formatting.
*   **Utility Functions (Examples):**
    *   `utils/booking-formatter.ts`: Potential patterns for data formatting/calculations.

*   **Dummy User ID:** Replace the dummy `user_id` with a proper solution when feasible. 