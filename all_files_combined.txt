Summary:
Total files: 97
Total lines of code: 11172

Files by extension:
.js: 15 files, 2142 lines
.ts: 55 files, 5817 lines
.tsx: 24 files, 3047 lines
.html: 2 files, 67 lines
.css: 1 files, 99 lines


Analysis Summary:

1. Core Features:
- auth: 44 files
- booking: 43 files
- customer: 23 files
- notification: 31 files
- integration: 53 files
- utils: 60 files

2. File Dependencies:
app\(features)\auth\components\GuestForm.tsx:
  Depends on: react, next-auth/react, react-phone-number-input
app\(features)\auth\layout.tsx:
  Depends on: 
app\(features)\auth\login\page.tsx:
  Depends on: next/image, @/components/icons, ../components/GuestForm, react, next-auth/react, next/navigation
app\(features)\bookings\actions.ts:
  Depends on: @/utils/date
app\(features)\bookings\components\booking\ConfirmationContent.tsx:
  Depends on: date-fns, next/dynamic, next/navigation, @/types
app\(features)\bookings\components\booking\Layout.tsx:
  Depends on: react, next-auth/react, next/navigation, @/utils/supabase/client, date-fns, react-hot-toast, @heroicons/react/24/outline, next/image, @headlessui/react
app\(features)\bookings\components\booking\steps\BookingDetails.tsx:
  Depends on: react, @heroicons/react/24/outline, date-fns, @/utils/supabase/client, next/navigation, @supabase/supabase-js, react-hot-toast, next-auth/react, uuid, crypto, next-auth, @/utils/customer-matching, react-phone-number-input
app\(features)\bookings\components\booking\steps\DateSelection.tsx:
  Depends on: react, date-fns, next/image, react-day-picker
app\(features)\bookings\components\booking\steps\TimeSlots.tsx:
  Depends on: react, date-fns, framer-motion, @heroicons/react/24/outline, next/navigation, ../../../hooks/useAvailability
app\(features)\bookings\confirmation\page.tsx:
  Depends on: next, next/navigation, @/utils/supabase/server, date-fns, @heroicons/react/24/outline, ../components/booking/Layout, @/types, ../components/booking/ConfirmationContent, next-auth
app\(features)\bookings\hooks\useAvailability.ts:
  Depends on: react, date-fns, next/navigation, next-auth/react, @/utils/date
app\(features)\bookings\hooks\useBookingFlow.ts:
  Depends on: react, next-auth/react, next/navigation
app\(features)\bookings\page.tsx:
  Depends on: react, next-auth/react, next/navigation, date-fns, @heroicons/react/24/outline, ./components/booking/Layout, ./components/booking/steps/DateSelection, ./components/booking/steps/TimeSlots, ./components/booking/steps/BookingDetails, ./hooks/useBookingFlow
app\(features)\bookings\types\index.ts:
  Depends on: 
app\api\auth\options.ts:
  Depends on: next-auth/providers/google, next-auth/providers/facebook, next-auth/providers/line, next-auth/providers/credentials, @/utils/supabase/server, @/utils/customer-matching, uuid, next-auth, next-auth/jwt, next-auth, next-auth, next-auth, next-auth
app\api\auth\[...nextauth]\route.ts:
  Depends on: next-auth, ../options
app\api\availability\check\route.ts:
  Depends on: next/server, @/lib/googleApiConfig, @/lib/bookingCalendarConfig, date-fns, date-fns-tz
app\api\availability\route.ts:
  Depends on: next/server, date-fns, date-fns-tz, @/lib/googleApiConfig, next-auth/jwt, next/server, @/lib/cache, date-fns
app\api\bookings\calendar\create\route.ts:
  Depends on: next/server, @/lib/googleApiConfig, @/lib/bookingCalendarConfig, date-fns, date-fns-tz, @/lib/bayConfig, @/utils/supabase/server
app\api\bookings\create\route.ts:
  Depends on: next/server, next-auth/jwt, @/utils/supabase/server, @/utils/booking-formatter, @/utils/parallel-processing, date-fns, date-fns-tz, @/utils/customer-matching, @/lib/bayConfig, @/lib/bookingCalendarConfig, @/lib/googleApiConfig, uuid, node:process, @/lib/reviewRequestScheduler
app\api\crm\mapping\route.ts:
  Depends on: next/server, next-auth, @/app/api/auth/options, next/server, @/utils/supabase/server, @/utils/customer-matching
app\api\crm\match\route.ts:
  Depends on: next/server, next-auth, @/app/api/auth/options, next/server, @/utils/supabase/server, @/utils/customer-matching
app\api\crm\packages\route.ts:
  Depends on: next/server, next-auth, @/app/api/auth/options, next/server, @/utils/supabase/crm-packages
app\api\crm\profile\route.ts:
  Depends on: next/server, next-auth, @/app/api/auth/options, next/server, @/utils/customer-matching
app\api\notifications\email\review-request\route.ts:
  Depends on: next/server, nodemailer
app\api\notifications\email\route.ts:
  Depends on: next/server, @/lib/emailService
app\api\notifications\line\review-request\route.ts:
  Depends on: next/server, @/utils/supabase/server
app\api\notifications\line\route.ts:
  Depends on: next/server, @/lib/env
app\api\notifications\process-review-requests\route.ts:
  Depends on: next/server, @/utils/supabase/server, date-fns-tz, date-fns
app\api\notifications\schedule-review-request\route.ts:
  Depends on: next/server, next-auth/jwt, @/utils/supabase/server, date-fns, date-fns-tz
app\api\notifications\send-review-request\route.ts:
  Depends on: next/server, @/utils/supabase/server
app\auth\error\page.tsx:
  Depends on: next/navigation, next/link, next/image
app\error.tsx:
  Depends on: @/components/shared/ErrorPage
app\globals.css:
  Depends on: 
app\layout.tsx:
  Depends on: next, next/font/google, ./providers, next/script
app\loading.tsx:
  Depends on: @/components/shared/LoadingPage
app\not-found.tsx:
  Depends on: @/components/shared/NotFoundPage
app\page.tsx:
  Depends on: 
app\providers.tsx:
  Depends on: next-auth/react, @/components/providers/GtmUserProfileProvider
components\icons\index.tsx:
  Depends on: react
components\providers\GtmUserProfileProvider.tsx:
  Depends on: next-auth/react, react, @/utils/supabase/client, @/utils/gtm
components\shared\ErrorPage.tsx:
  Depends on: react, next/link
components\shared\LoadingPage.tsx:
  Depends on: 
components\shared\NotFoundPage.tsx:
  Depends on: next/link
components\shared\PageTransition.tsx:
  Depends on: framer-motion
components\ui\Button.tsx:
  Depends on: react, tailwind-merge
jest.config.js:
  Depends on: next/jest
jest.setup.js:
  Depends on: 
lib\bayConfig.ts:
  Depends on: 
lib\bookingCalendarConfig.ts:
  Depends on: 
lib\cache.ts:
  Depends on: node-cache, @/lib/googleApiConfig, date-fns
lib\debug.ts:
  Depends on: 
lib\emailService.ts:
  Depends on: nodemailer
lib\env.ts:
  Depends on: 
lib\googleApiConfig.ts:
  Depends on: google-auth-library, googleapis
lib\init.ts:
  Depends on: ./cache
lib\lineNotifyService.ts:
  Depends on: ./env
lib\reviewRequestScheduler.ts:
  Depends on: @/utils/supabase/server, date-fns, date-fns-tz
middleware.ts:
  Depends on: next/server, next-auth/jwt, next/server
next-env.d.ts:
  Depends on: 
next.config.js:
  Depends on: 
next.config.ts:
  Depends on: next
pages\api\adsbot-test.ts:
  Depends on: next
postcss.config.js:
  Depends on: 
public\googlebot-test.html:
  Depends on: 
public\test-adsbot.html:
  Depends on: 
scripts\clean-duplicate-mappings.js:
  Depends on: dotenv, @supabase/supabase-js
scripts\mark-reviews-as-sent.js:
  Depends on: @supabase/supabase-js
scripts\process-review-requests.js:
  Depends on: node-fetch
scripts\schedule-test-review.js:
  Depends on: @supabase/supabase-js, uuid
scripts\send-test-review-request.js:
  Depends on: node-fetch
scripts\setup-supabase-cron.js:
  Depends on: @supabase/supabase-js
scripts\sync-customer-matching.js:
  Depends on: path, @supabase/supabase-js, natural, fs
scripts\sync-packages.js:
  Depends on: path, @supabase/supabase-js, fs
scripts\test-email-notification.js:
  Depends on: 
scripts\test-google-auth.ts:
  Depends on: ../lib/googleApiConfig, dotenv
scripts\test-line-notification.js:
  Depends on: node-fetch
scripts\test-process-reviews.js:
  Depends on: node-fetch, fs, path
tailwind.config.ts:
  Depends on: tailwindcss
types\env.d.ts:
  Depends on: 
types\index.ts:
  Depends on: 
types\next-auth.d.ts:
  Depends on: 
types\supabase.ts:
  Depends on: 
utils\booking-formatter.ts:
  Depends on: date-fns
utils\customer-matching.ts:
  Depends on: ./supabase/crm, ./supabase/server, ./supabase/crm-packages, @/types/supabase
utils\date.ts:
  Depends on: date-fns-tz
utils\gtm.ts:
  Depends on: 
utils\logger.ts:
  Depends on: 
utils\logging.ts:
  Depends on: ./supabase/server, uuid
utils\parallel-processing.ts:
  Depends on: 
utils\supabase\client.ts:
  Depends on: @supabase/supabase-js, @/types/supabase, @supabase/supabase-js
utils\supabase\crm-packages.ts:
  Depends on: ./crm, ./server
utils\supabase\crm.ts:
  Depends on: @supabase/supabase-js, @/types/supabase
utils\supabase\middleware.ts:
  Depends on: @supabase/ssr, next/server, @/types/supabase
utils\supabase\server.ts:
  Depends on: @supabase/supabase-js, @/types/supabase
__tests__\availability.test.ts:
  Depends on: @/app/api/availability/route, @/lib/googleApiConfig, @/utils/supabase/server, @/lib/cache
__tests__\sample.test.ts:
  Depends on: 

3. Integration Points:
- Google Calendar API
- Google Sheets API
- LINE Notify API
- Facebook OAuth
- LINE Login


==== Folder Structure ====

ðŸ“ app/
  ðŸ“ (features)/
    ðŸ“ auth/
      ðŸ“ components/
        ðŸ“„ GuestForm.tsx [Lines: 158] ðŸ“Š
      ðŸ“„ layout.tsx [Lines: 13] ðŸ“Š
      ðŸ“ login/
        ðŸ“„ page.tsx [Lines: 257] ðŸ“Š
    ðŸ“ bookings/
      ðŸ“„ actions.ts [Lines: 25] ðŸ“Š
      ðŸ“ components/
        ðŸ“ booking/
          ðŸ“„ ConfirmationContent.tsx [Lines: 200] ðŸ“Š
          ðŸ“„ Layout.tsx [Lines: 593] ðŸ“Š
          ðŸ“ steps/
            ðŸ“„ BookingDetails.tsx [Lines: 659] ðŸ“Š
            ðŸ“„ DateSelection.tsx [Lines: 289] ðŸ“Š
            ðŸ“„ TimeSlots.tsx [Lines: 120] ðŸ“Š
      ðŸ“ confirmation/
        ðŸ“„ page.tsx [Lines: 48] ðŸ“Š
      ðŸ“ hooks/
        ðŸ“„ useAvailability.ts [Lines: 67] ðŸ“Š
        ðŸ“„ useBookingFlow.ts [Lines: 82] ðŸ“Š
      ðŸ“„ page.tsx [Lines: 106] ðŸ“Š
      ðŸ“ types/
        ðŸ“„ index.ts [Lines: 21] ðŸ“Š
  ðŸ“ api/
    ðŸ“ auth/
      ðŸ“„ options.ts [Lines: 249] ðŸ“Š
      ðŸ“ [...nextauth]/
        ðŸ“„ route.ts [Lines: 9] ðŸ“Š
    ðŸ“ availability/
      ðŸ“ check/
        ðŸ“„ route.ts [Lines: 72] ðŸ“Š
      ðŸ“„ route.ts [Lines: 211] ðŸ“Š
    ðŸ“ bookings/
      ðŸ“ calendar/
        ðŸ“ create/
          ðŸ“„ route.ts [Lines: 225] ðŸ“Š
      ðŸ“ create/
        ðŸ“„ route.ts [Lines: 840] ðŸ“Š
    ðŸ“ crm/
      ðŸ“ mapping/
        ðŸ“„ route.ts [Lines: 68] ðŸ“Š
      ðŸ“ match/
        ðŸ“„ route.ts [Lines: 79] ðŸ“Š
      ðŸ“ packages/
        ðŸ“„ route.ts [Lines: 72] ðŸ“Š
      ðŸ“ profile/
        ðŸ“„ route.ts [Lines: 60] ðŸ“Š
    ðŸ“ notifications/
      ðŸ“ email/
        ðŸ“ review-request/
          ðŸ“„ route.ts [Lines: 166] ðŸ“Š
        ðŸ“„ route.ts [Lines: 87] ðŸ“Š
      ðŸ“ line/
        ðŸ“ review-request/
          ðŸ“„ route.ts [Lines: 169] ðŸ“Š
        ðŸ“„ route.ts [Lines: 191] ðŸ“Š
      ðŸ“ process-review-requests/
        ðŸ“„ route.ts [Lines: 300] ðŸ“Š
      ðŸ“ schedule-review-request/
        ðŸ“„ route.ts [Lines: 75] ðŸ“Š
      ðŸ“ send-review-request/
        ðŸ“„ route.ts [Lines: 85] ðŸ“Š
  ðŸ“ auth/
    ðŸ“ error/
      ðŸ“„ page.tsx [Lines: 73] ðŸ“Š
  ðŸ“„ error.tsx [Lines: 13] ðŸ“Š
  ðŸ“„ globals.css [Lines: 99] ðŸ“Š
  ðŸ“„ layout.tsx [Lines: 226] ðŸ“Š
  ðŸ“„ loading.tsx [Lines: 5] ðŸ“Š
  ðŸ“„ not-found.tsx [Lines: 5] ðŸ“Š
  ðŸ“„ page.tsx [Lines: 4] ðŸ“Š
  ðŸ“„ providers.tsx [Lines: 14] ðŸ“Š
ðŸ“ components/
  ðŸ“ icons/
    ðŸ“„ index.tsx [Lines: 44] ðŸ“Š
  ðŸ“ providers/
    ðŸ“„ GtmUserProfileProvider.tsx [Lines: 90] ðŸ“Š
  ðŸ“ shared/
    ðŸ“„ ErrorPage.tsx [Lines: 43] ðŸ“Š
    ðŸ“„ LoadingPage.tsx [Lines: 10] ðŸ“Š
    ðŸ“„ NotFoundPage.tsx [Lines: 18] ðŸ“Š
    ðŸ“„ PageTransition.tsx [Lines: 19] ðŸ“Š
  ðŸ“ ui/
    ðŸ“„ Button.tsx [Lines: 40] ðŸ“Š
ðŸ“„ deploy.sh
ðŸ“„ Dockerfile
ðŸ“„ env.example
ðŸ“„ eslint.config.mjs
ðŸ“„ jest.config.js [Lines: 20] ðŸ“Š
ðŸ“„ jest.setup.js [Lines: 124] ðŸ“Š
ðŸ“„ key.json
ðŸ“ lib/
  ðŸ“„ bayConfig.ts [Lines: 13] ðŸ“Š
  ðŸ“„ bookingCalendarConfig.ts [Lines: 18] ðŸ“Š
  ðŸ“„ cache.ts [Lines: 82] ðŸ“Š
  ðŸ“„ debug.ts [Lines: 133] ðŸ“Š
  ðŸ“„ emailService.ts [Lines: 133] ðŸ“Š
  ðŸ“„ env.ts [Lines: 9] ðŸ“Š
  ðŸ“„ googleApiConfig.ts [Lines: 49] ðŸ“Š
  ðŸ“„ init.ts [Lines: 12] ðŸ“Š
  ðŸ“„ lineNotifyService.ts [Lines: 43] ðŸ“Š
  ðŸ“„ reviewRequestScheduler.ts [Lines: 86] ðŸ“Š
ðŸ“„ middleware.ts [Lines: 175] ðŸ“Š
ðŸ“„ next-env.d.ts [Lines: 7] ðŸ“Š
ðŸ“„ next.config.js [Lines: 31] ðŸ“Š
ðŸ“„ next.config.ts [Lines: 8] ðŸ“Š
ðŸ“ pages/
  ðŸ“ api/
    ðŸ“„ adsbot-test.ts [Lines: 29] ðŸ“Š
ðŸ“„ postcss.config.js [Lines: 6] ðŸ“Š
ðŸ“„ postcss.config.mjs
ðŸ“ public/
  ðŸ“„ apple-touch-icon.png
  ðŸ“„ favicon-96x96.png
  ðŸ“„ favicon.ico
  ðŸ“„ favicon.svg
  ðŸ“„ file.svg
  ðŸ“„ globe.svg
  ðŸ“„ googlebot-test.html [Lines: 14] ðŸ“Š
  ðŸ“ images/
    ðŸ“„ coaching_1.jpg
    ðŸ“„ facebook.svg
    ðŸ“„ favicon.ico
    ðŸ“„ favicon.png
    ðŸ“„ google.svg
    ðŸ“„ LENGOLF - Line coupon.png
    ðŸ“„ lengolf_bay_rate.jpg
    ðŸ“„ lengolf_logo.jpg
    ðŸ“„ line.svg
    ðŸ“„ logo_v1.png
    ðŸ“„ pic1.png
    ðŸ“„ pic2.png
    ðŸ“„ promotion.jpg
    ðŸ“„ promotion_1.jpg
    ðŸ“„ promotion_2.jpg
  ðŸ“„ logo_v1.png
  ðŸ“„ next.svg
  ðŸ“„ robots.txt
  ðŸ“„ site.webmanifest
  ðŸ“„ test-adsbot.html [Lines: 53] ðŸ“Š
  ðŸ“„ vercel.svg
  ðŸ“„ web-app-manifest-192x192.png
  ðŸ“„ web-app-manifest-512x512.png
  ðŸ“„ window.svg
  ðŸ“„ _headers
  ðŸ“„ _redirects
ðŸ“„ README.md
ðŸ“ scripts/
  ðŸ“„ add-stable-hash-id.sql
  ðŸ“„ add_customers_hash_trigger.sql
  ðŸ“„ add_packages_hash_trigger.sql
  ðŸ“„ clean-duplicate-mappings.js [Lines: 99] ðŸ“Š
  ðŸ“„ crm_update_procedure.sql
  ðŸ“„ direct_update_package_hash.sql
  ðŸ“„ drop_foreign_key.sql
  ðŸ“„ mark-requests-as-sent.sql
  ðŸ“„ mark-reviews-as-sent.js [Lines: 72] ðŸ“Š
  ðŸ“„ process-review-requests.js [Lines: 69] ðŸ“Š
  ðŸ“„ process-reviews-test.log
  ðŸ“„ quick_fix_foreign_key.sql
  ðŸ“„ README_customer_hash.md
  ðŸ“„ schedule-test-review.js [Lines: 182] ðŸ“Š
  ðŸ“„ send-test-review-request.js [Lines: 101] ðŸ“Š
  ðŸ“„ setup-supabase-cron.js [Lines: 206] ðŸ“Š
  ðŸ“„ sync-customer-matching.js [Lines: 577] ðŸ“Š
  ðŸ“„ sync-packages.js [Lines: 395] ðŸ“Š
  ðŸ“„ test-email-notification.js [Lines: 1] ðŸ“Š
  ðŸ“„ test-google-auth.ts [Lines: 70] ðŸ“Š
  ðŸ“„ test-line-notification.js [Lines: 100] ðŸ“Š
  ðŸ“„ test-process-reviews.js [Lines: 159] ðŸ“Š
  ðŸ“„ test_customer_hash_trigger.sql
  ðŸ“„ test_package_hash_trigger.sql
  ðŸ“„ tsconfig.json
ðŸ“ supabase/
ðŸ“„ tailwind.config.ts [Lines: 28] ðŸ“Š
ðŸ“„ tsconfig.json
ðŸ“ types/
  ðŸ“„ env.d.ts [Lines: 10] ðŸ“Š
  ðŸ“„ index.ts [Lines: 8] ðŸ“Š
  ðŸ“„ next-auth.d.ts [Lines: 15] ðŸ“Š
  ðŸ“„ supabase.ts [Lines: 150] ðŸ“Š
ðŸ“ utils/
  ðŸ“„ booking-formatter.ts [Lines: 123] ðŸ“Š
  ðŸ“„ customer-matching.ts [Lines: 685] ðŸ“Š
  ðŸ“„ date.ts [Lines: 30] ðŸ“Š
  ðŸ“„ gtm.ts [Lines: 47] ðŸ“Š
  ðŸ“„ logger.ts [Lines: 18] ðŸ“Š
  ðŸ“„ logging.ts [Lines: 102] ðŸ“Š
  ðŸ“„ parallel-processing.ts [Lines: 20] ðŸ“Š
  ðŸ“ supabase/
    ðŸ“„ client.ts [Lines: 23] ðŸ“Š
    ðŸ“„ crm-packages.ts [Lines: 168] ðŸ“Š
    ðŸ“„ crm.ts [Lines: 27] ðŸ“Š
    ðŸ“„ middleware.ts [Lines: 61] ðŸ“Š
    ðŸ“„ server.ts [Lines: 22] ðŸ“Š
ðŸ“„ vercel.json
ðŸ“ __tests__/
  ðŸ“„ availability.test.ts [Lines: 255] ðŸ“Š
  ðŸ“„ sample.test.ts [Lines: 5] ðŸ“Š


==== File Statistics ====



==== app\(features)\auth\components\GuestForm.tsx (158 lines) ====

'use client';

import { useState } from 'react';
import { signIn } from 'next-auth/react';
import PhoneInput, { isValidPhoneNumber } from 'react-phone-number-input';
import 'react-phone-number-input/style.css';

interface GuestFormProps {
  onClose: () => void;
}

interface GuestFormData {
  name: string;
  email: string;
  phone: string | undefined;
}

export default function GuestForm({ onClose }: GuestFormProps) {
  const [formData, setFormData] = useState<GuestFormData>({
    name: '',
    email: '',
    phone: undefined,
  });
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setIsSubmitting(true);

    // Validate form data
    if (!formData.name || !formData.email || !formData.phone) {
      setError('All fields are required.');
      setIsSubmitting(false);
      return;
    }

    if (!isValidPhoneNumber(formData.phone || '')) {
      setError('Please enter a valid phone number.');
      setIsSubmitting(false);
      return;
    }

    try {
      const result = await signIn('guest', {
        name: formData.name,
        email: formData.email,
        phone: formData.phone,
        redirect: false
      });

      if (result?.error) {
        setError('Failed to create guest session. Please try again.');
        setIsSubmitting(false);
        return;
      }

      window.location.href = '/bookings';
    } catch (err) {
      console.error('Guest login error:', err);
      setError('Failed to create guest session. Please try again.');
      setIsSubmitting(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg p-6 max-w-md w-full">
        <h2 className="text-xl font-semibold mb-4">Guest Information</h2>
        
        {error && (
          <div className="mb-4 p-2 bg-red-100 border border-red-400 text-red-700 rounded">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700">
              Name
            </label>
            <input
              type="text"
              id="name"
              required
              disabled={isSubmitting}
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 disabled:bg-gray-100 disabled:cursor-not-allowed"
              value={formData.name}
              onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            />
          </div>

          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email
            </label>
            <input
              type="email"
              id="email"
              required
              disabled={isSubmitting}
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 disabled:bg-gray-100 disabled:cursor-not-allowed"
              value={formData.email}
              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            />
          </div>

          <div>
            <label htmlFor="phone" className="block text-sm font-medium text-gray-700">
              Phone
            </label>
            <PhoneInput
              international
              defaultCountry="TH"
              id="phone"
              placeholder="Enter phone number"
              value={formData.phone}
              onChange={(value) => setFormData({ ...formData, phone: value })}
              disabled={isSubmitting}
              className="mt-1 block w-full rounded-md border border-gray-300 custom-phone-input focus-within:ring-1 focus-within:ring-indigo-600 focus-within:border-indigo-600"
            />
            {!formData.phone && !error && (
                <p className="mt-1 text-xs text-gray-500">
                  Please select your country code and enter your phone number.
                </p>
            )}
          </div>

          <div className="flex justify-end space-x-3">
            <button
              type="button"
              onClick={onClose}
              disabled={isSubmitting}
              className="px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 border border-gray-300 rounded-md disabled:opacity-50 disabled:cursor-not-allowed"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={isSubmitting}
              className="relative px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md disabled:opacity-90 disabled:cursor-not-allowed min-w-[100px]"
            >
              {isSubmitting ? (
                <div className="flex items-center justify-center">
                  <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin mr-2" />
                  <span>Processing...</span>
                </div>
              ) : (
                'Continue'
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
} 



==== app\(features)\auth\layout.tsx (13 lines) ====

export default function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <main className="min-h-screen bg-gray-50">
      <div className="flex min-h-screen flex-col items-center justify-center px-4">
        {children}
      </div>
    </main>
  );
} 



==== app\(features)\auth\login\page.tsx (257 lines) ====

'use client';

import Image from 'next/image';
import { UserIcon } from '@/components/icons';
import GuestForm from '../components/GuestForm';
import { useState, useEffect } from 'react';
import { signIn } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';

export default function LoginPage() {
  const [showGuestForm, setShowGuestForm] = useState(false);
  const [loadingProvider, setLoadingProvider] = useState<string | null>(null);
  const [browserType, setBrowserType] = useState<'line' | 'facebook' | 'other'>('other');
  const searchParams = useSearchParams();
  const error = searchParams?.get('error') || null;
  const callbackUrl = searchParams?.get('callbackUrl') || '/bookings';

  useEffect(() => {
    // Function to detect browser type
    const detectBrowser = () => {
      const ua = navigator.userAgent.toLowerCase();
      
      // LINE browser detection
      if (ua.includes('line/') || ua.includes('line ')) {
        return 'line';
      }
      
      // Facebook browser detection
      if (ua.includes('fban/') || ua.includes('fbav/') || ua.includes('fbios/')) {
        return 'facebook';
      }

      // Other browsers
      return 'other';
    };

    setBrowserType(detectBrowser());
  }, []);

  // Reset loading state when component unmounts or user navigates back
  useEffect(() => {
    const handlePopState = () => {
      setLoadingProvider(null);
    };

    window.addEventListener('popstate', handlePopState);
    
    return () => {
      window.removeEventListener('popstate', handlePopState);
      setLoadingProvider(null);
    };
  }, []);

  const handleProviderSignIn = async (provider: string) => {
    setLoadingProvider(provider);
    try {
      await signIn(provider, { callbackUrl });
    } catch (error) {
      console.error('Sign in error:', error);
      setLoadingProvider(null);
    }
  };

  const LoadingSpinner = () => (
    <div className="flex items-center justify-center">
      <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin mr-2" />
      <span>Connecting...</span>
    </div>
  );

  return (
    <div className="w-full max-w-md px-6 py-12 bg-white rounded-lg shadow-sm">
      <div className="flex flex-col items-center justify-center">
        <div className="relative w-[180px] h-[60px] mb-8">
          <Image
            src="/images/logo_v1.png"
            alt="LENGOLF Logo"
            fill
            priority
            sizes="180px"
            className="object-contain"
          />
        </div>
        <h2 className="text-center text-2xl font-bold text-gray-900 mb-3">
          Welcome to LENGOLF
        </h2>
        <p className="text-center text-sm text-gray-600 mb-8">
          Please choose a login method to start booking your slot
        </p>
      </div>

      {/* Browser Warning */}
      {browserType !== 'other' && (
        <div className="mb-6 p-4 bg-amber-50 border border-amber-200 rounded-lg">
          <div className="flex items-start gap-2 text-amber-800">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" className="w-5 h-5 mt-0.5 shrink-0">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <span>For the best experience, please open this page in your device's external browser (Safari, Chrome, etc.)</span>
          </div>
        </div>
      )}

      {error && (
        <div className="mb-4 p-4 text-sm text-red-800 bg-red-100 rounded-lg">
          {error === 'OAuthSignin' && 'Error signing in with provider.'}
          {error === 'OAuthCallback' && 'Error during authentication callback.'}
          {error === 'OAuthCreateAccount' && 'Error creating account.'}
          {error === 'EmailCreateAccount' && 'Error creating email account.'}
          {error === 'Callback' && 'Error during authentication callback.'}
          {error === 'Default' && 'An error occurred during authentication.'}
        </div>
      )}

      <div className="space-y-4">
        {/* Show login options based on browser type */}
        {browserType === 'line' ? (
          // LINE browser: Show only LINE login
          <button
            onClick={() => handleProviderSignIn('line')}
            disabled={loadingProvider !== null}
            className="flex w-full items-center justify-center rounded-lg bg-[#00B900] px-4 py-3 text-sm font-medium text-white transition-colors hover:bg-[#00A000] focus:outline-none disabled:opacity-50 disabled:cursor-wait"
          >
            {loadingProvider === 'line' ? (
              <LoadingSpinner />
            ) : (
              <>
                <i className="fab fa-line text-lg mr-3"></i>
                Continue with LINE
              </>
            )}
          </button>
        ) : browserType === 'facebook' ? (
          // Facebook browser: Show only Facebook login
          <button
            onClick={() => handleProviderSignIn('facebook')}
            disabled={loadingProvider !== null}
            className="flex w-full items-center justify-center rounded-lg bg-[#1877F2] px-4 py-3 text-sm font-medium text-white transition-colors hover:bg-[#166FE5] focus:outline-none disabled:opacity-50 disabled:cursor-wait"
          >
            {loadingProvider === 'facebook' ? (
              <LoadingSpinner />
            ) : (
              <>
                <i className="fab fa-facebook text-lg mr-3"></i>
                Continue with Facebook
              </>
            )}
          </button>
        ) : (
          // Normal browser: Show all login options
          <>
            <button
              onClick={() => handleProviderSignIn('google')}
              disabled={loadingProvider !== null}
              className="flex w-full items-center justify-center rounded-lg border border-gray-300 bg-white px-4 py-3 text-sm font-medium text-gray-700 transition-colors hover:bg-gray-50 focus:outline-none disabled:opacity-50 disabled:cursor-wait"
            >
              {loadingProvider === 'google' ? (
                <LoadingSpinner />
              ) : (
                <>
                  <svg className="mr-3 h-5 w-5" viewBox="0 0 24 24">
                    <path
                      d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                      fill="#4285F4"
                    />
                    <path
                      d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                      fill="#34A853"
                    />
                    <path
                      d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                      fill="#FBBC05"
                    />
                    <path
                      d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                      fill="#EA4335"
                    />
                  </svg>
                  Continue with Google
                </>
              )}
            </button>

            <button
              onClick={() => handleProviderSignIn('facebook')}
              disabled={loadingProvider !== null}
              className="flex w-full items-center justify-center rounded-lg bg-[#1877F2] px-4 py-3 text-sm font-medium text-white transition-colors hover:bg-[#166FE5] focus:outline-none disabled:opacity-50 disabled:cursor-wait"
            >
              {loadingProvider === 'facebook' ? (
                <LoadingSpinner />
              ) : (
                <>
                  <i className="fab fa-facebook text-lg mr-3"></i>
                  Continue with Facebook
                </>
              )}
            </button>

            <button
              onClick={() => handleProviderSignIn('line')}
              disabled={loadingProvider !== null}
              className="flex w-full items-center justify-center rounded-lg bg-[#00B900] px-4 py-3 text-sm font-medium text-white transition-colors hover:bg-[#00A000] focus:outline-none disabled:opacity-50 disabled:cursor-wait"
            >
              {loadingProvider === 'line' ? (
                <LoadingSpinner />
              ) : (
                <>
                  <i className="fab fa-line text-lg mr-3"></i>
                  Continue with LINE
                </>
              )}
            </button>
          </>
        )}

        {/* Divider */}
        <div className="relative my-6">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-200" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="bg-white px-6 text-gray-500">Or</span>
          </div>
        </div>

        {/* Guest Login Button */}
        <button
          type="button"
          onClick={() => setShowGuestForm(true)}
          className="flex w-full items-center justify-center rounded-lg bg-gray-800 px-4 py-3 text-sm font-medium text-white transition-colors hover:bg-gray-700 focus:outline-none"
        >
          <UserIcon className="mr-3 h-5 w-5" />
          Continue as Guest
        </button>
      </div>

      {showGuestForm && (
        <GuestForm onClose={() => setShowGuestForm(false)} />
      )}

      {/* Privacy Policy Link */}
      <div className="mt-8 text-center">
        <a 
          href="https://www.len.golf/privacy-policy/" 
          onClick={(e) => {
            e.preventDefault();
            const cleanUrl = 'https://www.len.golf/privacy-policy/';
            window.open(cleanUrl, '_blank', 'noopener,noreferrer');
          }}
          className="text-xs text-gray-400 hover:text-gray-600 transition-colors"
        >
          Privacy Policy
        </a>
      </div>
    </div>
  );
} 



==== app\(features)\bookings\actions.ts (25 lines) ====

import { getCurrentBangkokTime } from '@/utils/date';

export async function getAvailability(date: string) {
  try {
    const response = await fetch('/api/availability', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        date,
        currentTimeInBangkok: getCurrentBangkokTime()
      })
    });

    if (!response.ok) {
      throw new Error('Failed to fetch availability');
    }

    return response.json();
  } catch (error) {
    console.error('Error fetching availability:', error);
    throw error;
  }
} 



==== app\(features)\bookings\components\booking\ConfirmationContent.tsx (200 lines) ====

'use client';

import { format } from 'date-fns';
import dynamic from 'next/dynamic';
import { useRouter } from 'next/navigation';
import { Booking } from '@/types';
import { 
  CheckCircleIcon, 
  CalendarIcon, 
  ClockIcon, 
  UserGroupIcon, 
  UserIcon, 
  PhoneIcon, 
  EnvelopeIcon 
} from '@heroicons/react/24/outline';

// Dynamically import PageTransition with loading fallback
const PageTransition = dynamic(
  () => import('@/components/shared/PageTransition').then(mod => mod.PageTransition),
  {
    loading: () => (
      <div className="animate-pulse">
        <div className="h-8 bg-gray-200 rounded w-1/3 mx-auto mb-4"></div>
        <div className="h-4 bg-gray-200 rounded w-2/3 mx-auto"></div>
      </div>
    ),
    ssr: false
  }
);

interface ConfirmationContentProps {
  booking: Booking;
}

export function ConfirmationContent({ booking }: ConfirmationContentProps) {
  const router = useRouter();

  const handleMakeAnotherBooking = () => {
    router.push('/bookings');
  };

  return (
    <PageTransition>
      <div className="max-w-4xl mx-auto">
        {/* Confirmation Header */}
        <div className="bg-white rounded-xl shadow-sm p-6 mb-6">
          <div className="flex items-center justify-center mb-4">
            <div className="bg-green-100 rounded-full p-3">
              <CheckCircleIcon className="h-8 w-8 text-green-600" />
            </div>
          </div>
          <h2 className="text-2xl font-bold text-center text-gray-900 mb-2">Booking Confirmed!</h2>
          <p className="text-center text-gray-600">Here are your booking details:</p>
        </div>

        {/* Booking Details Cards */}
        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
          {/* Date Card */}
          <div className="bg-white rounded-xl shadow-sm p-4 sm:p-6 border border-green-100">
            <div className="flex items-center gap-3">
              <div className="bg-green-50 p-2 sm:p-3 rounded-full">
                <CalendarIcon className="h-6 w-6 sm:h-8 sm:w-8 text-green-600" />
              </div>
              <div>
                <h3 className="text-sm font-medium text-gray-600">Date</h3>
                <p className="text-lg sm:text-xl font-bold text-green-700">
                  {format(new Date(booking.date), 'MMMM d, yyyy')}
                </p>
              </div>
            </div>
          </div>

          {/* Time Card */}
          <div className="bg-white rounded-xl shadow-sm p-4 sm:p-6 border border-green-100">
            <div className="flex items-center gap-3">
              <div className="bg-green-50 p-2 sm:p-3 rounded-full">
                <ClockIcon className="h-6 w-6 sm:h-8 sm:w-8 text-green-600" />
              </div>
              <div className="min-w-0">
                <h3 className="text-sm font-medium text-gray-600">Time Period</h3>
                <p className="text-lg sm:text-xl font-bold text-green-700 whitespace-nowrap">
                  {booking.start_time} - {format(
                    new Date(`2000-01-01T${booking.start_time}`).getTime() + booking.duration * 60 * 60 * 1000,
                    'HH:mm'
                  )}
                </p>
              </div>
            </div>
          </div>

          {/* People Card */}
          <div className="bg-white rounded-xl shadow-sm p-4 sm:p-6 border border-green-100">
            <div className="flex items-center gap-3">
              <div className="bg-green-50 p-2 sm:p-3 rounded-full">
                <UserGroupIcon className="h-6 w-6 sm:h-8 sm:w-8 text-green-600" />
              </div>
              <div>
                <h3 className="text-sm font-medium text-gray-600">Number of People</h3>
                <p className="text-lg sm:text-xl font-bold text-green-700">
                  {booking.number_of_people}
                </p>
              </div>
            </div>
          </div>
        </div>

        {/* Contact Information */}
        <div className="bg-white rounded-xl shadow-sm p-6 mb-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">Contact Information</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div className="flex items-center gap-3">
              <div className="bg-green-50 p-2 rounded-full">
                <UserIcon className="h-5 w-5 text-green-600" />
              </div>
              <div>
                <p className="text-sm text-gray-600">Name</p>
                <p className="font-semibold text-gray-900">{booking.name}</p>
              </div>
            </div>
            <div className="flex items-center gap-3">
              <div className="bg-green-50 p-2 rounded-full">
                <PhoneIcon className="h-5 w-5 text-green-600" />
              </div>
              <div>
                <p className="text-sm text-gray-600">Phone</p>
                <p className="font-semibold text-gray-900">{booking.phone_number}</p>
              </div>
            </div>
            <div className="sm:col-span-2 flex items-center gap-3">
              <div className="bg-green-50 p-2 rounded-full">
                <EnvelopeIcon className="h-5 w-5 text-green-600" />
              </div>
              <div>
                <p className="text-sm text-gray-600">Email</p>
                <p className="font-semibold text-gray-900">{booking.email}</p>
              </div>
            </div>
            <div className="sm:col-span-2">
              <p className="text-sm text-gray-600 mb-1">Booking ID</p>
              <p className="font-mono text-sm bg-gray-50 p-2 rounded">{booking.id}</p>
            </div>
          </div>
        </div>

        {/* Important Information */}
        <div className="bg-white rounded-xl shadow-sm p-6 mb-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">Important Information</h3>
          
          {/* Email Confirmation Notice */}
          <div className="mb-4 p-3 bg-green-50 rounded-lg">
            <p className="text-green-800">
              A booking confirmation has been sent to your email address: <span className="font-medium">{booking.email}</span>
            </p>
          </div>

          {/* What to Know Section */}
          <div className="space-y-4">
            <div>
              <h4 className="font-medium text-gray-900 mb-2">Before Your Visit</h4>
              <ul className="list-disc pl-5 space-y-2 text-gray-600">
                <li>Please arrive 5-10 minutes early to ensure a smooth check-in process and receive a brief introduction to our facilities.</li>
                <li>Golf clubs are provided free of charge for your convenience.</li>
                <li>Up to 5 players can play on a single bay.</li>
              </ul>
            </div>

            <div>
              <h4 className="font-medium text-gray-900 mb-2">Need to Modify or Cancel?</h4>
              <p className="text-gray-600 mb-2">Contact us through any of these channels:</p>
              <ul className="list-none space-y-2 text-gray-600">
                <li className="flex items-center">
                  <EnvelopeIcon className="h-5 w-5 text-green-600 mr-2" />
                  <a href="mailto:info@len.golf" className="text-green-600 hover:text-green-700">info@len.golf</a>
                </li>
                <li className="flex items-center">
                  <i className="fab fa-line text-xl text-green-600 mr-2"></i>
                  <span>LINE: <a href="https://lin.ee/uxQpIXn" className="text-green-600 hover:text-green-700">@lengolf</a></span>
                </li>
                <li className="flex items-center">
                  <PhoneIcon className="h-5 w-5 text-green-600 mr-2" />
                  <a href="tel:+66966682335" className="text-green-600 hover:text-green-700">+66 96-668-2335</a>
                </li>
              </ul>
            </div>
          </div>
        </div>

        {/* Action Button */}
        <div className="flex justify-center">
          <button
            onClick={handleMakeAnotherBooking}
            className="bg-green-600 text-white py-3 px-6 rounded-lg hover:bg-green-700 transition-colors font-semibold"
          >
            Make Another Booking
          </button>
        </div>
      </div>
    </PageTransition>
  );
} 



==== app\(features)\bookings\components\booking\Layout.tsx (593 lines) ====

'use client';

import { useState, useEffect } from 'react';
import { useSession, signOut, signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/utils/supabase/client';
import { format } from 'date-fns';
import { toast } from 'react-hot-toast';
import { ChevronDownIcon, PhoneIcon, EnvelopeIcon, XMarkIcon, Bars3Icon, CurrencyDollarIcon, AcademicCapIcon, FireIcon } from '@heroicons/react/24/outline';
import Image from 'next/image';
import { Menu } from '@headlessui/react';

interface LayoutProps {
  children: React.ReactNode;
}

export function Layout({ children }: LayoutProps) {
  const router = useRouter();
  const { data: session, status } = useSession();
  const [isLoading, setIsLoading] = useState(false);
  const [showBayRates, setShowBayRates] = useState(false);
  const [showPromotions, setShowPromotions] = useState(false);
  const [showLessons, setShowLessons] = useState(false);
  const [currentPromoIndex, setCurrentPromoIndex] = useState(0);

  // Sample promotion images - this would be replaced with your actual promotion images
  const promotionImages = [
    '/images/promotion.jpg',
    '/images/promotion_1.jpg',
    '/images/promotion_2.jpg',
    // Additional promotion images can be added here
  ];
  
  // Control body scroll when modals are open
  useEffect(() => {
    if (showBayRates || showPromotions || showLessons) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'auto';
    }
    
    return () => {
      document.body.style.overflow = 'auto';
    };
  }, [showBayRates, showPromotions, showLessons]);

  const handleSignOut = async () => {
    setIsLoading(true);
    try {
      await signOut({ redirect: false });
      router.push('/auth/login');
    } catch (error) {
      console.error('Error signing out:', error);
      toast.error('Failed to sign out. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  if (status === 'loading') {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="w-16 h-16 border-4 border-green-600 border-t-transparent rounded-full animate-spin"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      {/* Header */}
      <header className="bg-green-800 text-white">
        <div className="mx-auto max-w-7xl px-4 py-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center">
            {/* Show full text on desktop, just "LENGOLF" on mobile */}
            <h1 className="text-2xl font-bold">
              <button 
                onClick={() => router.push('/bookings')} 
                className="hover:opacity-80 transition-opacity"
              >
                <span className="md:hidden">LENGOLF</span>
                <span className="hidden md:inline">LENGOLF Booking</span>
              </button>
            </h1>
            
            <div className="flex items-center gap-4">
              <div className="hidden md:flex gap-4 items-center">
                <button
                  onClick={() => setShowBayRates(!showBayRates)}
                  className="text-white px-3 py-1.5 rounded-full border-2 border-white hover:bg-white hover:text-green-800 transition-colors flex items-center gap-1 font-medium"
                >
                  <CurrencyDollarIcon className="h-5 w-5" />
                  <span>Bay Rates</span>
                </button>
                
                <button
                  onClick={() => setShowPromotions(!showPromotions)}
                  className="text-white px-3 py-1.5 rounded-full border-2 border-white hover:bg-white hover:text-green-800 transition-colors flex items-center gap-1 font-medium"
                >
                  <FireIcon className="h-5 w-5" />
                  <span>Promotions</span>
                </button>
                
                <button
                  onClick={() => setShowLessons(!showLessons)}
                  className="text-white px-3 py-1.5 rounded-full border-2 border-white hover:bg-white hover:text-green-800 transition-colors flex items-center gap-1 font-medium"
                >
                  <AcademicCapIcon className="h-5 w-5" />
                  <span>Lessons</span>
                </button>
              </div>
              
              {/* Mobile Buttons Row - Only show Rates and Promotions */}
              <div className="md:hidden flex gap-2">
                <button
                  onClick={() => setShowBayRates(!showBayRates)}
                  className="px-3 py-1 rounded-full border-2 border-white text-sm font-medium hover:bg-white hover:text-green-800 transition-colors flex items-center"
                >
                  <CurrencyDollarIcon className="h-4 w-4 mr-1" />
                  Rates
                </button>
                
                <button
                  onClick={() => setShowPromotions(!showPromotions)}
                  className="px-3 py-1 rounded-full border-2 border-white text-sm font-medium hover:bg-white hover:text-green-800 transition-colors flex items-center"
                >
                  <FireIcon className="h-4 w-4 mr-1" />
                  Promos
                </button>
              </div>
              
              {/* --- Desktop Auth Buttons --- */}
              <div className="hidden md:flex gap-4 items-center">
                <a 
                  href="https://www.len.golf" 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-white hover:text-gray-200"
                >
                  Home Page
                </a>
                {status === 'authenticated' ? (
                  <button onClick={handleSignOut} className="text-white hover:text-gray-200">Logout</button>
                ) : (
                  <button onClick={() => signIn()} className="text-white hover:text-gray-200">Login</button>
                )}
              </div>
              <div className="md:hidden">
                <Menu as="div" className="relative">
                  <Menu.Button className="flex items-center text-white hover:text-gray-200">
                    <span className="sr-only">Open menu</span>
                    <Bars3Icon className="h-6 w-6" />
                  </Menu.Button>
                  <Menu.Items className="absolute right-0 mt-2 w-48 origin-top-right rounded-md bg-white py-1 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
                    <Menu.Item>
                      {({ active }) => (
                        <a
                          href="https://www.len.golf"
                          target="_blank"
                          rel="noopener noreferrer"
                          className={`${
                            active ? 'bg-gray-100' : ''
                          } block px-4 py-2 text-sm text-gray-700`}
                        >
                          Home Page
                        </a>
                      )}
                    </Menu.Item>
                    <Menu.Item>
                      {({ active }) => (
                        <button
                          onClick={() => setShowLessons(!showLessons)}
                          className={`${
                            active ? 'bg-gray-100' : ''
                          } block w-full text-left px-4 py-2 text-sm text-gray-700 flex items-center`}
                        >
                          <AcademicCapIcon className="h-4 w-4 mr-2" />
                          Golf Lessons
                        </button>
                      )}
                    </Menu.Item>
                    {/* --- Correct Conditional Auth Menu Item --- */}
                    {status === 'authenticated' && (
                      <Menu.Item>
                        {({ active }) => (
                          <button
                            onClick={handleSignOut}
                            className={`${
                              active ? 'bg-gray-100' : ''
                            } block w-full text-left px-4 py-2 text-sm text-gray-700`}
                          >
                            Logout
                          </button>
                        )}
                      </Menu.Item>
                    )}
                    {status !== 'authenticated' && (
                      <Menu.Item>
                        {({ active }) => (
                          <button
                            onClick={() => signIn()}
                            className={`${
                              active ? 'bg-gray-100' : ''
                            } block w-full text-left px-4 py-2 text-sm text-gray-700`}
                          >
                            Login
                          </button>
                        )}
                      </Menu.Item>
                    )}
                    {/* --- End Correct Conditional --- */}
                  </Menu.Items>
                </Menu>
              </div>
            </div>
          </div>
        </div>
      </header>

      {/* Bay Rates Modal */}
      {showBayRates && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={() => setShowBayRates(false)}>
          <div className="bg-white rounded-xl p-4 max-w-2xl w-full mx-4 md:mx-auto" onClick={e => e.stopPropagation()}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl md:text-2xl font-bold text-gray-900 flex items-center">
                <CurrencyDollarIcon className="h-6 w-6 mr-2 text-green-600" />
                Bay Rates
              </h3>
              <button onClick={() => setShowBayRates(false)} className="text-gray-500 hover:text-gray-700">
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            <div className="relative">
              <Image
                src="/images/lengolf_bay_rate.jpg"
                alt="LENGOLF Bay Rates"
                width={800}
                height={600}
                className="rounded-xl w-full h-auto object-contain"
                priority
              />
            </div>
          </div>
        </div>
      )}

      {/* Promotions Modal */}
      {showPromotions && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={() => setShowPromotions(false)}>
          <div className="bg-white rounded-xl p-4 max-w-2xl w-full mx-4 md:mx-auto" onClick={e => e.stopPropagation()}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl md:text-2xl font-bold text-gray-900 flex items-center">
                <FireIcon className="h-6 w-6 mr-2 text-green-600" />
                Promotions
              </h3>
              <button onClick={() => setShowPromotions(false)} className="text-gray-500 hover:text-gray-700">
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            <div className="relative">
              {promotionImages.length > 0 ? (
                <div className="relative">
                  <Image
                    src={promotionImages[currentPromoIndex]}
                    alt={`LENGOLF Promotion ${currentPromoIndex + 1}`}
                    width={800}
                    height={600}
                    className="rounded-xl w-full h-auto object-contain"
                    priority
                  />
                  
                  {/* Navigation arrows (only show if there's more than one promotion) */}
                  {promotionImages.length > 1 && (
                    <div className="absolute inset-0 flex items-center justify-between pointer-events-none">
                      <button 
                        onClick={(e) => {
                          e.stopPropagation();
                          setCurrentPromoIndex((prevIndex) => 
                            prevIndex === 0 ? promotionImages.length - 1 : prevIndex - 1
                          );
                        }}
                        className="bg-black bg-opacity-40 hover:bg-opacity-60 text-white p-2 rounded-full ml-2 pointer-events-auto"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" className="w-5 h-5">
                          <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                        </svg>
                      </button>
                      <button 
                        onClick={(e) => {
                          e.stopPropagation();
                          setCurrentPromoIndex((prevIndex) => 
                            (prevIndex + 1) % promotionImages.length
                          );
                        }}
                        className="bg-black bg-opacity-40 hover:bg-opacity-60 text-white p-2 rounded-full mr-2 pointer-events-auto"
                      >
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" className="w-5 h-5">
                          <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                        </svg>
                      </button>
                    </div>
                  )}
                  
                  {/* Dots indicators (only show if there's more than one promotion) */}
                  {promotionImages.length > 1 && (
                    <div className="absolute bottom-3 left-0 right-0 flex justify-center gap-2">
                      {promotionImages.map((_, index) => (
                        <button
                          key={index}
                          onClick={(e) => {
                            e.stopPropagation();
                            setCurrentPromoIndex(index);
                          }}
                          className={`w-2.5 h-2.5 rounded-full pointer-events-auto ${
                            currentPromoIndex === index ? 'bg-white' : 'bg-white bg-opacity-50'
                          }`}
                        />
                      ))}
                    </div>
                  )}
                </div>
              ) : (
                <div className="text-center py-10 bg-gray-50 rounded-xl">
                  <p className="text-gray-500">No promotions available at the moment.</p>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Lessons Modal */}
      {showLessons && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={() => setShowLessons(false)}>
          <div className="bg-white rounded-xl p-4 max-w-2xl w-full mx-4 md:mx-auto" onClick={e => e.stopPropagation()}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl md:text-2xl font-bold text-gray-900 flex items-center">
                <AcademicCapIcon className="h-6 w-6 mr-2 text-green-600" />
                Golf Lessons
              </h3>
              <button onClick={() => setShowLessons(false)} className="text-gray-500 hover:text-gray-700">
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            <div className="p-2 bg-white rounded-xl">
              <div className="text-center mb-4">
                <Image
                  src="/images/coaching_1.jpg"
                  alt="LENGOLF Lessons"
                  width={500}
                  height={375}
                  className="rounded-xl w-auto h-auto mx-auto object-contain mb-4"
                />
                <h4 className="text-lg font-semibold text-gray-900 mb-2">Book Professional Golf Lessons</h4>
                <p className="text-gray-600 mb-4">
                  Improve your golf skills with our professional instructors. 
                  Various lesson packages available for beginners to advanced players.
                  <span className="font-medium block mt-1">Golf lessons can only be booked via LINE.</span>
                </p>
                <div className="flex flex-col sm:flex-row justify-center gap-3 mb-4">
                  <a 
                    href="https://lin.ee/uxQpIXn"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center justify-center gap-2 bg-[#06C755] text-white px-4 py-2 rounded-lg hover:bg-[#05b04e] transition-colors"
                  >
                    <i className="fab fa-line text-xl"></i>
                    Contact via LINE
                  </a>
                  <a 
                    href="https://www.len.golf/lessons"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center justify-center gap-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                      <path strokeLinecap="round" strokeLinejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" />
                    </svg>
                    View for more information
                  </a>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Main Content */}
      <main className="flex-grow mx-auto w-full max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
        {children}
      </main>

      {/* Footer */}
      <footer className="bg-white border-t mt-auto">
        <div className="mx-auto max-w-7xl px-4 py-8 sm:px-6 lg:px-8">
          {/* Desktop Footer */}
          <div className="hidden md:grid md:grid-cols-4 gap-8">
            {/* Logo and Address */}
            <div className="flex flex-col">
              <a href="https://www.len.golf" className="mb-4">
                <Image
                  src="/images/logo_v1.png"
                  alt="LENGOLF Logo"
                  width={150}
                  height={50}
                  className="w-auto h-auto"
                />
              </a>
              <a 
                href="https://maps.app.goo.gl/M7ygv921XyzcQwBE8" 
                target="_blank" 
                rel="noopener noreferrer"
                className="text-gray-600 hover:text-gray-800"
              >
                The Mercury Ville @ BTS Chidlom<br />
                Floor 4
              </a>
            </div>

            {/* Opening Hours */}
            <div>
              <h5 className="text-[#005a32] font-semibold mb-3">Opening Hours</h5>
              <p className="text-gray-600">
                10am - 11pm<br />
                Monday - Sunday
              </p>
            </div>

            {/* Keep in Touch */}
            <div>
              <h5 className="text-[#005a32] font-semibold mb-3">Keep in Touch</h5>
              <div className="text-gray-600 space-y-2">
                <a 
                  href="https://www.len.golf" 
                  className="block hover:text-gray-800"
                >
                  www.len.golf
                </a>
                <p className="flex items-center">
                  <PhoneIcon className="h-4 w-4 mr-2 text-[#005a32]" />
                  096-668-2335
                </p>
                <a 
                  href="mailto:info@len.golf" 
                  className="flex items-center hover:text-gray-800"
                >
                  <EnvelopeIcon className="h-4 w-4 mr-2 text-[#005a32]" />
                  info@len.golf
                </a>
                <a 
                  href="https://www.len.golf/privacy-policy/" 
                  target="_blank"
                  rel="noopener noreferrer"
                  className="flex items-center hover:text-gray-800"
                >
                  <svg className="h-4 w-4 mr-2 text-[#005a32]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V7a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                  </svg>
                  Privacy Policy
                </a>
              </div>
            </div>

            {/* Social Media */}
            <div>
              <h5 className="text-[#005a32] font-semibold mb-3">Follow Us</h5>
              <div className="flex space-x-4">
                <a 
                  href="https://www.facebook.com/lengolf.bkk" 
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-[#005a32] hover:text-[#007a42] transition-colors"
                >
                  <i className="fab fa-facebook-f text-xl"></i>
                </a>
                <a 
                  href="https://lin.ee/uxQpIXn" 
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-[#005a32] hover:text-[#007a42] transition-colors"
                >
                  <i className="fab fa-line text-xl"></i>
                </a>
                <a 
                  href="https://www.instagram.com/lengolf.bkk/" 
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-[#005a32] hover:text-[#007a42] transition-colors"
                >
                  <i className="fab fa-instagram text-xl"></i>
                </a>
              </div>
            </div>
          </div>

          {/* Mobile Footer */}
          <div className="md:hidden space-y-6">
            {/* Logo */}
            <div className="flex justify-center">
              <Image
                src="/images/logo_v1.png"
                alt="LENGOLF Logo"
                width={120}
                height={40}
                className="w-auto h-auto"
              />
            </div>

            {/* Address */}
            <div className="text-center">
              <a 
                href="https://maps.app.goo.gl/M7ygv921XyzcQwBE8" 
                target="_blank" 
                rel="noopener noreferrer"
                className="text-gray-600"
              >
                The Mercury Ville @ BTS Chidlom<br />
                Floor 4
              </a>
            </div>

            {/* Opening Hours */}
            <div className="text-center">
              <h5 className="text-[#005a32] font-semibold mb-2">Opening Hours</h5>
              <p className="text-gray-600">
                10am - 11pm<br />
                Monday - Sunday
              </p>
            </div>

            {/* Contact Info */}
            <div className="text-center space-y-2">
              <h5 className="text-[#005a32] font-semibold mb-2">Keep in Touch</h5>
              <a 
                href="https://www.len.golf" 
                className="block text-gray-600"
              >
                www.len.golf
              </a>
              <p className="text-gray-600">
                <i className="fas fa-phone text-[#005a32] mr-2"></i>
                096-668-2335
              </p>
              <a 
                href="mailto:info@len.golf" 
                className="block text-gray-600"
              >
                <i className="fas fa-envelope text-[#005a32] mr-2"></i>
                info@len.golf
              </a>
              <a 
                href="https://www.len.golf/privacy-policy/" 
                target="_blank"
                rel="noopener noreferrer"
                className="block text-gray-600"
              >
                <i className="fas fa-file-alt text-[#005a32] mr-2"></i>
                Privacy Policy
              </a>
            </div>

            {/* Social Media Icons */}
            <div className="flex justify-center space-x-6">
              <a 
                href="https://www.facebook.com/lengolf.bkk" 
                target="_blank"
                rel="noopener noreferrer"
                className="text-[#005a32] text-xl"
              >
                <i className="fab fa-facebook-f"></i>
              </a>
              <a 
                href="https://lin.ee/uxQpIXn" 
                target="_blank"
                rel="noopener noreferrer"
                className="text-[#005a32] text-xl"
              >
                <i className="fab fa-line"></i>
              </a>
              <a 
                href="https://www.instagram.com/lengolf.bkk/" 
                target="_blank"
                rel="noopener noreferrer"
                className="text-[#005a32] text-xl"
              >
                <i className="fab fa-instagram"></i>
              </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  );
} 



==== app\(features)\bookings\components\booking\steps\BookingDetails.tsx (659 lines) ====

'use client';

import { useState, useEffect } from 'react';
import { CalendarIcon, ClockIcon } from '@heroicons/react/24/outline';
import { format, addHours } from 'date-fns';
import { createClient } from '@/utils/supabase/client';
import { useRouter } from 'next/navigation';
import { User } from '@supabase/supabase-js';
import { toast } from 'react-hot-toast';
import { useSession } from 'next-auth/react';
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';
import type { Session } from 'next-auth';
import { matchProfileWithCrm } from '@/utils/customer-matching';
import PhoneInput, { isValidPhoneNumber } from 'react-phone-number-input';
import 'react-phone-number-input/style.css';

interface Profile {
  name: string;
  email: string | null;
  phone_number: string | null;
  display_name: string;
  updated_at?: string;
}

// Define the session user type to match what we actually have
interface ExtendedUser {
  id: string;
  name?: string | null;
  email?: string | null;
  image?: string | null;
  provider?: string;
  phone?: string | null;
}

interface ExtendedSession extends Omit<Session, 'user'> {
  user: ExtendedUser;
  accessToken?: string;  // Add accessToken to the session type
}

interface BookingDetailsProps {
  selectedDate: Date;
  selectedTime: string;
  maxDuration: number;
  onBack: () => void;
}

// Add loading animation components
const LoadingOverlay = ({ steps, currentStep }: { steps: string[], currentStep: number }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 max-w-md w-full shadow-xl">
        <div className="text-center mb-4">
          <div className="inline-block animate-bounce">
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-green-600">
              <circle cx="12" cy="8" r="7" />
              <polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88" />
            </svg>
          </div>
          <h3 className="text-xl font-bold mt-2">Confirming Your Booking</h3>
          <p className="text-gray-600">Please wait while we process your reservation</p>
        </div>
        
        <div className="space-y-4">
          {steps.map((step, index) => (
            <div key={index} className="flex items-center">
              <div className={`flex-shrink-0 h-8 w-8 rounded-full flex items-center justify-center ${
                index < currentStep ? 'bg-green-100 text-green-600' : 
                index === currentStep ? 'bg-green-600 text-white animate-pulse' : 
                'bg-gray-100 text-gray-400'
              }`}>
                {index < currentStep ? (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                ) : (
                  <span>{index + 1}</span>
                )}
              </div>
              <div className="ml-4">
                <p className={`font-medium ${
                  index < currentStep ? 'text-green-600' : 
                  index === currentStep ? 'text-gray-900' : 
                  'text-gray-400'
                }`}>
                  {step}
                </p>
              </div>
            </div>
          ))}
        </div>
        
        <div className="mt-6">
          <div className="w-full bg-gray-200 rounded-full h-2.5">
            <div 
              className="bg-green-600 h-2.5 rounded-full transition-all duration-500 ease-in-out" 
              style={{ width: `${Math.min((currentStep / (steps.length - 1)) * 100, 100)}%` }}
            ></div>
          </div>
        </div>
      </div>
    </div>
  );
};

export function BookingDetails({
  selectedDate,
  selectedTime,
  maxDuration,
  onBack,
}: BookingDetailsProps) {
  const router = useRouter();
  const { data: session, status } = useSession() as { data: ExtendedSession | null, status: 'loading' | 'authenticated' | 'unauthenticated' };
  const [duration, setDuration] = useState<number>(1);
  const [profile, setProfile] = useState<Profile | null>(null);
  const [phoneNumber, setPhoneNumber] = useState<string | undefined>(undefined);
  const [email, setEmail] = useState('');
  const [name, setName] = useState('');
  const [numberOfPeople, setNumberOfPeople] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [loadingStep, setLoadingStep] = useState(0);
  const [showLoadingOverlay, setShowLoadingOverlay] = useState(false);
  const [customerNotes, setCustomerNotes] = useState('');
  const [errors, setErrors] = useState({
    duration: '',
    phoneNumber: '',
    email: '',
    name: '',
  });
  const [showNoAvailabilityModal, setShowNoAvailabilityModal] = useState(false);
  const [crmCustomerId, setCrmCustomerId] = useState<string | null>(null);
  const [hasBookingError, setHasBookingError] = useState(false);
  const loadingSteps = [
    "Checking availability",
    "Creating your booking",
    "Sending notifications",
    "Booking confirmed!"
  ];

  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  useEffect(() => {
    const fetchProfile = async () => {
      if (session?.user?.id) {
        try {
          const userId = session.user.id;
          const supabase = createClient();
          const { data, error } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', userId)
            .single();

          if (error) {
            console.error('Error fetching profile:', error);
          } else if (data) {
            // Set the profile data
            setProfile(data);
            
            // Prefill the form with user data
            setName(data.display_name || data.name || session?.user?.name || '');
            setEmail(data.email || session?.user?.email || '');
            
            let initialPhoneNumber = data.phone_number || session?.user?.phone || '';
            if (initialPhoneNumber && !initialPhoneNumber.startsWith('+')) {
              // Basic assumption: if it's a 10-digit number starting with 0, assume it's a Thai number
              if (initialPhoneNumber.length === 10 && initialPhoneNumber.startsWith('0')) {
                initialPhoneNumber = '+66' + initialPhoneNumber.substring(1);
              }
              // Add more rules if necessary for other common local formats
            }
            setPhoneNumber(initialPhoneNumber || undefined); // Set to undefined if empty for placeholder to show
            
            // Get any existing CRM mapping from our database directly
            // Skip the unnecessary API call to /api/crm/match which is slow
            try {
              const { data: mapping } = await supabase
                .from('crm_customer_mapping')
                .select('crm_customer_id')
                .eq('profile_id', userId)
                .eq('is_matched', true)
                .maybeSingle();
                
              if (mapping?.crm_customer_id) {
                setCrmCustomerId(mapping.crm_customer_id);
              }
            } catch (error) {
              console.error('Error checking CRM mapping:', error);
            }
          }
        } catch (err) {
          console.error('Failed to fetch profile:', err);
        }
      }
    };

    fetchProfile();
  }, [session?.user?.id, session?.user?.name, session?.user?.email, session?.user?.phone]);

  useEffect(() => {
    if (isSubmitting && loadingStep < loadingSteps.length - 1) {
      // Create a more consistent animation with timed steps
      const stepTimes = [1000, 1500, 1500]; // Time to spend on each step
      const timer = setTimeout(() => {
        setLoadingStep(prevStep => {
          const nextStep = prevStep + 1;
          return Math.min(nextStep, loadingSteps.length - 2);
        });
      }, stepTimes[loadingStep] || 1000);
      return () => clearTimeout(timer);
    }
  }, [isSubmitting, loadingStep, loadingSteps.length]);

  const validateForm = () => {
    let currentErrors = { duration: '', phoneNumber: '', email: '', name: '' };
    let isValid = true;

    if (!name) {
      currentErrors.name = 'Name is required';
      isValid = false;
    }
    if (!email) {
      currentErrors.email = 'Email is required';
      isValid = false;
    }
    // Updated phone number validation
    if (!phoneNumber) {
      currentErrors.phoneNumber = 'Phone number is required';
      isValid = false;
    } else if (!isValidPhoneNumber(phoneNumber)) {
      currentErrors.phoneNumber = 'Please enter a valid phone number';
      isValid = false;
    }

    setErrors(currentErrors);

    if (!isValid) {
      // Consolidate toast messages or show one generic message
      toast.error('Please fill in all required fields correctly.');
    }
    return isValid;
  };

  const generateBookingId = () => {
    const timestamp = new Date().toISOString().slice(2, 10).replace(/-/g, '');
    const randomNum = Math.random().toString(36).substring(2, 6).toUpperCase();
    return `BK${timestamp}${randomNum}`;
  };

  // Helper function to ensure minimum animation duration
  const ensureMinimumAnimationDuration = async (startTime: number, minDuration: number = 3000) => {
    const elapsedTime = Date.now() - startTime;
    if (elapsedTime < minDuration) {
      await new Promise(resolve => setTimeout(resolve, minDuration - elapsedTime));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) {
      return;
    }

    if (!session) {
      toast.error('Please sign in to continue');
      router.push('/auth/signin');
      return;
    }

    // Start timing the submission process
    const submissionStartTime = Date.now();
    setIsSubmitting(true);
    setShowLoadingOverlay(true);
    setLoadingStep(0);
    
    try {
      if (!session?.user?.id) {
        throw new Error('User not authenticated');
      }
      
      // Check if we need to update the user profile
      const profileNeedsUpdate = 
        profile && (
          profile.name !== name || 
          profile.email !== email || 
          profile.phone_number !== phoneNumber ||
          profile.display_name !== name
        );
      
      // Update profile if needed
      if (profileNeedsUpdate && session?.user?.id) {
        const supabase = createClient();
        
        try {
          // Only update fields that we know exist in the schema
          const { data, error } = await supabase
            .from('profiles')
            .update({
              display_name: name,
              email: email,
              phone_number: phoneNumber,
              updated_at: new Date().toISOString()
            })
            .eq('id', session.user.id);
        } catch (queryError) {
          // Silent error handling to avoid exposing to users
        }
      }

      // Step 1: Create the booking record
      setLoadingStep(0); // Checking availability
      const createResponse = await fetch('/api/bookings/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session?.accessToken || ''}`
        },
        body: JSON.stringify({
          date: format(selectedDate, 'yyyy-MM-dd'),
          start_time: selectedTime,
          duration,
          number_of_people: numberOfPeople,
          name,
          email,
          phone_number: phoneNumber,
          customer_notes: customerNotes
        })
      });
      
      if (!createResponse.ok) {
        let errorMessage = 'Failed to create booking';
        try {
          const errorData = await createResponse.json();
          if (errorData.error) {
            errorMessage = errorData.error;
          }
        } catch (parseError) {
          errorMessage = `API Error: ${createResponse.status} ${createResponse.statusText}`;
        }
        throw new Error(errorMessage);
      }
      
      const createData = await createResponse.json();
      
      // Check if booking data exists in the response
      if (!createData || !createData.booking) {
        throw new Error('Invalid response from booking creation');
      }
      
      const { booking, bayDisplayName, notificationsSuccess } = createData;
      
      if (createData.crmCustomerId) {
        setCrmCustomerId(createData.crmCustomerId);
      }
      
      // If notifications failed, show a warning but continue
      if (notificationsSuccess === false) {
        toast.error('Your booking was created, but there was an issue sending confirmation messages. Staff will be in touch shortly.');
      }
      
      // Step 2: Ensure we've shown the processing steps long enough for a good UX
      await ensureMinimumAnimationDuration(submissionStartTime, 3000);
      
      // Step 3: Booking confirmed, set to final step
      setLoadingStep(loadingSteps.length - 1);
      
      // Wait for a moment to let the user see the confirmation step
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Redirect to confirmation page
      const url = `/bookings/confirmation?id=${booking.id}`;
      router.push(url);
      
    } catch (error) {
      console.error('Error in booking process:', error);
      toast.error(error instanceof Error ? error.message : 'An error occurred during booking');
      setIsSubmitting(false);
      setShowLoadingOverlay(false);
    }
  };

  const formatDate = (date: Date) => {
    return format(date, 'EEE, do MMM yyyy');
  };

  const isLineUser = session?.user?.provider === 'line';

  // Show loading state while session is being fetched
  if (status === 'loading') {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500"></div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Selected Info Cards */}
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div className="bg-white rounded-xl shadow-sm p-4 sm:p-6 border border-green-100">
          <div className="flex items-center gap-3">
            <div className="bg-green-50 p-2 sm:p-3 rounded-full">
              <CalendarIcon className="h-6 w-6 sm:h-8 sm:w-8 text-green-600" />
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-600">Selected Date</h3>
              <p className="text-lg sm:text-xl font-bold text-green-700">
                {formatDate(selectedDate)}
              </p>
            </div>
          </div>
        </div>
        
        <div className="bg-white rounded-xl shadow-sm p-4 sm:p-6 border border-green-100">
          <div className="flex items-center gap-3">
            <div className="bg-green-50 p-2 sm:p-3 rounded-full">
              <ClockIcon className="h-6 w-6 sm:h-8 sm:w-8 text-green-600" />
            </div>
            <div>
              <h3 className="text-sm font-medium text-gray-600">Start Time</h3>
              <p className="text-lg sm:text-xl font-bold text-green-700">
                {selectedTime}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Booking Form */}
      <form onSubmit={handleSubmit} className="space-y-6 bg-white rounded-xl shadow-sm p-4 sm:p-6">
        {/* Duration Selection */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Duration (in hours)
          </label>
          <div className="grid grid-cols-5 gap-2">
            {Array.from({ length: maxDuration }, (_, i) => i + 1).map((hours) => (
              <button
                key={hours}
                type="button"
                onClick={() => setDuration(hours)}
                className={`flex h-12 items-center justify-center rounded-lg border ${
                  duration === hours
                    ? 'border-green-600 bg-green-50 text-green-600 font-medium'
                    : 'border-gray-300 text-gray-700 hover:border-green-600'
                }`}
              >
                {hours}
              </button>
            ))}
          </div>
          {errors.duration && (
            <p className="mt-1 text-sm text-red-600">{errors.duration}</p>
          )}
        </div>

        {/* Number of People */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Number of People
          </label>
          <div className="grid grid-cols-5 gap-2">
            {[1, 2, 3, 4, 5].map((num) => (
              <button
                key={num}
                type="button"
                onClick={() => setNumberOfPeople(num)}
                className={`flex h-12 items-center justify-center rounded-lg border ${
                  numberOfPeople === num
                    ? 'border-green-600 bg-green-50 text-green-600 font-medium'
                    : 'border-gray-300 text-gray-700 hover:border-green-600'
                }`}
              >
                {num}
              </button>
            ))}
          </div>
        </div>

        {/* Contact Information Section */}
        <div className="pt-4 border-t border-gray-200">
          <h3 className="text-sm font-semibold text-gray-900 mb-4">Contact Information</h3>
          
          <div className="space-y-4">
            {/* Name field */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Name
              </label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className={`w-full h-12 px-4 rounded-lg bg-gray-50 focus:outline-none ${
                  !name ? 'border-red-100' : 'border-green-500'
                } border focus:border-green-500 focus:ring-1 focus:ring-green-500`}
                placeholder="Enter your name"
              />
            </div>

            {/* Phone Number */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Phone Number
              </label>
              <div className="relative">
                <PhoneInput
                  international
                  defaultCountry="TH"
                  placeholder="Enter phone number"
                  value={phoneNumber}
                  onChange={setPhoneNumber}
                  className={`w-full h-12 px-3 py-2 rounded-lg bg-gray-50 focus:outline-none border focus:border-green-500 focus:ring-1 focus:ring-green-500 custom-phone-input ${
                    errors.phoneNumber 
                      ? 'border-red-500' 
                      : (phoneNumber && isValidPhoneNumber(phoneNumber || '')) 
                      ? 'border-green-500' 
                      : 'border-gray-200'
                  }`}
                />
              </div>
              {/* Helper text to guide country selection if number is empty */}
              {!phoneNumber && (
                <p className="mt-1 text-xs text-gray-500">
                  Please select your country code and enter your phone number.
                </p>
              )}
              {errors.phoneNumber && (
                <p className="mt-1 text-sm text-red-600">{errors.phoneNumber}</p>
              )}
            </div>

            {/* Email */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Email Address
              </label>
              <div className="relative">
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className={`w-full h-12 px-4 rounded-lg bg-gray-50 focus:outline-none ${
                    !email
                      ? 'border border-red-100 focus:border-green-500 focus:ring-1 focus:ring-green-500'
                      : 'border border-green-500'
                  }`}
                  placeholder={isLineUser ? "Enter your email address" : "your@email.com"}
                />
              </div>
              <p className="mt-1 text-xs text-gray-500">
              Booking confirmation will be sent to this email
              </p>
              {errors.email && (
                <p className="mt-1 text-sm text-red-600">{errors.email}</p>
              )}
            </div>
          </div>
        </div>

        {/* Add Customer Notes/Special Requests field */}
        <div>
          <label htmlFor="customerNotes" className="block text-sm font-medium text-gray-700 mb-1">
            Notes / Requests (Optional)
          </label>
          <textarea
            id="customerNotes"
            value={customerNotes}
            onChange={(e) => setCustomerNotes(e.target.value)}
            rows={3}
            className="w-full px-4 py-2 rounded-lg bg-gray-50 border border-gray-200 focus:border-green-500 focus:ring-1 focus:ring-green-500 focus:outline-none text-sm sm:text-base"
            placeholder="e.g., specific club preferences, coaching add-on interest, specific simulator bay?"
          />
          <p className="mt-1 text-xs sm:text-sm text-gray-500">
            Mention specific club preferences, promotions, coaching interest, or other requests here.
          </p>
        </div>

        {/* Fine print about communications */}
        <div className="mt-2">
          <p className="text-xs text-gray-500">
            By placing a booking, you agree to receive communications regarding your booking status. If this is your first booking, you will also receive a follow-up message inviting you to rate your visit.
          </p>
        </div>

        {/* Submit Button */}
        <div className="flex space-x-3 justify-end mt-6">
          <button
            type="button"
            onClick={onBack}
            className="py-2 px-4 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2"
            disabled={isSubmitting}
          >
            Back
          </button>
          <button
            type="submit"
            disabled={
              isSubmitting || 
              !duration || 
              !phoneNumber || 
              !isValidPhoneNumber(phoneNumber || '') ||
              !name ||
              !email
            }
            className={`py-2 px-6 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 ${
              isSubmitting
                ? 'bg-green-600 opacity-75'
                : (duration && phoneNumber && isValidPhoneNumber(phoneNumber || '') && name && email)
                ? 'bg-green-600 hover:bg-green-700'
                : 'bg-gray-300 text-gray-500 cursor-not-allowed'
            }`}
          >
            {isSubmitting ? 'Processing...' : 'Confirm Booking'}
          </button>
        </div>
      </form>

      {/* No Availability Modal */}
      {showNoAvailabilityModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl p-6 max-w-md w-full mx-4">
            <div className="text-center">
              <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
                <ClockIcon className="h-6 w-6 text-red-600" />
              </div>
              <h3 className="text-lg font-semibold text-gray-900 mb-2">
                Bay Not Available
              </h3>
              <p className="text-sm text-gray-500 mb-6">
                All bays are currently booked for this time slot.
              </p>
              <button
                onClick={() => {
                  setShowNoAvailabilityModal(false);
                  onBack();
                }}
                className="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium transition-colors"
              >
                Select Another Time
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Add the loading overlay */}
      {showLoadingOverlay && (
        <LoadingOverlay steps={loadingSteps} currentStep={loadingStep} />
      )}
    </div>
  );
}



==== app\(features)\bookings\components\booking\steps\DateSelection.tsx (289 lines) ====

'use client';

import { useState } from 'react';
import { format, addDays } from 'date-fns';
import Image from 'next/image';
import {
  CalendarIcon,
  ClockIcon,
  SunIcon,
  UserGroupIcon,
  ShoppingBagIcon,
} from '@heroicons/react/24/outline';
import { DayPicker } from 'react-day-picker';
import 'react-day-picker/dist/style.css';

interface DateSelectionProps {
  onDateSelect: (date: Date) => void;
}

export function DateSelection({ onDateSelect }: DateSelectionProps) {
  const today = new Date();
  const tomorrow = addDays(today, 1);
  const [showCalendar, setShowCalendar] = useState(false);

  const formatDateLong = (date: Date) => format(date, 'do MMMM yyyy');

  return (
    <div className="w-full px-2 sm:px-4 space-y-8">
      {/* Cards */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
        {/* Today Card */}
        <button
          onClick={() => onDateSelect(today)}
          className="bg-white border-2 border-gray-200 rounded-xl hover:border-green-500 hover:shadow-lg transition-all duration-300 text-left w-full min-w-full"
        >
          <div className="flex items-start p-4 sm:p-6">
            <div className="bg-green-50 p-2 rounded-full shrink-0">
              <ClockIcon className="h-6 w-6 text-green-600" />
            </div>
            <div className="ml-3 leading-normal">
              <div className="text-lg sm:text-xl font-bold text-green-800">Today</div>
              <div className="text-gray-600">{formatDateLong(today)}</div>
            </div>
          </div>
        </button>

        {/* Tomorrow Card */}
        <button
          onClick={() => onDateSelect(tomorrow)}
          className="bg-white border-2 border-gray-200 rounded-xl hover:border-green-500 hover:shadow-lg transition-all duration-300 text-left w-full min-w-full"
        >
          <div className="flex items-start p-4 sm:p-6">
            <div className="bg-green-50 p-2 rounded-full shrink-0">
              <SunIcon className="h-6 w-6 text-green-600" />
            </div>
            <div className="ml-3 leading-normal">
              <div className="text-lg sm:text-xl font-bold text-green-800">Tomorrow</div>
              <div className="text-gray-600">{formatDateLong(tomorrow)}</div>
            </div>
          </div>
        </button>

        {/* Custom Date Card */}
        <button
          onClick={() => setShowCalendar(true)}
          className="bg-white border-2 border-gray-200 rounded-xl hover:border-green-500 hover:shadow-lg transition-all duration-300 text-left w-full min-w-full"
        >
          <div className="flex items-start p-4 sm:p-6">
            <div className="bg-green-50 p-2 rounded-full shrink-0">
              <CalendarIcon className="h-6 w-6 text-green-600" />
            </div>
            <div className="ml-3 leading-normal">
              <div className="text-lg sm:text-xl font-bold text-green-800">Select Date</div>
              <div className="text-gray-600">Choose another date</div>
            </div>
          </div>
        </button>
      </div>

      {/* Facility Information (hidden on mobile) */}
      <div className="hidden lg:block bg-gray-50 border-2 border-gray-300 rounded-xl p-6">
        <div className="grid grid-cols-5 gap-6">
          <div className="col-span-3 space-y-5">
            <h3 className="text-xl font-bold text-green-800 mb-6">Facility Information</h3>
            
            {/* Opening Hours Section */}
            <div className="space-y-2">
              <div className="flex items-start">
                <div className="bg-green-50 p-1.5 rounded-full shrink-0">
                  <ClockIcon className="h-4 w-4 text-green-600" />
                </div>
                <div className="ml-3 text-gray-600 leading-normal">
                  <p><span className="font-medium">Opening Hours:</span> 10:00 AM - 11:00 PM daily</p>
                  <p className="text-sm text-gray-500">Peak Hours: 6:00 PM - 9:00 PM</p>
                  <p className="text-sm text-gray-500">Last booking: 10:00 PM (1-hour session)</p>
                </div>
              </div>
            </div>

            {/* Bay Capacity Section */}
            <div className="space-y-2">
              <div className="flex items-start">
                <div className="bg-green-50 p-1.5 rounded-full shrink-0">
                  <UserGroupIcon className="h-4 w-4 text-green-600" />
                </div>
                <div className="ml-3 text-gray-600 leading-normal">
                  <p><span className="font-medium">Bay Capacity:</span> Up to 5 players per bay</p>
                  <p className="text-sm text-gray-500">Perfect for groups, friends, and family</p>
                  <p className="text-sm text-gray-500">Professional coaching available upon request</p>
                </div>
              </div>
            </div>

            {/* Equipment Section */}
            <div className="space-y-2">
              <div className="flex items-start">
                <div className="bg-green-50 p-1.5 rounded-full shrink-0">
                  <ShoppingBagIcon className="h-4 w-4 text-green-600" />
                </div>
                <div className="ml-3 text-gray-600 leading-normal">
                  <p><span className="font-medium">Facilities & Equipment:</span></p>
                  <ul className="mt-1 space-y-1">
                    <li>â€¢ Professional golf clubs available complimentary</li>
                    <li>â€¢ Dedicated club storage for regular players</li>
                    <li>â€¢ Professional golf gloves available in our shop</li>
                    <li>â€¢ Food & beverages service available</li>
                    <li>â€¢ Spacious putting green free for all visitors</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          {/* Images Section */}
          <div className="col-span-2 grid grid-rows-2 gap-4">
            <div className="relative w-full h-44 rounded-lg overflow-hidden">
              <Image
                src="/images/pic2.png"
                alt="LENGOLF Bay"
                fill
                className="object-cover"
                sizes="(max-width: 768px) 100vw, 400px"
                priority
              />
            </div>
            <div className="relative w-full h-44 rounded-lg overflow-hidden">
              <Image
                src="/images/pic1.png"
                alt="LENGOLF Facility"
                fill
                className="object-cover"
                sizes="(max-width: 768px) 100vw, 400px"
                priority
              />
            </div>
          </div>
        </div>
      </div>

      {/* Calendar Modal */}
      {showCalendar && (
        <div
          className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4"
          onClick={() => setShowCalendar(false)}
        >
          <div
            className="bg-white rounded-2xl p-6 shadow-xl max-w-md w-full"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex justify-between items-center mb-6">
              <div>
                <h3 className="text-xl font-bold text-gray-900">Select Date</h3>
                <p className="text-sm text-gray-500 mt-1">Choose your preferred date</p>
              </div>
              <button
                onClick={() => setShowCalendar(false)}
                className="text-gray-400 hover:text-gray-600 transition-colors"
              >
                <svg
                  className="w-6 h-6"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            <style jsx global>{`
              .rdp {
                --rdp-cell-size: 40px;
                --rdp-accent-color: rgb(22 163 74) !important;
                --rdp-background-color: rgb(220 252 231) !important;
                --rdp-accent-color-dark: rgb(21 128 61) !important;
                --rdp-background-color-dark: rgb(220 252 231) !important;
                --rdp-outline: 2px solid var(--rdp-accent-color) !important;
                --rdp-outline-selected: 2px solid rgb(22 163 74) !important;
                margin: 0;
              }

              .rdp-button:focus-visible:not([disabled]) {
                outline: none;
              }

              .rdp-day_today {
                background: none !important;
                color: rgb(22 163 74) !important;
                font-weight: bold !important;
                border: 2px solid rgb(22 163 74) !important;
              }

              .rdp-day_selected:not([disabled]),
              .rdp-day_selected:focus:not([disabled]),
              .rdp-day_selected:active:not([disabled]),
              .rdp-day_selected:hover:not([disabled]) {
                color: white !important;
                background-color: rgb(22 163 74) !important;
                border-color: rgb(22 163 74) !important;
              }

              .rdp-day:hover:not([disabled]):not(.rdp-day_selected) {
                color: rgb(22 163 74) !important;
                background-color: rgb(220 252 231) !important;
              }

              .rdp-nav_button {
                color: rgb(22 163 74) !important;
              }
              .rdp-nav_button:hover,
              .rdp-nav_button:focus-visible {
                color: rgb(22 163 74) !important;
                background-color: rgb(220 252 231) !important;
              }

              .rdp-nav button svg {
                fill: rgb(22 163 74) !important;
              }

              .rdp-button_reset {
                color: inherit !important;
              }

              .rdp-day {
                color: inherit !important;
              }

              .rdp-day_today.rdp-day_selected {
                color: white !important;
              }

              .rdp-day_disabled,
              .rdp-day_disabled:hover {
                color: rgb(156 163 175) !important;
                cursor: not-allowed !important;
                background-color: rgb(243 244 246) !important;
                opacity: 0.5;
              }

              .rdp-day_disabled.rdp-day_today {
                border-color: rgb(156 163 175) !important;
              }
            `}</style>

            <DayPicker
              mode="single"
              onSelect={(date) => {
                if (date) {
                  onDateSelect(date);
                  setShowCalendar(false);
                }
              }}
              fromDate={today}
              disabled={[{ before: today }]}
              modifiers={{ today: new Date() }}
              className="mx-auto"
            />
          </div>
        </div>
      )}
    </div>
  );
}




==== app\(features)\bookings\components\booking\steps\TimeSlots.tsx (120 lines) ====

'use client';

import { useEffect } from 'react';
import { format } from 'date-fns';
import { motion } from 'framer-motion';
import { ClockIcon, SunIcon, CloudIcon, MoonIcon } from '@heroicons/react/24/outline';
import { useRouter } from 'next/navigation';
import { useAvailability } from '../../../hooks/useAvailability';

interface TimeSlotsProps {
  selectedDate: Date;
  onBack: () => void;
  onTimeSelect: (time: string, maxHours: number) => void;
}

export function TimeSlots({ selectedDate, onBack, onTimeSelect }: TimeSlotsProps) {
  const { isLoadingSlots, availableSlots, fetchAvailability } = useAvailability();
  const router = useRouter();

  useEffect(() => {
    fetchAvailability(selectedDate);
  }, [selectedDate]);

  return (
    <div className="min-h-[calc(100vh-32rem)]">
      {isLoadingSlots ? (
        <div className="flex flex-col items-center justify-center h-full py-20">
          <div className="w-16 h-16 border-4 border-green-600 border-t-transparent rounded-full animate-spin"></div>
          <p className="mt-4 text-lg text-gray-600">Loading available times...</p>
        </div>
      ) : (
        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="grid grid-cols-1 lg:grid-cols-3 gap-6"
        >
          {['morning', 'afternoon', 'evening'].map((period) => {
            const periodSlots = availableSlots.filter(slot => slot.period === period);
            if (periodSlots.length === 0) return null;

            return (
              <div key={period} className="bg-white rounded-xl shadow-sm overflow-hidden">
                {/* Period Header */}
                <div className="bg-green-700 px-4 py-3 flex items-center justify-between">
                  <div className="flex items-center">
                    {period === 'morning' ? (
                      <SunIcon className="h-5 w-5 text-yellow-300 mr-2" />
                    ) : period === 'afternoon' ? (
                      <CloudIcon className="h-5 w-5 text-white mr-2" />
                    ) : (
                      <MoonIcon className="h-5 w-5 text-blue-200 mr-2" />
                    )}
                    <div>
                      <h3 className="text-lg font-semibold text-white">
                        {period.charAt(0).toUpperCase() + period.slice(1)}
                        <span className="ml-2 text-sm font-normal opacity-90">
                          {period === 'morning' ? '(10:00 - 13:00)' : 
                           period === 'afternoon' ? '(13:00 - 17:00)' : 
                           '(17:00 - 23:00)'}
                        </span>
                      </h3>
                    </div>
                  </div>
                </div>

                {/* Time Slots */}
                <div className="divide-y">
                  {periodSlots
                    .sort((a, b) => a.startTime.localeCompare(b.startTime))
                    .map((slot, index) => (
                      <motion.div
                        key={index}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ duration: 0.2, delay: index * 0.05 }}
                        className="group px-4 py-3 hover:bg-gray-50 transition-colors cursor-pointer"
                        onClick={() => onTimeSelect(slot.startTime, slot.maxHours)}
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center">
                            <div className="flex items-center text-green-800 w-20">
                              <ClockIcon className="h-5 w-5 mr-2" />
                              <span className="text-lg font-semibold">{slot.startTime}</span>
                            </div>
                            <div className="text-gray-600 text-sm ml-6">
                              Up to {slot.maxHours} hour{slot.maxHours > 1 ? 's' : ''}
                            </div>
                          </div>
                          <div className="flex items-center text-green-700 font-medium group-hover:text-green-800">
                            Select
                            <svg className="w-5 h-5 ml-1 transform group-hover:translate-x-1 transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                            </svg>
                          </div>
                        </div>
                      </motion.div>
                    ))}
                </div>
              </div>
            );
          })}
          {availableSlots.length === 0 && !isLoadingSlots && (
            <motion.div 
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="lg:col-span-3 flex items-center justify-center"
            >
              <div className="bg-white rounded-xl shadow-sm p-8 text-center">
                <p className="text-gray-600 text-lg">
                  No available time slots for this date.
                </p>
              </div>
            </motion.div>
          )}
        </motion.div>
      )}
    </div>
  );
} 



==== app\(features)\bookings\confirmation\page.tsx (48 lines) ====

import { Metadata } from 'next';
import { redirect } from 'next/navigation';
import { createServerClient } from '@/utils/supabase/server';
import { format } from 'date-fns';
import { CheckCircleIcon, CalendarIcon, ClockIcon, UserGroupIcon } from '@heroicons/react/24/outline';
import { Layout } from '../components/booking/Layout';
import { Booking } from '@/types';
import { ConfirmationContent } from '../components/booking/ConfirmationContent';
import { getServerSession } from 'next-auth';

export const metadata: Metadata = {
  title: 'Booking Confirmation - LENGOLF',
  description: 'Confirm your booking at LENGOLF',
};

export default async function ConfirmationPage({
  searchParams,
}: {
  searchParams: Promise<{ id?: string }>;
}) {
  const { id } = await searchParams;
  
  if (!id) {
    redirect('/bookings');
  }

  const session = await getServerSession();
  if (!session) {
    redirect('/auth/login');
  }

  const supabase = createServerClient();
  const { data: booking, error: bookingError } = await supabase
    .from('bookings')
    .select('*')
    .eq('id', id)
    .single();

  if (bookingError || !booking) {
    redirect('/bookings');
  }

  return (
    <Layout>
      <ConfirmationContent booking={booking} />
    </Layout>
  );
} 



==== app\(features)\bookings\hooks\useAvailability.ts (67 lines) ====

import { useState } from 'react';
import { format } from 'date-fns';
import { useRouter } from 'next/navigation';
import { useSession } from 'next-auth/react';
import { getCurrentBangkokTime } from '@/utils/date';

interface TimeSlot {
  startTime: string;
  endTime: string;
  maxHours: number;
  period: 'morning' | 'afternoon' | 'evening';
}

export function useAvailability() {
  const [isLoadingSlots, setIsLoadingSlots] = useState(false);
  const [availableSlots, setAvailableSlots] = useState<TimeSlot[]>([]);
  const router = useRouter();
  const { data: session } = useSession();

  const fetchAvailability = async (selectedDate: Date) => {
    setIsLoadingSlots(true);

    try {
      if (!session) {
        router.push('/auth/login');
        return;
      }

      // Get current time in Bangkok timezone
      const currentTimeInBangkok = getCurrentBangkokTime();
      
      const response = await fetch('/api/availability', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          date: format(selectedDate, 'yyyy-MM-dd'),
          currentTimeInBangkok: currentTimeInBangkok.toISOString()
        }),
      });

      if (response.status === 401) {
        router.push('/auth/login');
        return;
      }

      if (!response.ok) {
        throw new Error('Failed to fetch availability');
      }

      const data = await response.json();
      setAvailableSlots(data.slots);
    } catch (error) {
      setAvailableSlots([]);
      console.error('Error fetching availability:', error);
    } finally {
      setIsLoadingSlots(false);
    }
  };

  return {
    isLoadingSlots,
    availableSlots,
    fetchAvailability,
  };
} 



==== app\(features)\bookings\hooks\useBookingFlow.ts (82 lines) ====

import { useState, useEffect } from 'react';
import { useSession, signIn } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';

export function useBookingFlow() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const searchParams = useSearchParams();

  const [currentStep, setCurrentStep] = useState(1);
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedTime, setSelectedTime] = useState<string | null>(null);
  const [maxDuration, setMaxDuration] = useState<number>(1);
  const [isAutoSelecting, setIsAutoSelecting] = useState(false);

  useEffect(() => {
    if (status === 'authenticated' && searchParams && !isAutoSelecting) {
      const dateParam = searchParams.get('selectDate');
      
      if (dateParam) {
        setIsAutoSelecting(true);
        try {
          const selectedDateFromParam = new Date(dateParam);
          
          if (isNaN(selectedDateFromParam.getTime())) {
            throw new Error('Invalid date parameter');
          }

          setSelectedDate(selectedDateFromParam);
          setCurrentStep(2); 

          router.replace('/bookings', { scroll: false }); 

        } catch (error) {
          console.error("Error processing selectDate param:", error);
          router.replace('/bookings', { scroll: false }); 
        } finally {
            setIsAutoSelecting(false);
        }
      }
    }
  }, [status, isAutoSelecting]);

  const handleDateSelect = (date: Date) => {
    if (status === 'unauthenticated') {
      const callbackUrl = `/bookings?selectDate=${date.toISOString()}`;
      signIn(undefined, { callbackUrl });
      return;
    }

    setSelectedDate(date);
    setCurrentStep(2);
  };

  const handleTimeSelect = (time: string, maxHours: number) => {
    setSelectedTime(time);
    setMaxDuration(maxHours);
    setCurrentStep(3);
  };

  const handleBack = () => {
    if (currentStep > 1) {
      if (currentStep === 2) {
        setSelectedDate(null);
      } else if (currentStep === 3) {
        setSelectedTime(null);
      }
      setCurrentStep(currentStep - 1);
    }
  };

  return {
    currentStep,
    selectedDate,
    selectedTime,
    maxDuration,
    isAutoSelecting,
    handleDateSelect,
    handleTimeSelect,
    handleBack,
  };
} 



==== app\(features)\bookings\page.tsx (106 lines) ====

'use client';

import { useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { format } from 'date-fns';
import { ArrowLeftIcon } from '@heroicons/react/24/outline';
import { Layout } from './components/booking/Layout';
import { DateSelection } from './components/booking/steps/DateSelection';
import { TimeSlots } from './components/booking/steps/TimeSlots';
import { BookingDetails } from './components/booking/steps/BookingDetails';
import { useBookingFlow } from './hooks/useBookingFlow';

export default function BookingsPage() {
  const router = useRouter();
  const { data: session, status } = useSession({
    required: false,
    onUnauthenticated() {
    },
  });

  const {
    currentStep,
    selectedDate,
    selectedTime,
    maxDuration,
    handleDateSelect,
    handleTimeSelect,
    handleBack,
  } = useBookingFlow();

  if (status === 'loading') {
    return (
      <Layout>
        <div className="flex items-center justify-center min-h-[60vh]">
          <div className="w-8 h-8 border-4 border-green-600 border-t-transparent rounded-full animate-spin" />
        </div>
      </Layout>
    );
  }
  
  const renderContent = () => (
    <div className="min-h-[36rem]">
      <div className="mb-6 flex items-start">
        {currentStep > 1 && (
          <button
            onClick={handleBack}
            className="mr-4 p-2 rounded-lg hover:bg-gray-100"
            aria-label="Go back"
          >
            <ArrowLeftIcon className="h-6 w-6 text-gray-600" />
          </button>
        )}
        <div>
          <h2 className="text-2xl font-bold text-gray-900">
            {currentStep === 1 
              ? 'Select Date'
              : currentStep === 2
              ? 'Select Time'
              : 'Provide Details'
            }
          </h2>
          <p className="text-gray-600 mt-1">
            {currentStep === 1 
              ? 'Choose when you\'d like to play.'
              : currentStep === 2
              ? format(selectedDate!, 'EEE, d MMM yyyy')
              : 'Complete your booking details.'
            }
          </p>
        </div>
      </div>

      <div className="relative">
        {currentStep === 1 && (
          <DateSelection onDateSelect={handleDateSelect} />
        )}

        {currentStep === 2 && selectedDate && (
          <TimeSlots
            selectedDate={selectedDate}
            onTimeSelect={handleTimeSelect}
            onBack={handleBack}
          />
        )}

        {currentStep === 3 && selectedDate && selectedTime && (
          <BookingDetails
            selectedDate={selectedDate}
            selectedTime={selectedTime}
            maxDuration={maxDuration}
            onBack={handleBack}
          />
        )}
      </div>
    </div>
  );

  return (
    <Layout>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {renderContent()}
      </div>
    </Layout>
  );
} 



==== app\(features)\bookings\types\index.ts (21 lines) ====

export interface TimeSlot {
  startTime: string;
  endTime: string;
  maxHours: number;
  period: 'morning' | 'afternoon' | 'evening';
}

export interface BookingFormData {
  date: Date;
  startTime: string;
  duration: number;
  numberOfPeople: number;
  phoneNumber: string;
  email: string;
}

export interface BookingConfirmation {
  id: string;
  bay: string;
  eventId: string;
} 



==== app\api\auth\options.ts (249 lines) ====

import GoogleProvider from 'next-auth/providers/google';
import FacebookProvider from 'next-auth/providers/facebook';
import LineProvider from 'next-auth/providers/line';
import CredentialsProvider from 'next-auth/providers/credentials';
import { createServerClient } from '@/utils/supabase/server';
import { getOrCreateCrmMapping } from '@/utils/customer-matching';
import { v4 as uuidv4 } from 'uuid';
import type { NextAuthOptions } from 'next-auth';
import type { JWT } from 'next-auth/jwt';
import type { Session } from 'next-auth';
import type { User } from 'next-auth';
import type { Account } from 'next-auth';
import type { Profile as OAuthProfile } from 'next-auth';

if (!process.env.NEXTAUTH_SECRET) {
  throw new Error('Please provide process.env.NEXTAUTH_SECRET');
}

// Extend the User type to include our custom fields
interface ExtendedUser extends User {
  id: string;
  provider?: string;
  phone?: string | null;
}

export const authOptions: NextAuthOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID!,
      clientSecret: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_SECRET!,
      authorization: {
        params: {
          prompt: "select_account",
          access_type: "offline",
          response_type: "code",
          hl: "en"
        }
      }
    }),
    FacebookProvider({
      clientId: process.env.NEXT_PUBLIC_FACEBOOK_APP_ID!,
      clientSecret: process.env.NEXT_PUBLIC_FACEBOOK_CLIENT_SECRET!
    }),
    LineProvider({
      clientId: process.env.NEXT_PUBLIC_LINE_CLIENT_ID!,
      clientSecret: process.env.LINE_CLIENT_SECRET!,
      authorization: {
        url: 'https://access.line.me/oauth2/v2.1/authorize',
        params: {
          scope: 'profile openid email',
          bot_prompt: 'normal',
          redirect_uri: process.env.NEXT_PUBLIC_LINE_REDIRECT_URI
        }
      },
      userinfo: {
        url: 'https://api.line.me/oauth2/v2.1/userinfo',
        params: { scope: 'profile openid email' }
      },
      profile(profile) {
        return {
          id: profile.sub,
          name: profile.name,
          email: null,
          image: profile.picture
        }
      }
    }),
    CredentialsProvider({
      id: 'guest',
      name: 'Guest',
      credentials: {
        name: { label: 'Name', type: 'text' },
        email: { label: 'Email', type: 'email' },
        phone: { label: 'Phone', type: 'tel' }
      },
      async authorize(credentials) {
        if (!credentials?.name || !credentials?.email || !credentials?.phone) {
          return null;
        }

        const supabase = createServerClient();
        
        const { data: existingProfile } = await supabase
          .from('profiles')
          .select('*')
          .eq('email', credentials.email)
          .eq('provider', 'guest')
          .single();

        if (existingProfile) {
          const { data: profile } = await supabase
            .from('profiles')
            .update({
              display_name: credentials.name,
              phone_number: credentials.phone,
              updated_at: new Date().toISOString()
            })
            .eq('id', existingProfile.id)
            .select()
            .single();

          if (!profile) return null;

          return {
            id: existingProfile.id,
            name: credentials.name,
            email: credentials.email,
            phone: credentials.phone,
            provider: 'guest'
          };
        }

        const guestId = uuidv4();
        const { data: profile } = await supabase
          .from('profiles')
          .insert({
            id: guestId,
            email: credentials.email,
            display_name: credentials.name,
            phone_number: credentials.phone,
            provider: 'guest',
            updated_at: new Date().toISOString()
          })
          .select()
          .single();

        if (!profile) return null;

        return {
          id: guestId,
          name: credentials.name,
          email: credentials.email,
          phone: credentials.phone,
          provider: 'guest'
        };
      }
    })
  ],
  callbacks: {
    async signIn({ user, account, profile: oauthProfile }: { 
      user: ExtendedUser; 
      account: Account | null; 
      profile?: OAuthProfile;
    }) {
      const supabase = createServerClient();

      try {
        if (account?.provider === 'guest') {
          return true;
        }

        const { data: existingProfile } = await supabase
          .from('profiles')
          .select('id')
          .eq('provider_id', account?.providerAccountId)
          .single();

        const userId = existingProfile?.id || uuidv4();

        const { error } = await supabase
          .from('profiles')
          .upsert({
            id: userId,
            email: user.email,
            display_name: existingProfile ? undefined : user.name,
            picture_url: user.image,
            provider: account?.provider,
            provider_id: account?.providerAccountId,
            updated_at: new Date().toISOString()
          }, { 
            onConflict: 'id',
            ignoreDuplicates: false
          });

        if (error) {
          console.error('Failed to upsert profile:', error);
          return false;
        }

        user.id = userId;
        
        // Attempt to match the user with a CRM customer in the background
        // This allows the login to proceed regardless of mapping success
        getOrCreateCrmMapping(userId, { source: 'auth' }).catch(error => {
          console.error('Unexpected error in background CRM mapping:', error);
        });

        return true;
      } catch (error) {
        console.error('Sign-in process error:', error);
        return false;
      }
    },
    async session({ session, token }: { session: Session; token: JWT }) {
      // --- TEMPORARILY SIMPLIFIED FOR DEBUGGING ---
      // // Original code:
      // const supabase = createServerClient();
      // const { data: profile } = await supabase
      //   .from('profiles')
      //   .select('phone_number')
      //   .eq('id', token.sub)
      //   .single();
      //
      // return {
      //   ...session,
      //   user: {
      //     ...session.user,
      //     id: token.sub,
      //     provider: token.provider as string,
      //     phone: profile?.phone_number || null
      //   },
      //   accessToken: token.accessToken
      // };

      // Simplified return:
      // If token exists, add basic info; otherwise, let NextAuth handle default.
      if (token && token.sub) {
        session.user.id = token.sub;
        // session.user.provider = token.provider as string; // Optional: Keep if needed
        // session.accessToken = token.accessToken; // Optional: Keep if needed
      }
      return session; // Return the potentially minimally modified session
      // --- END TEMPORARY SIMPLIFICATION ---
    },
    async jwt({ token, user, account }: { token: JWT; user?: ExtendedUser; account?: Account | null }) {
      // --- TEMPORARILY SIMPLIFIED FOR DEBUGGING ---
      // // Original code:
      // if (user) {
      //   token.sub = user.id;
      //   token.provider = user.provider;
      // }
      // if (account) {
      //   token.accessToken = account.access_token;
      // }
      return token; // Just return the token as is
      // --- END TEMPORARY SIMPLIFICATION ---
    }
  },
  pages: {
    signIn: '/auth/login',
    error: '/auth/error',
  },
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
    updateAge: 0, // Disable activity-based session extension
  },
  debug: false,
}; 



==== app\api\auth\[...nextauth]\route.ts (9 lines) ====

import NextAuth from 'next-auth';
import { authOptions } from '../options';

// console.log("Loading NextAuth handler...");
// console.log("NEXTAUTH_SECRET available?", !!process.env.NEXTAUTH_SECRET);

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };



==== app\api\availability\check\route.ts (72 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { calendar } from '@/lib/googleApiConfig';
import { BOOKING_CALENDARS } from '@/lib/bookingCalendarConfig';
import { parse, addHours, isAfter } from 'date-fns';
import { zonedTimeToUtc, formatInTimeZone } from 'date-fns-tz';

const TIMEZONE = 'Asia/Bangkok';

export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const { date, startTime, duration } = await request.json();
    
    if (!date || !startTime || !duration) {
      return NextResponse.json({ 
        error: 'Missing required parameters', 
        available: false 
      }, { status: 400 });
    }

    // Format date and time
    const parsedDateTime = parse(`${date} ${startTime}`, 'yyyy-MM-dd HH:mm', new Date());
    const startDateTime = zonedTimeToUtc(parsedDateTime, TIMEZONE);
    const endDateTime = addHours(startDateTime, duration);

    // Check availability for all bays
    const bayAvailability = await Promise.all(
      Object.entries(BOOKING_CALENDARS).map(async ([bay, calendarId]) => {
        try {
          const events = await calendar.events.list({
            calendarId,
            timeMin: formatInTimeZone(startDateTime, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx"),
            timeMax: formatInTimeZone(endDateTime, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx"),
            singleEvents: true,
            orderBy: 'startTime',
          });

          return {
            bay,
            available: !events.data.items || events.data.items.length === 0
          };
        } catch (error) {
          console.error(`Error checking availability for bay ${bay}:`, error);
          return { bay, available: false };
        }
      })
    );

    // Find available bays
    const availableBays = bayAvailability.filter(bay => bay.available);
    
    if (availableBays.length === 0) {
      return NextResponse.json({ 
        available: false, 
        message: 'No bays available for the selected time slot' 
      });
    }

    // Return the first available bay
    return NextResponse.json({
      available: true,
      bay: availableBays[0].bay,
      allAvailableBays: availableBays.map(b => b.bay)
    });
  } catch (error) {
    console.error('Error checking bay availability:', error);
    return NextResponse.json(
      { error: 'An error occurred while checking bay availability', available: false },
      { status: 500 }
    );
  }
} 



==== app\api\availability\route.ts (211 lines) ====

import { NextResponse } from 'next/server';
import { format, parse, addHours, startOfDay, endOfDay } from 'date-fns';
import { zonedTimeToUtc, formatInTimeZone } from 'date-fns-tz';
import { calendar, AVAILABILITY_CALENDARS } from '@/lib/googleApiConfig';
import { getToken } from 'next-auth/jwt';
import type { NextRequest } from 'next/server';
import { calendarCache, authCache, getCacheKey, updateCalendarCache } from '@/lib/cache';
import { differenceInHours } from 'date-fns';

const OPENING_HOUR = 10; // 10:00 AM
const CLOSING_HOUR = 23; // 11:00 PM
const MAX_HOURS = 5;
const TIMEZONE = 'Asia/Bangkok';

// Helper: determine period based on starting hour
function getTimePeriod(hour: number): 'morning' | 'afternoon' | 'evening' {
  if (hour < 13) return 'morning';
  if (hour < 17) return 'afternoon';
  return 'evening';
}

// Helper: format a date in Bangkok time
function formatBangkokTime(date: Date | string, fmt: string): string {
  return formatInTimeZone(new Date(date), TIMEZONE, fmt);
}

export async function POST(request: NextRequest) {
  try {
    // 1. Authenticate via NextAuth
    const token = await getToken({ req: request as any });
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const authCacheKey = getCacheKey.auth(token.sub!);
    if (!authCache.get(authCacheKey)) {
      authCache.set(authCacheKey, true);
    }

    // 2. Parse incoming JSON
    const body = await request.json();
    const { date, currentTimeInBangkok } = body;
    if (!date || !currentTimeInBangkok) {
      return NextResponse.json({ error: 'Invalid request parameters' }, { status: 400 });
    }
    
    const parsedDate = parse(date + ' 00:00', 'yyyy-MM-dd HH:mm', new Date());
    const bangkokStartOfDay = zonedTimeToUtc(parsedDate, TIMEZONE);
    const bangkokEndOfDay = zonedTimeToUtc(endOfDay(parsedDate), TIMEZONE);
    const currentDate = new Date(currentTimeInBangkok);
    const currentHourInZone = parseInt(formatBangkokTime(currentDate, 'HH'), 10);
    const isToday = formatBangkokTime(bangkokStartOfDay, 'yyyy-MM-dd') === formatBangkokTime(currentDate, 'yyyy-MM-dd');
    const startHour = isToday ? Math.max(OPENING_HOUR, currentHourInZone + 1) : OPENING_HOUR;

    // 3. Fetch events for the booking day
    let allEvents: any[] = [];
    const calendarCacheKey = getCacheKey.calendar(formatBangkokTime(bangkokStartOfDay, 'yyyy-MM-dd'));
    
    const cachedEvents = calendarCache.get<any[]>(calendarCacheKey);
    
    if (cachedEvents) {
      allEvents = cachedEvents;
    } else {
      const timeMin = formatInTimeZone(bangkokStartOfDay, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx");
      const timeMax = formatInTimeZone(bangkokEndOfDay, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx");

      try {
        const bayEvents = await Promise.all(
          Object.entries(AVAILABILITY_CALENDARS).map(async ([name, calendarId]) => {
            try {
              const response = await calendar.events.list({
                calendarId,
                timeMin,
                timeMax,
                singleEvents: true,
                orderBy: 'startTime',
                timeZone: TIMEZONE,
              });
              return response;
            } catch (error: any) {
              console.error(`Error fetching events for ${name}:`, {
                calendarId: calendarId.substring(0, 10) + '...',
                error: error.message,
                status: error.status
              });
              throw error;
            }
          })
        );
        
        allEvents = bayEvents.flatMap(response => response.data.items || []);
        
        try {
          calendarCache.set(calendarCacheKey, allEvents);
        } catch (cacheError) {
          console.error('Failed to update calendar cache:', cacheError);
        }
      } catch (error: any) {
        console.error('Calendar API error:', {
          message: error.message,
          status: error.status
        });
        throw error;
      }
    }

    // 4. Build available time slots
    const slots = [];

    for (let hour = startHour; hour < CLOSING_HOUR; hour++) {
      const dateStr = formatBangkokTime(bangkokStartOfDay, 'yyyy-MM-dd');
      const slotParsed = parse(`${dateStr} ${hour}:00`, 'yyyy-MM-dd HH:mm', new Date());
      const slotStart = zonedTimeToUtc(slotParsed, TIMEZONE);
      const timeStr = formatBangkokTime(slotStart, 'HH:mm');

      if (slotStart.getTime() <= currentDate.getTime()) {
        continue;
      }

      const hoursUntilClose = CLOSING_HOUR - hour;
      const maxAvailableHours = Math.min(MAX_HOURS, hoursUntilClose);

      const availableBays = Object.keys(AVAILABILITY_CALENDARS).filter(bay => {
        const bayEvents = allEvents.filter(event => 
          event.organizer?.email === AVAILABILITY_CALENDARS[bay as keyof typeof AVAILABILITY_CALENDARS]
        );

        return !bayEvents.some(event => {
          const eventStart = new Date(event.start?.dateTime || '');
          const eventEnd = new Date(event.end?.dateTime || '');
          const slotEnd = addHours(slotStart, 1);

          const slotStartsDuringEvent = slotStart >= eventStart && slotStart < eventEnd;
          const slotEndsDuringEvent = slotEnd > eventStart && slotEnd <= eventEnd;
          const eventContainsSlot = eventStart <= slotStart && eventEnd >= slotEnd;
          const gapBeforeEvent = eventStart.getTime() - slotStart.getTime();
          const hasSmallGap = gapBeforeEvent > 0 && gapBeforeEvent < 15 * 60 * 1000;
          const slotOverlapsEvent = slotStart < eventEnd && slotEnd > eventStart;
          const eventStartsAtSlot = eventStart.getTime() === slotStart.getTime();
          const eventEndsAtSlotStart = eventEnd.getTime() === slotStart.getTime();

          return !eventEndsAtSlotStart && (
            slotStartsDuringEvent || 
            slotEndsDuringEvent || 
            eventContainsSlot || 
            hasSmallGap || 
            slotOverlapsEvent || 
            eventStartsAtSlot
          );
        });
      });

      if (availableBays.length > 0) {
        const bayHours = availableBays.map(bay => {
          const bayEvents = allEvents.filter(event => 
            event.organizer?.email === AVAILABILITY_CALENDARS[bay as keyof typeof AVAILABILITY_CALENDARS]
          );

          const nextEvent = bayEvents.find(event => {
            const eventStart = new Date(event.start?.dateTime || '');
            return eventStart > slotStart;
          });

          const overlappingEvents = bayEvents.filter(event => {
            const eventStart = new Date(event.start?.dateTime || '');
            const eventEnd = new Date(event.end?.dateTime || '');
            const slotEnd = addHours(slotStart, 1);
            return slotStart < eventEnd && slotEnd > eventStart;
          });

          if (overlappingEvents.length > 0) {
            return 0;
          }

          if (nextEvent) {
            const eventStart = new Date(nextEvent.start?.dateTime || '');
            const hoursUntilEvent = differenceInHours(eventStart, slotStart);
            return Math.min(maxAvailableHours, Math.max(1, hoursUntilEvent));
          }

          const hasEvents = bayEvents.length > 0;
          if (!hasEvents) {
            return maxAvailableHours;
          }

          const lastEvent = bayEvents[bayEvents.length - 1];
          const lastEventEnd = new Date(lastEvent.end?.dateTime || '');
          if (slotStart >= lastEventEnd) {
            return maxAvailableHours;
          }

          return 0;
        });

        const actualMaxHours = Math.max(...bayHours);
        if (actualMaxHours > 0) {
          slots.push({
            startTime: timeStr,
            endTime: formatBangkokTime(addHours(slotStart, actualMaxHours), 'HH:mm'),
            maxHours: actualMaxHours,
            period: getTimePeriod(hour),
          });
        }
      }
    }

    return NextResponse.json({ slots });
  } catch (error) {
    console.error('Error in availability endpoint:', error instanceof Error ? error.message : error);
    return NextResponse.json({ error: 'Failed to fetch availability' }, { status: 500 });
  }
} 



==== app\api\bookings\calendar\create\route.ts (225 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { calendar } from '@/lib/googleApiConfig';
import { BOOKING_CALENDARS } from '@/lib/bookingCalendarConfig';
import { format, parseISO } from 'date-fns';
import { formatInTimeZone } from 'date-fns-tz';
import { BAY_COLORS } from '@/lib/bayConfig';
import { createServerClient } from '@/utils/supabase/server';

const TIMEZONE = 'Asia/Bangkok';
const ENABLE_DETAILED_LOGGING = process.env.ENABLE_BOOKING_DETAILED_LOGGING === 'true';

interface CalendarResponse {
  data: {
    id: string;
    [key: string]: any;
  };
}

// Helper function to log calendar creation steps to Supabase
async function logCalendarCreationStep({
  bookingId,
  step,
  status,
  durationMs,
  metadata = {}
}: {
  bookingId: string;
  step: string;
  status: 'success' | 'error' | 'info';
  durationMs: number;
  metadata?: Record<string, any>;
}) {
  if (!ENABLE_DETAILED_LOGGING) return;
  
  try {
    const supabase = createServerClient();
    await supabase
      .from('booking_process_logs')
      .insert({
        booking_id: bookingId,
        user_id: '00000000-0000-0000-0000-000000000000', // System user as a fallback
        step,
        status,
        duration_ms: durationMs,
        total_duration_ms: durationMs, // For this endpoint, we just use the same value
        metadata
      });
  } catch (error) {
    // Don't let logging errors affect the calendar creation process
    console.error('Error logging calendar creation step:', error);
  }
}

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  let bookingId = 'unknown';
  
  try {
    // Parse request body
    const requestData = await request.json();
    
    // Require full data for calendar creation
    if (!requestData.booking || !requestData.startDateTime || !requestData.endDateTime) {
      return NextResponse.json({ error: 'Missing required data for calendar event' }, { status: 400 });
    }
    
    // Extract data
    const { booking, customerName, bayDisplayName, startDateTime, endDateTime, packageInfo = 'Normal Bay Rate' } = requestData;
    
    // Set bookingId for logging
    bookingId = booking.id || requestData.bookingId || 'unknown';
    
    // Log the start of calendar creation
    if (ENABLE_DETAILED_LOGGING) {
      await logCalendarCreationStep({
        bookingId,
        step: 'Calendar API request started',
        status: 'info',
        durationMs: Date.now() - startTime,
        metadata: {
          bay: booking.bay,
          bayDisplayName,
          startDateTime,
          endDateTime
        }
      });
    }
    
    // Get calendar ID for the bay
    const bay = booking.bay || 'Bay 1';
    const calendarId = BOOKING_CALENDARS[bay as keyof typeof BOOKING_CALENDARS];
    
    if (!calendarId) {
      if (ENABLE_DETAILED_LOGGING) {
        await logCalendarCreationStep({
          bookingId,
          step: 'Calendar ID lookup',
          status: 'error',
          durationMs: Date.now() - startTime,
          metadata: { bay, error: 'Invalid bay ID' }
        });
      }
      return NextResponse.json({ error: 'Invalid bay ID' }, { status: 400 });
    }

    try {
      // Log input data for debugging
      console.log('Calendar event creation input:', {
        customerName,
        bookingName: booking.name,
        isSameName: customerName === booking.name
      });
      
      // For calendar title/summary: Use CRM customer name if available, otherwise booking name
      const calendarTitle = customerName !== booking.name ? customerName : booking.name;
      
      // For customer name in description: Use "New Customer" if no CRM mapping exists
      const descriptionCustomerName = customerName === booking.name ? 'New Customer' : customerName;
      
      console.log('Calendar event names used:', {
        calendarTitle,
        descriptionCustomerName
      });
      
      // Track time for Google Calendar API operation
      const calendarApiStart = Date.now();
      
      const calendarResponse = await calendar.events.insert({
        calendarId,
        requestBody: {
          summary: `${calendarTitle} (${booking.phone_number}) (${booking.number_of_people}) - ${packageInfo} at ${bayDisplayName}`,
          description: `Customer Name: ${descriptionCustomerName}
Booking Name: ${booking.name}
Contact: ${booking.phone_number}
Email: ${booking.email}
Type: ${packageInfo}
Pax: ${booking.number_of_people}
Bay: ${bayDisplayName}
Date: ${formatInTimeZone(parseISO(startDateTime), TIMEZONE, 'EEEE, MMMM d')}
Time: ${formatInTimeZone(parseISO(startDateTime), TIMEZONE, 'HH:mm')} - ${formatInTimeZone(parseISO(endDateTime), TIMEZONE, 'HH:mm')}
Via: Website
Booking ID: ${booking.id}`,
          start: {
            dateTime: startDateTime,
            timeZone: TIMEZONE
          },
          end: {
            dateTime: endDateTime,
            timeZone: TIMEZONE
          },
          colorId: BAY_COLORS[bayDisplayName as keyof typeof BAY_COLORS] || '1'
        }
      }) as CalendarResponse;
      
      const calendarApiDuration = Date.now() - calendarApiStart;
      const totalDuration = Date.now() - startTime;
      
      // Log successful calendar API operation
      if (ENABLE_DETAILED_LOGGING) {
        await logCalendarCreationStep({
          bookingId,
          step: 'Google Calendar API operation',
          status: 'success',
          durationMs: calendarApiDuration,
          metadata: {
            calendarId,
            calendarEventId: calendarResponse.data.id,
            apiDurationMs: calendarApiDuration
          }
        });
      }

      // Return success response with calendar event ID
      return NextResponse.json({
        success: true,
        bookingId: booking.id,
        calendarEventId: calendarResponse.data.id,
        processingTime: totalDuration
      });
    } catch (error: any) {
      console.error('Failed to create calendar event:', error);
      
      // Log Google Calendar API error
      if (ENABLE_DETAILED_LOGGING) {
        await logCalendarCreationStep({
          bookingId,
          step: 'Google Calendar API operation',
          status: 'error',
          durationMs: Date.now() - startTime,
          metadata: {
            error: error.message || 'Unknown error',
            errorCode: error.code || '',
            errorStatus: error.status || '',
            calendarId
          }
        });
      }
      
      return NextResponse.json(
        { error: 'Failed to create calendar event' },
        { status: 500 }
      );
    }
  } catch (error: any) {
    console.error('Error in calendar event creation:', error);
    
    // Log general error
    if (ENABLE_DETAILED_LOGGING) {
      await logCalendarCreationStep({
        bookingId,
        step: 'Calendar creation error',
        status: 'error',
        durationMs: Date.now() - startTime,
        metadata: {
          error: error.message || 'Unknown error'
        }
      });
    }
    
    return NextResponse.json(
      { error: 'An error occurred while creating the calendar event' },
      { status: 500 }
    );
  }
} 



==== app\api\bookings\create\route.ts (840 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { getToken } from 'next-auth/jwt';
import { createServerClient } from '@/utils/supabase/server';
import { formatBookingData } from '@/utils/booking-formatter';
import { executeParallel } from '@/utils/parallel-processing';
import { parse, addHours, addMinutes } from 'date-fns';
import { zonedTimeToUtc, formatInTimeZone } from 'date-fns-tz';
import { getOrCreateCrmMapping, normalizeCrmCustomerData } from '@/utils/customer-matching';
import { BAY_DISPLAY_NAMES, BAY_COLORS } from '@/lib/bayConfig';
import { BOOKING_CALENDARS } from '@/lib/bookingCalendarConfig';
import { calendar } from '@/lib/googleApiConfig';
import { v4 as uuidv4 } from 'uuid';
import { nextTick } from 'node:process';
import { scheduleReviewRequest } from '@/lib/reviewRequestScheduler';

const TIMEZONE = 'Asia/Bangkok';

// Configuration for detailed booking process logging
const ENABLE_DETAILED_LOGGING = process.env.ENABLE_BOOKING_DETAILED_LOGGING === 'true';

// Type definitions for the availability check
interface AvailabilityResult {
  available: boolean;
  bay?: string;
  allAvailableBays?: string[];
}

// Type definitions for the CRM mapping result
interface CrmMappingResult {
  profileId: string;
  crmCustomerId: string;
  stableHashId: string;
  crmCustomerData?: any;
  isNewMatch: boolean;
}

// Helper function to generate a booking ID
const generateBookingId = () => {
  const timestamp = new Date().toISOString().slice(2, 10).replace(/-/g, '');
  const randomNum = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `BK${timestamp}${randomNum}`;
};

/**
 * Helper function to get package info for a customer
 * This centralizes the package info handling logic
 */
async function getPackageInfo(stableHashId: string | null): Promise<string> {
  // Default package info
  let packageInfo = 'Normal Bay Rate';
  
  // If we have a stable hash ID, try to get package info
  if (stableHashId) {
    try {
      const supabase = createServerClient();
      const { data: packages } = await supabase
        .from('crm_packages')
        .select('*')
        .eq('stable_hash_id', stableHashId)
        .gte('expiration_date', new Date().toISOString().split('T')[0]) // Only active packages
        .order('expiration_date', { ascending: true });
      
      if (packages && packages.length > 0) {
        // Filter out coaching packages
        const nonCoachingPackages = packages.filter((pkg: any) => 
          !pkg.package_type_name.toLowerCase().includes('coaching')
        );
        
        if (nonCoachingPackages.length > 0) {
          const activePackage = nonCoachingPackages[0];
          packageInfo = `Package (${activePackage.package_type_name})`;
        }
      }
    } catch (error) {
      console.error('Error looking up packages:', error);
    }
  }
  
  return packageInfo;
}

// Helper function to send notifications
async function sendNotifications(formattedData: any, booking: any, bayDisplayName: string, crmCustomerId?: string, stableHashId?: string, packageInfo: string = 'Normal Bay Rate', customerNotes?: string) {
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
  
  // Start both notifications in parallel using our utility
  const notificationTasks = [
    // Email notification
    async () => {
      try {
        // ALWAYS use booking name for email notification recipient name
        const userName = booking.name;
        
        // For email subject, use CRM customer name unless it's a new customer
        const subjectName = crmCustomerId ? (formattedData.customerName || booking.name) : booking.name;
        
        const emailData = {
          userName,
          subjectName, // Add subject name separately for email subject
          email: formattedData.email || booking.email,
          date: formattedData.formattedDate || booking.date,
          startTime: booking.start_time,
          endTime: formattedData.endTime,
          duration: booking.duration,
          numberOfPeople: booking.number_of_people,
          bayNumber: bayDisplayName,
          userId: booking.user_id,
          crmCustomerId,
          stableHashId,
          skipCrmMatch: true,
          packageInfo,
          standardizedData: formattedData,
          customerNotes
        };
        
        const response = await fetch(`${baseUrl}/api/notifications/email`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(emailData),
        });
        return response;
      } catch (error) {
        console.error('Error sending email notification:', error);
        return null;
      }
    },
    
    // LINE notification
    async () => {
      try {
        // Use customerName from formattedData with fallbacks
        const customerNameForLine = formattedData.customerName || booking.name;
        
        // Always use "New Customer" for unmatched customers
        const lineCustomerName = crmCustomerId ? customerNameForLine : "New Customer";
        
        const lineData = {
          customerName: lineCustomerName,
          bookingName: formattedData.lineNotification?.bookingName || booking.name,
          email: booking.email,
          phoneNumber: booking.phone_number,
          bookingDate: formattedData.formattedDate || booking.date,
          bookingStartTime: booking.start_time,
          bookingEndTime: formattedData.endTime,
          bayNumber: bayDisplayName,
          duration: booking.duration,
          numberOfPeople: booking.number_of_people,
          profileId: booking.user_id,
          crmCustomerId,
          stableHashId,
          skipCrmMatch: true,
          packageInfo,
          standardizedData: formattedData,
          customerNotes
        };
        
        const response = await fetch(`${baseUrl}/api/notifications/line`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(lineData),
        });
        return response;
      } catch (error) {
        console.error('Error sending LINE notification:', error);
        return null;
      }
    }
  ];
  
  // Return the promise for all notifications completing
  return executeParallel(notificationTasks, { timeout: 10000 })
    .then(results => {
      console.log('All notifications sent');
      return { success: true, results };
    })
    .catch(error => {
      console.error('Error sending notifications:', error);
      return { success: false, error };
    });
}

// Function to log booking steps to Supabase
async function logBookingProcessStep({
  bookingId,
  userId,
  step,
  status,
  durationMs,
  totalDurationMs,
  metadata = {}
}: {
  bookingId: string;
  userId: string;
  step: string;
  status: 'success' | 'error' | 'info';
  durationMs: number;
  totalDurationMs: number;
  metadata?: Record<string, any>;
}) {
  if (!ENABLE_DETAILED_LOGGING) return;

  try {
    const supabase = createServerClient();
    await supabase
      .from('booking_process_logs')
      .insert({
        booking_id: bookingId,
        user_id: userId,
        step,
        status,
        duration_ms: durationMs,
        total_duration_ms: totalDurationMs,
        metadata
      });
  } catch (error) {
    // Don't let logging errors affect the booking process
    console.error('Error logging booking process step:', error);
  }
}

export async function POST(request: NextRequest) {
  try {
    // Performance tracking
    const apiStartTime = Date.now();
    let lastCheckpoint = apiStartTime;
    let bookingId = 'pending'; // Will be updated once we have a booking ID
    let userId = ''; // Will be updated once we have authenticated
    
    const logTiming = (step: string, status: 'success' | 'error' | 'info' = 'info', metadata: Record<string, any> = {}) => {
      const now = Date.now();
      const stepDuration = now - lastCheckpoint;
      const totalDuration = now - apiStartTime;
      
      console.log(`[Timing] ${step}: ${stepDuration}ms (total: ${totalDuration}ms)`);
      
      // Log to Supabase if we have a user ID
      if (userId) {
        logBookingProcessStep({
          bookingId,
          userId,
          step,
          status,
          durationMs: stepDuration,
          totalDurationMs: totalDuration,
          metadata
        });
      }
      
      lastCheckpoint = now;
    };

    // 1. Authenticate user
    const token = await getToken({ req: request as any });
    if (!token?.sub) {
      return NextResponse.json(
        { error: 'Unauthorized or session expired' },
        { status: 401 }
      );
    }
    userId = token.sub;
    logTiming('Authentication', 'success');

    // 2. Parse request body
    const {
      name,
      email,
      phone_number,
      date,
      start_time,
      duration,
      number_of_people,
      customer_notes
    } = await request.json();

    // Validate required fields
    if (!name || !email || !phone_number || !date || !start_time || !duration || !number_of_people) {
      logTiming('Request validation', 'error', { 
        missing: [
          !name ? 'name' : null,
          !email ? 'email' : null,
          !phone_number ? 'phone_number' : null,
          !date ? 'date' : null,
          !start_time ? 'start_time' : null,
          !duration ? 'duration' : null,
          !number_of_people ? 'number_of_people' : null
        ].filter(Boolean)
      });
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }
    logTiming('Request parsing', 'success');

    // 3. Format date and time for availability check
    const parsedDateTime = parse(`${date} ${start_time}`, 'yyyy-MM-dd HH:mm', new Date());
    const startDateTime = zonedTimeToUtc(parsedDateTime, TIMEZONE);
    const endDateTime = addHours(startDateTime, duration);
    logTiming('Date parsing', 'success');

    // 4. Get base URL for API calls
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';

    // 5. Run bay availability check and CRM matching in parallel
    const [availabilityResult, crmMappingResult] = await Promise.all([
      // Bay availability check
      (async () => {
        try {
          // Format date and time
          const parsedDateTime = parse(`${date} ${start_time}`, 'yyyy-MM-dd HH:mm', new Date());
          const startDateTime = zonedTimeToUtc(parsedDateTime, TIMEZONE);
          const endDateTime = addHours(startDateTime, duration);

          // Check availability for all bays
          const bayAvailability = await Promise.all(
            Object.entries(BOOKING_CALENDARS).map(async ([bay, calendarId]) => {
              try {
                const events = await calendar.events.list({
                  calendarId,
                  timeMin: formatInTimeZone(startDateTime, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx"),
                  timeMax: formatInTimeZone(endDateTime, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx"),
                  singleEvents: true,
                  orderBy: 'startTime',
                });

                return {
                  bay,
                  available: !events.data.items || events.data.items.length === 0
                };
              } catch (error) {
                console.error(`Error checking availability for bay ${bay}:`, error);
                return { bay, available: false };
              }
            })
          );

          // Find available bays
          const availableBays = bayAvailability.filter(bay => bay.available);
          
          if (availableBays.length === 0) {
            return { available: false };
          }

          // Return the first available bay
          return {
            available: true,
            bay: availableBays[0].bay,
            allAvailableBays: availableBays.map(b => b.bay)
          };
        } catch (error) {
          console.error('Error checking bay availability:', error);
          return { available: false };
        }
      })(),
      
      // CRM matching - get complete mapping data including CRM customer data
      (async () => {
        if (!token.sub) return null;
        
        try {
          // First check for existing mapping
          const supabase = createServerClient();
          const { data: mapping, error: mappingError } = await supabase
            .from('crm_customer_mapping')
            .select('crm_customer_id, stable_hash_id, crm_customer_data')
            .eq('profile_id', token.sub)
            .eq('is_matched', true)
            .order('match_confidence', { ascending: false })
            .order('updated_at', { ascending: false })
            .maybeSingle();
          
          if (mappingError) {
            console.error('Error checking for CRM mapping:', mappingError);
            return null;
          }
          
          if (mapping) {
            return {
              profileId: token.sub,
              crmCustomerId: mapping.crm_customer_id,
              stableHashId: mapping.stable_hash_id,
              crmCustomerData: mapping.crm_customer_data,
              isNewMatch: false
            };
          }
          
          // If no mapping found, try creating one
          return await getOrCreateCrmMapping(token.sub, { source: 'booking' });
        } catch (error) {
          console.error('Error in CRM mapping:', error);
          return null;
        }
      })()
    ]).catch(error => {
      console.error('Error in parallel operations:', error);
      logTiming('Parallel operations failure', 'error', { error: error.message });
      return [{ available: false }, null];
    });
    
    // Log more detailed info about the results
    logTiming('Parallel operations (availability + CRM)', 'success', {
      bayAvailability: availabilityResult?.available || false,
      availableBays: (availabilityResult as any)?.allAvailableBays || [],
      crmMatchFound: !!(crmMappingResult as any)?.crmCustomerId,
      isNewCrmMatch: !!(crmMappingResult as any)?.isNewMatch
    });

    // 6. Handle availability result
    if (!availabilityResult || !availabilityResult.available) {
      logTiming('Bay availability check', 'error', { available: false });
      return NextResponse.json(
        { error: 'No bays available for the selected time slot' },
        { status: 400 }
      );
    }

    // Get the assigned bay and its display name
    const availabilityResultWithBay = availabilityResult as AvailabilityResult & { bay: string };
    const availableBay = availabilityResultWithBay.bay;
    const bayDisplayName = BAY_DISPLAY_NAMES[availableBay] || availableBay;

    // 7. Handle CRM matching result
    let crmCustomerId = null;
    let stableHashId = null;
    let crmCustomerData = null;
    let customerName = null;
    let isNewCustomer = true; // Flag to identify new customers

    if (crmMappingResult) {
      if ('crmCustomerId' in crmMappingResult) {
        crmCustomerId = crmMappingResult.crmCustomerId;
        stableHashId = crmMappingResult.stableHashId;
        isNewCustomer = false; // Customer exists in CRM system
        
        // Extract CRM customer data if available
        if ('crmCustomerData' in crmMappingResult && crmMappingResult.crmCustomerData) {
          crmCustomerData = crmMappingResult.crmCustomerData;
          
          // Normalize the customer data
          const normalizedCrmData = normalizeCrmCustomerData(crmCustomerData);
          
          if (normalizedCrmData?.name) {
            customerName = normalizedCrmData.name;
          }
        }
      }
    }

    // 8. Create booking record in Supabase
    const supabase = createServerClient();
    const { data: booking, error: bookingError } = await supabase
      .from('bookings')
      .insert({
        id: generateBookingId(),
        name,
        email,
        phone_number,
        date,
        start_time,
        duration,
        number_of_people,
        customer_notes,
        user_id: token.sub,
        bay: availableBay,
        status: 'confirmed'
      })
      .select()
      .single();

    if (bookingError || !booking) {
      console.error('Error creating booking:', bookingError);
      logTiming('Booking record creation', 'error', { 
        error: bookingError?.message || 'Unknown error'
      });
      return NextResponse.json(
        { error: 'Failed to create booking record' },
        { status: 500 }
      );
    }
    
    // Update bookingId once we have it
    bookingId = booking.id;
    logTiming('Booking record creation', 'success', { bookingId });

    // If we don't have a customer name from CRM, use the booking name
    if (!customerName) {
      customerName = booking.name;
    }
    
    // Get package info using the centralized function
    const packageInfo = await getPackageInfo(stableHashId);
    logTiming('Customer data lookup', 'success');

    // Now log detailed CRM customer match information after package info is available
    if (crmMappingResult && 'crmCustomerId' in crmMappingResult) {
      // Log detailed CRM customer match information
      logTiming('CRM customer match', 'success', {
        crmCustomerId,
        stableHashId,
        matchedName: customerName,
        isNewMatch: (crmMappingResult as any)?.isNewMatch || false,
        confidence: (crmMappingResult as any)?.confidence,
        crmCustomerDetails: {
          name: crmCustomerData ? normalizeCrmCustomerData(crmCustomerData)?.name || null : null,
          phone: crmCustomerData ? normalizeCrmCustomerData(crmCustomerData)?.phone_number || null : null,
          email: crmCustomerData ? normalizeCrmCustomerData(crmCustomerData)?.email || null : null,
          hasActivePackage: !!packageInfo && packageInfo !== 'Normal Bay Rate'
        }
      });
    } else if (crmMappingResult) {
      // Log failed CRM match
      logTiming('CRM customer match', 'info', {
        matched: false,
        reason: 'No matching CRM customer found'
      });
    } else {
      // Log failure in CRM matching process
      logTiming('CRM customer match', 'error', {
        matched: false,
        reason: 'CRM matching process failed'
      });
    }

    // Derive booking_type and package_name from packageInfo string
    let derivedBookingType: string;
    let derivedPackageName: string | null = null;

    const packagePrefix = 'Package (';
    if (packageInfo.startsWith(packagePrefix) && packageInfo.endsWith(')')) {
      derivedBookingType = 'Package';
      derivedPackageName = packageInfo.substring(packagePrefix.length, packageInfo.length - 1);
    } else {
      derivedBookingType = packageInfo; // e.g., "Normal Bay Rate", "Coaching", etc.
      // derivedPackageName remains null
    }

    // Update booking with booking_type and package_name
    const { error: updateBookingTypeError } = await supabase
      .from('bookings')
      .update({ 
        booking_type: derivedBookingType,
        package_name: derivedPackageName
      })
      .eq('id', booking.id);

    if (updateBookingTypeError) {
      console.error('Error updating booking with type and package name:', updateBookingTypeError);
      logTiming('Booking type/package update', 'error', { error: updateBookingTypeError.message });
      // Decide if this is a critical error to stop the process
    } else {
      logTiming('Booking type/package update', 'success', { booking_type: derivedBookingType, package_name: derivedPackageName });
    }
    
    // Update the local booking object with these details
    // Also, set package_info on the local object for compatibility with formatBookingData if it expects it.
    // This assumes 'booking' type might need casting or is flexible.
    booking.booking_type = derivedBookingType;
    booking.package_name = derivedPackageName;
    (booking as any).package_info = packageInfo; // For downstream compatibility (e.g. formatBookingData)

    // 9. Format booking data for all services
    const formattedData = formatBookingData({
      booking,
      crmData: crmCustomerId ? { 
        id: crmCustomerId,
        name: customerName  // Use the normalized CRM customer name
      } : null,
      bayInfo: {
        id: availableBay,
        displayName: bayDisplayName
      }
    });
    logTiming('Data formatting', 'success');
    
    // Send notifications in parallel and wait for them to complete
    const notificationResults = await sendNotifications(
      formattedData,
      booking,
      bayDisplayName,
      crmCustomerId || undefined,
      stableHashId || undefined,
      packageInfo,
      customer_notes
    );

    // Log each notification type separately instead of logging them together
    if (notificationResults.success) {
      // Check individual notification results (if available)
      if ('results' in notificationResults && Array.isArray(notificationResults.results)) {
        // Email notification (first item in the results array)
        const emailResult = notificationResults.results[0];
        logTiming('Email notification', emailResult ? 'success' : 'error', {
          success: !!emailResult,
          recipient: booking.email,
          statusCode: emailResult?.status
        });
        
        // LINE notification (second item in the results array)
        const lineResult = notificationResults.results[1];
        logTiming('LINE notification', lineResult ? 'success' : 'error', {
          success: !!lineResult,
          statusCode: lineResult?.status
        });
      } else {
        // If we don't have detailed results, log overall success
        logTiming('Notifications', 'success', {
          success: true
        });
      }
    } else {
      // Log notification failure
      logTiming('Notifications', 'error', {
        success: false,
        error: (notificationResults as any).error?.message
      });
    }
    
    // 10. Trigger calendar creation in the background (still non-blocking)
    // This is non-blocking - we'll return to the user before it completes
    
    // Format date and time for calendar
    const calendarDateTime = parse(`${booking.date} ${booking.start_time}`, 'yyyy-MM-dd HH:mm', new Date());
    const calendarStartTime = zonedTimeToUtc(calendarDateTime, TIMEZONE);
    const calendarEndTime = addHours(calendarStartTime, booking.duration);
    
    // Trigger calendar creation with all required data (non-blocking)
    const calendarData = {
      bookingId: booking.id,
      booking,
      customerName,  // Use the normalized CRM customer name
      bayDisplayName,
      startDateTime: formatInTimeZone(calendarStartTime, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx"),
      endDateTime: formatInTimeZone(calendarEndTime, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx"),
      packageInfo
    };
    
    // Log calendar creation initiation
    logTiming('Calendar creation initiated', 'info', {
      bookingId: booking.id,
      bay: availableBay,
      bayDisplayName,
      startDateTime: calendarData.startDateTime,
      endDateTime: calendarData.endDateTime
    });

    // Use setTimeout to make this non-blocking
    setTimeout(() => {
      fetch(`${baseUrl}/api/bookings/calendar/create`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': request.headers.get('Authorization') || ''
        },
        body: JSON.stringify(calendarData)
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`Calendar creation failed with status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        if (data.calendarEventId) {
          const eventId = data.calendarEventId;
          const bookingToUpdateId = booking.id; // Capture booking id for use in this scope
          
          // Determine calendarId based on the booking's bay
          // booking.bay should be available here from the earlier insert/select
          const bookedBay = booking.bay; // Assuming booking object is in scope and has .bay
          const calendarIdForUpdate = bookedBay ? BOOKING_CALENDARS[bookedBay as keyof typeof BOOKING_CALENDARS] : undefined;

          if (!calendarIdForUpdate) {
            console.error(`[Booking Create API - Async] Could not determine calendarId for booking ${bookingToUpdateId} with bay ${bookedBay}. Cannot update calendar_events.`);
            if (ENABLE_DETAILED_LOGGING && userId) {
              logBookingProcessStep({
                bookingId: bookingToUpdateId,
                userId,
                step: 'Update booking with calendar_events',
                status: 'error',
                durationMs: 0,
                totalDurationMs: Date.now() - apiStartTime,
                metadata: { error: 'Could not determine calendarId for update', eventId: eventId, bay: bookedBay }
              });
            }
            return; // Stop if no calendarId can be found
          }

          const newCalendarEventsEntry = [{
            eventId: eventId,
            calendarId: calendarIdForUpdate,
            status: "confirmed"
          }];
          
          // Update booking with the new calendar_events field
          supabase
            .from('bookings')
            .update({ calendar_events: newCalendarEventsEntry }) // Update calendar_events
            .eq('id', bookingToUpdateId) // Essential: target the correct booking
            .then(({ error: updateError }) => { // Destructure error from the promise result
              if (updateError) {
                console.error(`[Booking Create API - Async] Failed to update booking ${bookingToUpdateId} with calendar_events ${JSON.stringify(newCalendarEventsEntry)}:`, updateError);
                // Log the error to booking_process_logs if needed
                if (ENABLE_DETAILED_LOGGING && userId) {
                     logBookingProcessStep({
                        bookingId: bookingToUpdateId,
                        userId,
                        step: 'Update booking with calendar_events', // Updated step name
                        status: 'error',
                        durationMs: 0, // Duration isn't tracked precisely here
                        totalDurationMs: Date.now() - apiStartTime,
                        metadata: { error: updateError.message, eventDetails: newCalendarEventsEntry }
                    });
                }
              } else {
                console.log(`[Booking Create API - Async] Successfully updated booking ${bookingToUpdateId} with calendar_events ${JSON.stringify(newCalendarEventsEntry)}`);
                // Log successful calendar creation AND booking update
                if (ENABLE_DETAILED_LOGGING && userId) {
                  logBookingProcessStep({
                    bookingId: bookingToUpdateId,
                    userId,
                    step: 'Calendar creation completed & booking updated with calendar_events', // Updated step name
                    status: 'success',
                    durationMs: data.processingTime || 0, // From calendar API response
                    totalDurationMs: Date.now() - apiStartTime,
                    metadata: {
                      calendarEvents: newCalendarEventsEntry,
                      processingTime: data.processingTime
                    }
                  });
                }
              }
            });
        } else {
            // Handle case where calendarEventId is missing from the response
            console.error(`[Booking Create API - Async] Calendar API call succeeded but event ID was missing for booking ${booking.id}. Response data:`, data);
             if (ENABLE_DETAILED_LOGGING && userId) {
                logBookingProcessStep({
                    bookingId: booking.id,
                    userId,
                    step: 'Update booking with calendar_event_id', // This log can remain or be updated
                    status: 'error',
                    durationMs: 0,
                    totalDurationMs: Date.now() - apiStartTime,
                    metadata: { error: 'Calendar event ID missing in calendar API response', responseData: data }
                });
            }
        }
      })
      .catch(error => {
        console.error('Error in calendar creation:', error);
        
        // Log calendar creation error
        if (ENABLE_DETAILED_LOGGING) {
          logBookingProcessStep({
            bookingId: booking.id,
            userId,
            step: 'Calendar creation error',
            status: 'error',
            durationMs: 0,
            totalDurationMs: Date.now() - apiStartTime,
            metadata: {
              error: error.message
            }
          });
        }
      });
    }, 0);

    // After successful booking creation, schedule review request for new customers
    if (isNewCustomer && token.sub) {
      try {
        // Check if this is a LINE user by examining the profile
        const { data: profile } = await supabase
          .from('profiles')
          .select('provider, provider_id')
          .eq('id', token.sub)
          .single();
        
        // Determine the notification provider (LINE or email)
        const provider = profile?.provider === 'line' ? 'line' : 'email';
        
        // Get the appropriate contact info based on the provider
        // For LINE users, use provider_id (LINE user ID) instead of user_id
        const contactInfo = provider === 'line' 
          ? profile?.provider_id || '' // Use LINE provider_id
          : booking.email;             // Use booking email for non-LINE users
        
        // Make sure we have valid contact info
        if (!contactInfo) {
          console.error('Missing contact info for review request', { provider, profile });
          throw new Error('Missing contact info for review request');
        }
        
        // Schedule the review request to be sent 30 minutes after booking ends
        // The scheduler will calculate this based on booking details
        const scheduled = await scheduleReviewRequest({
          bookingId: booking.id,
          userId: token.sub,
          provider,
          contactInfo
          // No delayMinutes - use booking end time + 30 minutes
        });
        
        if (scheduled) {
          logTiming('Review request scheduling', 'success', { 
            provider, 
            bookingId: booking.id,
            bookingDuration: booking.duration
          });
        } else {
          logTiming('Review request scheduling', 'error', { error: 'Failed to schedule' });
        }
      } catch (reviewRequestError) {
        // Log error but don't fail the booking process
        logTiming('Review request scheduling', 'error', { 
          error: reviewRequestError instanceof Error ? reviewRequestError.message : 'Unknown error'
        });
      }
    }

    // 11. Return success response to user with notification status
    return NextResponse.json({
      success: true,
      booking,
      bookingId: booking.id,
      bay: availableBay,
      bayDisplayName,
      crmCustomerId,
      stableHashId,
      notificationsSuccess: notificationResults.success,
      processingTime: Date.now() - apiStartTime
    });
  } catch (error) {
    console.error('Exception in booking creation:', error);
    return NextResponse.json(
      { error: 'An error occurred while creating the booking' },
      { status: 500 }
    );
  }
} 



==== app\api\crm\mapping\route.ts (68 lines) ====

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/options';
import type { NextRequest } from 'next/server';
import { createServerClient } from '@/utils/supabase/server';
import { getCrmCustomerForProfile, matchProfileWithCrm } from '@/utils/customer-matching';

/**
 * Get the CRM customer mapped to a profile
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(request.url);
    const profileId = url.searchParams.get('profileId');

    if (!profileId) {
      return NextResponse.json({ error: 'Profile ID is required' }, { status: 400 });
    }

    // Users can only access their own mapping
    if (session.user.id !== profileId) {
      return NextResponse.json({ error: 'You can only access your own mapping' }, { status: 403 });
    }

    const crmCustomer = await getCrmCustomerForProfile(profileId);

    return NextResponse.json({
      success: true,
      crmCustomer: crmCustomer || null
    });
  } catch (error) {
    console.error('Error getting CRM mapping:', error);
    return NextResponse.json({ error: 'Failed to get CRM mapping' }, { status: 500 });
  }
}

/**
 * Force a new matching attempt for a profile
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { profileId } = await request.json();
    if (!profileId) {
      return NextResponse.json({ error: 'Profile ID is required' }, { status: 400 });
    }

    // Users can only match their own profile
    if (session.user.id !== profileId) {
      return NextResponse.json({ error: 'You can only match your own profile' }, { status: 403 });
    }

    const result = await matchProfileWithCrm(profileId);
    return NextResponse.json({ success: true, result });
  } catch (error) {
    console.error('Error matching profile:', error);
    return NextResponse.json({ error: 'Failed to match profile' }, { status: 500 });
  }
} 



==== app\api\crm\match\route.ts (79 lines) ====

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/options';
import type { NextRequest } from 'next/server';
import { createServerClient } from '@/utils/supabase/server';
import { matchProfileWithCrm } from '@/utils/customer-matching';

/**
 * Get the CRM customer mapped to a profile
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(request.url);
    const profileId = url.searchParams.get('profileId');

    if (!profileId) {
      return NextResponse.json({ error: 'Profile ID is required' }, { status: 400 });
    }

    // Users can only access their own mapping
    if (session.user.id !== profileId) {
      return NextResponse.json({ error: 'You can only access your own mapping' }, { status: 403 });
    }

    const supabase = createServerClient();
    const { data: mapping, error } = await supabase
      .from('crm_customer_mapping')
      .select('crm_customer_id, crm_customer_data')
      .eq('profile_id', profileId)
      .eq('is_matched', true)
      .maybeSingle();
      
    if (error) {
      console.error('Error retrieving CRM mapping:', error);
    }

    return NextResponse.json({
      success: true,
      mapping: mapping || null
    });
  } catch (error) {
    console.error('Exception in CRM mapping request:', error);
    return NextResponse.json({ error: 'Failed to get CRM mapping' }, { status: 500 });
  }
}

/**
 * Force a new matching attempt for a profile
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { profileId } = await request.json();
    if (!profileId) {
      return NextResponse.json({ error: 'Profile ID is required' }, { status: 400 });
    }

    // Users can only match their own profile
    if (session.user.id !== profileId) {
      return NextResponse.json({ error: 'You can only match your own profile' }, { status: 403 });
    }

    const result = await matchProfileWithCrm(profileId);
    
    return NextResponse.json({ success: true, result });
  } catch (error) {
    console.error('Exception in CRM matching request:', error);
    return NextResponse.json({ error: 'Failed to match profile' }, { status: 500 });
  }
} 



==== app\api\crm\packages\route.ts (72 lines) ====

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/options';
import type { NextRequest } from 'next/server';
import { getPackagesForProfile, syncPackagesForProfile } from '@/utils/supabase/crm-packages';

/**
 * Get packages for a profile
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const url = new URL(request.url);
    const profileId = url.searchParams.get('profileId');

    if (!profileId) {
      return NextResponse.json({ error: 'Profile ID is required' }, { status: 400 });
    }

    // Users can only access their own packages
    if (session.user.id !== profileId) {
      return NextResponse.json({ error: 'You can only access your own packages' }, { status: 403 });
    }

    const packages = await getPackagesForProfile(profileId);

    return NextResponse.json({
      success: true,
      packages
    });
  } catch (error) {
    console.error('Error getting packages:', error);
    return NextResponse.json({ error: 'Failed to get packages' }, { status: 500 });
  }
}

/**
 * Force a package sync for a profile
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { profileId } = await request.json();
    if (!profileId) {
      return NextResponse.json({ error: 'Profile ID is required' }, { status: 400 });
    }

    // Users can only sync their own packages
    if (session.user.id !== profileId) {
      return NextResponse.json({ error: 'You can only sync your own packages' }, { status: 403 });
    }

    await syncPackagesForProfile(profileId);
    const packages = await getPackagesForProfile(profileId);

    return NextResponse.json({
      success: true,
      packages
    });
  } catch (error) {
    console.error('Error syncing packages:', error);
    return NextResponse.json({ error: 'Failed to sync packages' }, { status: 500 });
  }
} 



==== app\api\crm\profile\route.ts (60 lines) ====

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/options';
import type { NextRequest } from 'next/server';
import { matchProfileWithCrm } from '@/utils/customer-matching';

/**
 * Get a profile with its CRM data
 * This endpoint:
 * 1. Checks/updates CRM mapping
 * 2. Returns the profile with its CRM data
 * 
 * Query parameters:
 * - force=true: Force a new matching attempt
 */
export async function GET(request: NextRequest) {
  try {
    // Get session to verify the user is authenticated
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check for force param to bypass cached results
    const url = new URL(request.url);
    const forceCheck = url.searchParams.get('force') === 'true';

    // Log the request
    console.log(`Profile check for user ${session.user.id}${forceCheck ? ' (forced)' : ''}`);

    // If forcing, do a fresh match attempt
    let result = null;
    if (forceCheck) {
      result = await matchProfileWithCrm(session.user.id);
    }

    // Add timestamp to response
    const responseData = {
      success: true,
      timestamp: new Date().toISOString(),
      mapping: result
    };

    return NextResponse.json(responseData);
  } catch (error) {
    console.error('Error checking profile:', error);
    return NextResponse.json(
      {
        error: 'Failed to check profile',
        details: (error as Error).message,
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    );
  }
}

// Ensure the function runs every time
export const dynamic = 'force-dynamic';
export const revalidate = 0; 



==== app\api\notifications\email\review-request\route.ts (166 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import nodemailer from 'nodemailer';

// Email configuration - use the same as in emailService.ts
const EMAIL_HOST = process.env.EMAIL_HOST || '27.254.86.99';
const EMAIL_PORT = parseInt(process.env.EMAIL_PORT || '587');
const EMAIL_USER = process.env.EMAIL_USER;
const EMAIL_PASS = process.env.EMAIL_PASSWORD;
const EMAIL_FROM = process.env.EMAIL_FROM || 'notification@len.golf';

interface ReviewRequestBody {
  email: string;
  userName: string;
  bookingDate?: string;
  reviewUrl: string;
  voucherImageUrl: string;
}

export async function POST(request: NextRequest) {
  try {
    // 1. Check email configuration
    if (!EMAIL_USER || !EMAIL_PASS) {
      console.error('Email configuration missing');
      return NextResponse.json(
        { error: 'Email service not configured' },
        { status: 500 }
      );
    }

    // 2. Parse request body
    const body: ReviewRequestBody = await request.json();
    const { email, userName, bookingDate, reviewUrl, voucherImageUrl } = body;

    // 3. Validate required fields
    if (!email || !userName || !reviewUrl) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Ensure the voucher image URL is a valid, fully-qualified URL with HTTPS
    let safeVoucherImageUrl = voucherImageUrl;
    
    // Check if URL is already HTTPS
    if (!safeVoucherImageUrl.startsWith('https://')) {
      // If it starts with HTTP, convert to HTTPS
      if (safeVoucherImageUrl.startsWith('http://')) {
        console.log(`Converting HTTP image URL to HTTPS: ${safeVoucherImageUrl}`);
        safeVoucherImageUrl = safeVoucherImageUrl.replace('http://', 'https://');
      } 
      // If it's a relative URL (starts with / or doesn't have protocol), use a fallback
      else if (safeVoucherImageUrl.startsWith('/') || !safeVoucherImageUrl.includes('://')) {
        console.log(`Using fallback for relative URL: ${safeVoucherImageUrl}`);
        safeVoucherImageUrl = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher_email.png';
      }
    }
    
    console.log(`Using email voucher image URL: ${safeVoucherImageUrl}`);

    // 4. Create email transporter with same config as emailService.ts
    const transporter = nodemailer.createTransport({
      host: EMAIL_HOST,
      port: EMAIL_PORT,
      secure: false,
      auth: {
        user: EMAIL_USER,
        pass: EMAIL_PASS,
      },
      tls: {
        rejectUnauthorized: false, // Allow self-signed certificates if necessary
      },
    });

    // 5. Create email content
    const mailOptions = {
      from: `"LENGOLF" <${EMAIL_FROM}>`,
      to: email,
      subject: 'Enjoy a FREE HOUR on Your Next Visit to LENGOLF!',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; border: 1px solid #ddd; border-radius: 8px; background-color: #ffffff;">
          <div style="text-align: center; margin-bottom: 20px;">
            <img src="https://www.len.golf/wp-content/uploads/2024/06/Logo.png" alt="LENGOLF Logo" style="max-width: 200px;">
          </div>
          
          <div style="margin-bottom: 30px;">
            <h2 style="color: #1a3308; text-align: center; margin-bottom: 15px;">Thank You for Visiting LENGOLF!</h2>
            <p>Hello ${userName},</p>
            <p>We hope you enjoyed your golf session. ðŸŒï¸â€â™‚ï¸</p>
            <p>Your feedback is important to us! Please consider taking a moment to share your experience by leaving a Google review.</p>
          </div>
          
          <div style="background-color: #f5f5f5; padding: 20px; border-radius: 5px; margin-bottom: 30px;">
            <h3 style="color: #1a3308; margin-top: 0; text-align: center;">Special Offer Just for You!</h3>
            <p style="text-align: center; font-weight: bold; font-size: 18px; color: #1a3308;">1 FREE HOUR + 1 FREE SOFT DRINK</p>
            <p style="text-align: center;">As a token of our appreciation for your feedback!</p>
            <div style="text-align: center; margin: 20px 0;">
              <img src="${safeVoucherImageUrl}" alt="LENGOLF Special Offer" style="max-width: 100%; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
            </div>
            <p style="text-align: center;"><em><strong>To redeem your offer:</strong> Please show both your Google review and this email during your next visit.</em></p>
          </div>
          
          <div style="text-align: center; margin-bottom: 30px;">
            <a href="${reviewUrl}" style="display: inline-block; background-color: #1a3308; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; font-weight: bold;">
              Leave a Google Review
            </a>
          </div>
          
          <!-- Footer -->
          <div style="font-size: 14px; color: #777; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
              <p style="margin: 5px 0; text-align: center;">
                  <strong>Phone Number:</strong> <a href="tel:+66966682335" style="color: #8dc743; text-decoration: none;">+66 96 668 2335</a>
              </p>
              <p style="margin: 5px 0; text-align: center;">
                  <strong>LINE:</strong> <a href="https://lin.ee/UwwOr84" style="color: #8dc743; text-decoration: none;">@lengolf</a>
              </p>
              <p style="margin: 5px 0; text-align: center;">
                  <strong>Maps Link:</strong> <a href="https://maps.app.goo.gl/U6rgZyjCwC46dABy6" style="color: #8dc743; text-decoration: none;">How to find us</a>
              </p>
              <p style="margin: 5px 0; text-align: center;">
                  <strong>Address:</strong> 4th Floor, Mercury Ville at BTS Chidlom
              </p>
              <div style="text-align: center; margin-top: 20px;">
                  <a href="https://len.golf" style="text-decoration: none; color: white; background-color: #1a3308; padding: 8px 15px; border-radius: 5px; font-size: 14px;">
                      Visit Our Website
                  </a>
              </div>
              <p style="font-size: 12px; margin-top: 15px; color: #777; text-align: center;">
                  &copy; 2024 LENGOLF. All rights reserved.
              </p>
          </div>
        </div>
      `,
    };

    // 6. Send email
    try {
      const info = await transporter.sendMail(mailOptions);
      
      // 7. Return success response
      return NextResponse.json({
        success: true,
        email,
        messageId: info.messageId
      });
    } catch (error: unknown) {
      console.error('Error sending email:', error);
      
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      return NextResponse.json(
        { 
          error: 'Failed to send email',
          details: errorMessage
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Exception in email review request:', error);
    return NextResponse.json(
      { error: 'An error occurred while sending email review request' },
      { status: 500 }
    );
  }
} 



==== app\api\notifications\email\route.ts (87 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { sendConfirmationEmail } from '@/lib/emailService';

interface EmailConfirmation {
  userName: string;
  subjectName?: string;
  email: string;
  date: string;
  startTime: string;
  endTime: string;
  duration: number;
  numberOfPeople: number;
  bayNumber?: string;
  phoneNumber?: string;
  packageInfo?: string;
  customerNotes?: string;
  // Optional standardized data field from the formatter
  standardizedData?: {
    emailData: {
      userDisplayName: string;
      subject: string;
    },
    // Common fields
    bookingId: string;
    customerName: string;
    email: string;
    phoneNumber: string;
    date: string;
    formattedDate: string;
    startTime: string;
    endTime: string;
    bayName: string;
    duration: number;
    numberOfPeople: number;
  }
}

export async function POST(request: NextRequest) {
  try {
    const { customerNotes, ...bookingData }: EmailConfirmation & { customerNotes?: string } = await request.json();

    // Check if we have standardized data from the formatter
    if (bookingData.standardizedData) {
      const std = bookingData.standardizedData;
      
      // Send email confirmation with standardized data
      await sendConfirmationEmail({
        userName: bookingData.userName || std.emailData.userDisplayName,
        subjectName: bookingData.subjectName || std.customerName,
        email: std.email,
        date: std.formattedDate,
        startTime: std.startTime,
        endTime: std.endTime,
        bayNumber: std.bayName,
        duration: std.duration,
        numberOfPeople: std.numberOfPeople,
        packageInfo: bookingData.packageInfo,
        customerNotes: customerNotes
      });
      
      return NextResponse.json({ success: true });
    }

    // Fallback to legacy format for backward compatibility
    await sendConfirmationEmail({
      userName: bookingData.userName,
      subjectName: bookingData.subjectName || bookingData.userName,
      email: bookingData.email,
      date: bookingData.date,
      startTime: bookingData.startTime,
      endTime: bookingData.endTime,
      bayNumber: bookingData.bayNumber,
      duration: bookingData.duration,
      numberOfPeople: bookingData.numberOfPeople,
      packageInfo: bookingData.packageInfo,
      customerNotes: customerNotes
    });
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error in email notification handler:', error);
    return NextResponse.json(
      { error: 'Failed to send email confirmation' },
      { status: 500 }
    );
  }
} 



==== app\api\notifications\line\review-request\route.ts (169 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/utils/supabase/server';

const LINE_MESSAGING_API = 'https://api.line.me/v2/bot/message/push';
const LINE_CHANNEL_ACCESS_TOKEN = process.env.LINE_CHANNEL_ACCESS_TOKEN;

interface LineErrorDetail {
  message: string;
}

interface LineErrorResponse {
  message?: string;
  details?: LineErrorDetail[];
}

interface ReviewRequestBody {
  userId: string;
  bookingName: string;
  customerName?: string;
  bookingDate?: string;
  reviewUrl: string;
  voucherImageUrl: string;
}

export async function POST(request: NextRequest) {
  try {
    // 1. Check LINE API configuration
    if (!LINE_CHANNEL_ACCESS_TOKEN) {
      console.error('LINE_CHANNEL_ACCESS_TOKEN is missing');
      return NextResponse.json(
        { error: 'LINE API not configured' },
        { status: 500 }
      );
    }

    // 2. Parse request body
    const body: ReviewRequestBody = await request.json();
    const { userId, bookingName, customerName, bookingDate, reviewUrl, voucherImageUrl } = body;

    // 3. Validate required fields
    if (!userId || !bookingName || !reviewUrl) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Use customer name if provided, otherwise use booking name or a generic greeting
    const greeting = customerName ? `Hello ${customerName}! ` : '';
    
    // 4. Build LINE message
    // Validate image URL - must be HTTPS for LINE API
    let safeVoucherImageUrl = voucherImageUrl;
    if (safeVoucherImageUrl && !safeVoucherImageUrl.startsWith('https://')) {
      console.warn(`WARNING: LINE API requires HTTPS image URLs. Converting ${safeVoucherImageUrl} to HTTPS`);
      safeVoucherImageUrl = safeVoucherImageUrl.replace('http://', 'https://');
      
      // If image URL is still not HTTPS, use a fallback image
      if (!safeVoucherImageUrl.startsWith('https://')) {
        console.warn(`Using fallback image URL for LINE message as original URL wasn't HTTPS`);
        safeVoucherImageUrl = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher.png';
      }
    }
    
    console.log(`Using image URL for LINE message: ${safeVoucherImageUrl}`);
    
    // Ensure text lengths are within LINE limits
    const titleText = 'LENGOLF Special Offer';
    const messageText = '1 FREE HOUR + FREE DRINK on your next visit!';
    
    // Create the LINE message
    const message = {
      to: userId,
      messages: [
        {
          type: 'text',
          text: `${greeting}Thank you for visiting LENGOLF! We hope you enjoyed your golf session. â›³ðŸŒï¸â€â™‚`
        },
        {
          type: 'text',
          text: 'Your feedback is important to us! Please consider leaving us a Google review and receive a special thank you offer: 1 FREE HOUR + 1 FREE SOFT DRINK on your next visit!'
        },
        {
          type: 'template',
          altText: 'Leave a Google Review for LENGOLF - Get 1 FREE HOUR + FREE DRINK',
          template: {
            type: 'buttons',
            thumbnailImageUrl: safeVoucherImageUrl,
            imageAspectRatio: 'rectangle',
            imageSize: 'cover',
            title: titleText,
            text: messageText,
            actions: [
              {
                type: 'uri',
                label: 'Write a Review',
                uri: reviewUrl
              }
            ]
          }
        },
        {
          type: 'text',
          text: 'To redeem your offer, please show both your Google review and this LINE message during your next visit. Thank you!'
        }
      ]
    };
    
    console.log('LINE message payload:', JSON.stringify(message, null, 2));

    // 5. Send LINE message
    try {
      const response = await fetch(LINE_MESSAGING_API, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${LINE_CHANNEL_ACCESS_TOKEN}`
        },
        body: JSON.stringify(message)
      });

      if (!response.ok) {
        // Get the response text to see the detailed error
        const errorText = await response.text();
        let errorDetails = errorText;
        
        // Try to parse the error response as JSON if possible
        try {
          const errorJson = JSON.parse(errorText);
          errorDetails = JSON.stringify(errorJson, null, 2);
        } catch (e) {
          // Keep as text if not JSON
        }
        
        console.error(`LINE API error details: ${errorDetails}`);
        throw new Error(`LINE API error: ${response.status} ${response.statusText} - ${errorDetails}`);
      }

      const responseData = await response.json();

      // 6. Return success response
      return NextResponse.json({
        success: true,
        userId,
        messageId: responseData?.messageId
      });
    } catch (error: unknown) {
      console.error('Error sending LINE message:', error);
      
      // Get error message
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      return NextResponse.json(
        { 
          error: 'Failed to send LINE message',
          details: errorMessage
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Exception in LINE review request:', error);
    return NextResponse.json(
      { error: 'An error occurred while sending LINE review request' },
      { status: 500 }
    );
  }
} 




==== app\api\notifications\line\route.ts (191 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { LINE_NOTIFY_TOKEN } from '@/lib/env';

interface BookingNotification {
  customerName: string;
  email: string;
  phoneNumber: string;
  bookingDate: string;
  bookingStartTime: string;
  bookingEndTime: string;
  bayNumber: string;
  duration: number;
  numberOfPeople: number;
  bookingName: string;
  packageInfo?: string;
  crmCustomerId?: string;
  customerNotes?: string;
  bookingId?: string;
  // Optional standardized data field from the formatter
  standardizedData?: {
    lineNotification: {
      bookingName: string;
      customerLabel: string;
    },
    // Common fields
    bookingId: string;
    customerName: string;
    email: string;
    phoneNumber: string;
    date: string;
    formattedDate: string;
    startTime: string;
    endTime: string;
    bayName: string;
    duration: number;
    numberOfPeople: number;
    isNewCustomer?: boolean;
    crmCustomerId?: string;
  }
}

export async function POST(request: NextRequest) {
  try {
    // Check if LINE environment variables are set
    console.log('LINE environment variables check:', {
      hasChannelAccessToken: !!process.env.LINE_CHANNEL_ACCESS_TOKEN,
      hasGroupId: !!process.env.LINE_GROUP_ID,
      channelAccessTokenLength: process.env.LINE_CHANNEL_ACCESS_TOKEN?.length || 0,
      groupIdLength: process.env.LINE_GROUP_ID?.length || 0
    });
    
    const { customerNotes, ...bookingData }: BookingNotification & { customerNotes?: string } = await request.json();
    
    // Prepare the sanitized booking object
    let sanitizedBooking: any;
    
    // Check if we have standardized data from the formatter
    if (bookingData.standardizedData) {
      const std = bookingData.standardizedData;
      
      // Check if this is a new customer (no CRM ID)
      const isNewCustomer = !bookingData.crmCustomerId && !std.crmCustomerId;
      
      // Use standardized data
      sanitizedBooking = {
        // Always use "New Customer" when there's no CRM ID, otherwise use customerLabel or customerName
        customerName: isNewCustomer ? "New Customer" : (std.lineNotification.customerLabel || std.customerName),
        bookingName: std.lineNotification.bookingName,
        email: std.email,
        phoneNumber: std.phoneNumber,
        bookingDate: std.formattedDate,
        bookingStartTime: std.startTime,
        bookingEndTime: std.endTime,
        bayNumber: std.bayName,
        duration: std.duration,
        numberOfPeople: std.numberOfPeople,
        packageInfo: bookingData.packageInfo,
        customerNotes: customerNotes,
        crmCustomerId: bookingData.crmCustomerId || std.crmCustomerId
      };
    } else {
      // Fallback to legacy format for backward compatibility
      sanitizedBooking = {
        // For legacy format, check if we have a CRM ID
        customerName: bookingData.crmCustomerId ? bookingData.customerName : "New Customer",
        bookingName: bookingData.bookingName,
        email: bookingData.email,
        phoneNumber: bookingData.phoneNumber,
        bookingDate: bookingData.bookingDate,
        bookingStartTime: bookingData.bookingStartTime,
        bookingEndTime: bookingData.bookingEndTime,
        bayNumber: bookingData.bayNumber,
        duration: bookingData.duration,
        numberOfPeople: bookingData.numberOfPeople,
        packageInfo: bookingData.packageInfo,
        customerNotes: customerNotes,
        crmCustomerId: bookingData.crmCustomerId
      };
    }
    
    // Format date to "Thu, 6th March" format
    const dateObj = new Date(sanitizedBooking.bookingDate);
    const day = dateObj.getDate();
    const dayWithSuffix = day + (
      day === 1 || day === 21 || day === 31 ? 'st' : 
      day === 2 || day === 22 ? 'nd' : 
      day === 3 || day === 23 ? 'rd' : 'th'
    );
    const formattedDate = dateObj.toLocaleDateString('en-GB', { 
      weekday: 'short', 
      day: 'numeric', 
      month: 'long' 
    }).replace(/\d+/, dayWithSuffix).replace(/(\w+)/, '$1,');

    // Attempt to get bookingId from standardizedData first, then from top-level bookingData
    const bookingId = bookingData.standardizedData?.bookingId || bookingData.bookingId;
    const bookingIdString = bookingId ? ` (ID: ${bookingId})` : '';

    // Generate the notification message with consistent fallbacks
    const fullMessage = `Booking Notification${bookingIdString}
Customer Name: ${sanitizedBooking.customerName}
Booking Name: ${sanitizedBooking.bookingName}
Email: ${sanitizedBooking.email || 'Not provided'}
Phone: ${sanitizedBooking.phoneNumber || 'Not provided'}
Date: ${formattedDate}
Time: ${sanitizedBooking.bookingStartTime} - ${sanitizedBooking.bookingEndTime}
Bay: ${sanitizedBooking.bayNumber}
Type: ${sanitizedBooking.packageInfo || 'Normal Bay Rate'}
People: ${sanitizedBooking.numberOfPeople || '1'}
Channel: Website
${sanitizedBooking.customerNotes ? `\nNotes: ${sanitizedBooking.customerNotes}` : ''}

This booking has been auto-confirmed. No need to re-confirm with the customer. Please double check bay selection`.trim();

    // Use LINE Messaging API instead of LINE Notify
    const channelAccessToken = process.env.LINE_CHANNEL_ACCESS_TOKEN;
    const groupId = process.env.LINE_GROUP_ID;

    if (!channelAccessToken) {
      throw new Error('LINE Messaging API access token is not set');
    }

    if (!groupId) {
      throw new Error('LINE group ID is not set');
    }

    console.log('Sending LINE message to group:', {
      groupId,
      messageLength: fullMessage.length,
      customerName: sanitizedBooking.customerName,
      bookingName: sanitizedBooking.bookingName
    });

    // Send message to LINE group using Messaging API
    const response = await fetch('https://api.line.me/v2/bot/message/push', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${channelAccessToken}`,
      },
      body: JSON.stringify({
        to: groupId,
        messages: [
          {
            type: 'text',
            text: fullMessage
          }
        ]
      }),
    });

    // Handle rate limiting more gracefully
    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      console.error('LINE API error:', errorData || response.statusText);
      return NextResponse.json(
        { error: 'Failed to send LINE notification', details: errorData },
        { status: response.status }
      );
    }

    console.log('LINE notification sent successfully');
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error in LINE notification handler:', error);
    return NextResponse.json(
      { error: 'Failed to send LINE notification' },
      { status: 500 }
    );
  }
} 



==== app\api\notifications\process-review-requests\route.ts (300 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/utils/supabase/server';
import { formatInTimeZone, zonedTimeToUtc, utcToZonedTime } from 'date-fns-tz';
import { subMinutes, addMinutes } from 'date-fns';

const TIMEZONE = 'Asia/Bangkok';
const GOOGLE_REVIEW_URL = 'https://g.page/r/CXwvpW56UsBgEAE/review';
// Use different images for LINE and email (with HTTPS)
const LINE_VOUCHER_IMAGE_URL = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher.png';
const EMAIL_VOUCHER_IMAGE_URL = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher_email.png';

/**
 * This endpoint processes scheduled review requests that are due to be sent.
 * It is designed to be called by a cron job every 5 minutes.
 * 
 * Security: This endpoint requires a secret API key for authentication.
 * 
 * Timezone handling:
 * - Scheduled times are stored in UTC in the database
 * - We use Bangkok timezone (Asia/Bangkok) for business logic
 * - We process requests from a 20-minute window:
 *   - From 10 minutes in the past
 *   - To 10 minutes in the future
 *   This ensures we don't miss any requests due to timing issues.
 */
export async function POST(request: NextRequest) {
  console.log('â­ï¸ Processing review requests - starting...');
  try {
    // 1. Check API key for cron job authentication
    const authHeader = request.headers.get('Authorization');
    const apiKey = process.env.CRON_API_KEY;
    
    if (!apiKey || !authHeader || authHeader !== `Bearer ${apiKey}`) {
      console.error('âŒ Authentication failed - invalid API key:', authHeader?.substring(0, 10) + '...');
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    console.log('âœ… Authentication successful');

    // 2. Get current time and create processing window (Â±10 minutes)
    const now = new Date();
    const bangkokNow = utcToZonedTime(now, TIMEZONE);
    const tenMinutesAgo = subMinutes(bangkokNow, 10);
    const tenMinutesAhead = addMinutes(bangkokNow, 10);
    
    // Convert times to UTC ISO strings for database comparison
    const tenMinutesAgoUtc = zonedTimeToUtc(tenMinutesAgo, TIMEZONE).toISOString();
    const tenMinutesAheadUtc = zonedTimeToUtc(tenMinutesAhead, TIMEZONE).toISOString();
    
    // Format for readable logging (both Thai and UTC time)
    const currentTimeStr = formatInTimeZone(now, TIMEZONE, "yyyy-MM-dd'T'HH:mm:ssxxx");
    const windowStartThai = formatInTimeZone(tenMinutesAgo, TIMEZONE, "yyyy-MM-dd HH:mm:ss");
    const windowEndThai = formatInTimeZone(tenMinutesAhead, TIMEZONE, "yyyy-MM-dd HH:mm:ss");
    
    console.log(`ðŸ“… Current time (Bangkok): ${currentTimeStr}`);
    console.log(`ðŸ“… Processing window (Thai): ${windowStartThai} to ${windowEndThai}`);
    console.log(`ðŸ“… Processing window (UTC): ${tenMinutesAgoUtc} to ${tenMinutesAheadUtc}`);

    // 2.5 Get total count of pending review requests for monitoring
    const supabase = createServerClient();
    console.log('ðŸ“Š Checking total pending review requests...');
    const { count: totalPendingCount, error: countError } = await supabase
      .from('scheduled_review_requests')
      .select('*', { count: 'exact', head: true })
      .eq('sent', false);
    
    if (countError) {
      console.error('âš ï¸ Error counting total pending requests:', countError);
    } else {
      console.log(`ðŸ“ˆ Total pending review requests in system: ${totalPendingCount}`);
    }

    // 3. Get pending review requests within the processing window (Â±10 minutes from now)
    console.log('ðŸ” Fetching pending review requests in the processing window...');
    const { data: pendingRequests, error: fetchError } = await supabase
      .from('scheduled_review_requests')
      .select('*')  // Don't try to join with bookings table
      .eq('sent', false)
      .gte('scheduled_time', tenMinutesAgoUtc)   // Not older than 10 minutes
      .lte('scheduled_time', tenMinutesAheadUtc) // Not more than 10 minutes in future
      .order('scheduled_time', { ascending: true })
      .limit(10); // Process in batches to avoid timeout

    if (fetchError) {
      console.error('âŒ Error fetching pending review requests:', fetchError);
      return NextResponse.json(
        { error: 'Failed to fetch pending review requests', details: fetchError },
        { status: 500 }
      );
    }

    if (!pendingRequests || pendingRequests.length === 0) {
      console.log('â„¹ï¸ No pending review requests found in the processing window');
      return NextResponse.json({ 
        message: 'No pending review requests in the processing window',
        processingWindow: {
          from: tenMinutesAgoUtc,
          to: tenMinutesAheadUtc,
          fromThai: windowStartThai,
          toThai: windowEndThai
        },
        totalPending: totalPendingCount || 0
      });
    }

    console.log(`ðŸ”” Found ${pendingRequests.length} pending review requests to process in this batch (of ${totalPendingCount} total)`);
    console.log('ðŸ“„ Requests:', JSON.stringify(pendingRequests, null, 2));

    // For testing purposes, process all requests without checking booking status
    const validRequests = pendingRequests;
    
    if (validRequests.length === 0) {
      console.log('â„¹ï¸ No valid review requests to process');
      return NextResponse.json({ message: 'No valid review requests to process' });
    }

    // 4. Process each valid request
    // For local development, we need to make sure we're using the right URL
    // In production, NEXT_PUBLIC_APP_URL should be set correctly
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 
                   (request.url ? new URL(request.url).origin : 'http://localhost:3000');
    
    console.log(`ðŸŒ Using base URL: ${baseUrl}`);
    
    // Use the predefined voucher image URL or override with env var if provided
    const voucherImageUrl = process.env.REVIEW_VOUCHER_IMAGE_URL || LINE_VOUCHER_IMAGE_URL;
    console.log(`ðŸ–¼ï¸ Using voucher image URL: ${voucherImageUrl}`);
    
    const results = await Promise.all(
      validRequests.map(async (request) => {
        console.log(`â³ Processing request ID ${request.id} for ${request.provider}: ${request.contact_info}`);
        try {
          // Look up the booking and customer information
          const { data: bookingData, error: bookingError } = await supabase
            .from('bookings')
            .select('id, name, email, user_id')
            .eq('id', request.booking_id)
            .single();
          
          if (bookingError) {
            console.error(`âŒ Error retrieving booking ${request.booking_id}:`, bookingError);
            throw new Error(`Failed to retrieve booking: ${bookingError.message}`);
          }
          
          // Try to get customer name from CRM if possible
          let customerName = bookingData.name; // Default to booking name
          
          // Check if there's a CRM mapping for this user
          if (bookingData.user_id) {
            const { data: crmMapping, error: crmError } = await supabase
              .from('crm_customer_mapping')
              .select('crm_customer_data')
              .eq('profile_id', bookingData.user_id)
              .eq('is_matched', true)
              .order('match_confidence', { ascending: false })
              .maybeSingle();
            
            if (!crmError && crmMapping?.crm_customer_data?.name) {
              // Use customer name from CRM if available
              customerName = crmMapping.crm_customer_data.name;
              console.log(`â„¹ï¸ Using CRM customer name: ${customerName}`);
            }
          }
          
          // Send review request based on provider
          if (request.provider === 'line') {
            // Send LINE notification
            console.log(`ðŸ“± Sending LINE notification to ${request.contact_info}`);
            const lineEndpoint = `${baseUrl}/api/notifications/line/review-request`;
            console.log(`ðŸ”— LINE endpoint: ${lineEndpoint}`);
            
            // For LINE, use provider_id instead of user_id/contact_info
            // and use the LINE-specific voucher image
            const lineVoucherUrl = process.env.LINE_VOUCHER_IMAGE_URL || LINE_VOUCHER_IMAGE_URL;
            console.log(`ðŸ–¼ï¸ Using LINE voucher image: ${lineVoucherUrl}`);
            
            const lineResponse = await fetch(lineEndpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                userId: request.contact_info, // This is actually the LINE provider_id
                bookingName: bookingData.name,
                customerName: customerName, // Use actual customer name
                reviewUrl: GOOGLE_REVIEW_URL,
                voucherImageUrl: lineVoucherUrl
              })
            });

            const lineResponseText = await lineResponse.text();
            console.log(`ðŸ“¤ LINE API response: ${lineResponse.status} ${lineResponseText}`);

            if (!lineResponse.ok) {
              throw new Error(`LINE notification failed: ${lineResponse.status} ${lineResponse.statusText} - ${lineResponseText}`);
            }
          } else {
            // Send email notification
            console.log(`ðŸ“§ Sending email notification to ${request.contact_info}`);
            const emailEndpoint = `${baseUrl}/api/notifications/email/review-request`;
            console.log(`ðŸ”— Email endpoint: ${emailEndpoint}`);
            
            // Use the email-specific voucher image
            const emailVoucherUrl = process.env.EMAIL_VOUCHER_IMAGE_URL || EMAIL_VOUCHER_IMAGE_URL;
            console.log(`ðŸ–¼ï¸ Using email voucher image: ${emailVoucherUrl}`);
            
            const emailResponse = await fetch(emailEndpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                email: request.contact_info,
                userName: customerName, // Use actual customer name
                bookingName: bookingData.name,
                reviewUrl: GOOGLE_REVIEW_URL,
                voucherImageUrl: emailVoucherUrl
              })
            });

            const emailResponseText = await emailResponse.text();
            console.log(`ðŸ“¤ Email API response: ${emailResponse.status} ${emailResponseText}`);

            if (!emailResponse.ok) {
              throw new Error(`Email notification failed: ${emailResponse.status} ${emailResponse.statusText} - ${emailResponseText}`);
            }
          }

          // Mark request as sent
          console.log(`âœï¸ Marking request ${request.id} as sent`);
          const { data: updateData, error: updateError } = await supabase
            .from('scheduled_review_requests')
            .update({ sent: true })
            .eq('id', request.id)
            .select()
            .single();

          if (updateError) {
            console.error(`âŒ Failed to update request status for ${request.id}:`, updateError);
            throw new Error(`Failed to update request status: ${updateError.message}`);
          }

          console.log(`âœ… Successfully processed request ${request.id}`);
          return {
            id: request.id,
            provider: request.provider,
            contact_info: request.contact_info,
            status: 'sent',
            success: true
          };
        } catch (error) {
          console.error(`âŒ Error processing review request ${request.id}:`, error);
          return {
            id: request.id,
            provider: request.provider,
            contact_info: request.contact_info,
            status: 'error',
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error'
          };
        }
      })
    );

    // 5. Return results
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;

    console.log(`ðŸ Processing complete: ${successful} successful, ${failed} failed`);
    
    // 6. Log remaining pending requests after processing
    const { count: remainingCount, error: remainingError } = await supabase
      .from('scheduled_review_requests')
      .select('*', { count: 'exact', head: true })
      .eq('sent', false);
      
    if (!remainingError) {
      console.log(`ðŸ“‰ Remaining pending review requests: ${remainingCount}`);
    }
    
    return NextResponse.json({
      processed: results.length,
      successful,
      failed,
      totalPending: totalPendingCount,
      remainingPending: remainingCount || 0,
      processingWindow: {
        from: tenMinutesAgoUtc,
        to: tenMinutesAheadUtc,
        fromThai: windowStartThai,
        toThai: windowEndThai
      },
      results
    });
  } catch (error) {
    console.error('âŒ Exception in processing review requests:', error);
    return NextResponse.json(
      { error: 'An error occurred while processing review requests', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
} 



==== app\api\notifications\schedule-review-request\route.ts (75 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { getToken } from 'next-auth/jwt';
import { createServerClient } from '@/utils/supabase/server';
import { parse, addMinutes } from 'date-fns';
import { zonedTimeToUtc, formatInTimeZone } from 'date-fns-tz';

const TIMEZONE = 'Asia/Bangkok';

interface ScheduleReviewRequestBody {
  bookingId: string;
  userId: string;
  scheduledTime: string;
  provider: 'line' | 'email';
  contactInfo: string;
}

export async function POST(request: NextRequest) {
  try {
    // 1. Authenticate user
    const token = await getToken({ req: request as any });
    if (!token?.sub) {
      return NextResponse.json(
        { error: 'Unauthorized or session expired' },
        { status: 401 }
      );
    }

    // 2. Parse request body
    const body: ScheduleReviewRequestBody = await request.json();
    const { bookingId, userId, scheduledTime, provider, contactInfo } = body;

    // 3. Validate required fields
    if (!bookingId || !userId || !scheduledTime || !provider || !contactInfo) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // 4. Create scheduled review request in database
    const supabase = createServerClient();
    const { data, error } = await supabase
      .from('scheduled_review_requests')
      .insert({
        booking_id: bookingId,
        user_id: userId,
        scheduled_time: scheduledTime,
        provider,
        contact_info: contactInfo,
        sent: false
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating scheduled review request:', error);
      return NextResponse.json(
        { error: 'Failed to schedule review request' },
        { status: 500 }
      );
    }

    // 5. Return success response
    return NextResponse.json({
      success: true,
      scheduledReviewRequest: data
    });
  } catch (error) {
    console.error('Exception in scheduling review request:', error);
    return NextResponse.json(
      { error: 'An error occurred while scheduling the review request' },
      { status: 500 }
    );
  }
} 



==== app\api\notifications\send-review-request\route.ts (85 lines) ====

import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@/utils/supabase/server';

const GOOGLE_REVIEW_URL = 'https://g.page/r/CXwvpW56UsBgEAE/review';
const VOUCHER_IMAGE_URL = process.env.REVIEW_VOUCHER_IMAGE_URL || 'https://www.len.golf/wp-content/uploads/2024/06/Logo.png';

interface SendReviewRequestBody {
  bookingId: string;
  userId: string;
  provider: 'line' | 'email';
  contactInfo: string;
}

/**
 * This endpoint handles sending a single review request.
 * It's designed to be called by Upstash QStash after the scheduled delay.
 */
export async function POST(request: NextRequest) {
  try {
    // 1. Authentication
    const authHeader = request.headers.get('Authorization');
    const apiKey = process.env.QSTASH_API_KEY || process.env.CRON_API_KEY;
    
    // Verify either QStash signature or API key
    const qStashSignature = request.headers.get('Upstash-Signature');
    const isFromQStash = !!qStashSignature; // In a real implementation, verify this signature
    
    if (!isFromQStash && (!apiKey || !authHeader || authHeader !== `Bearer ${apiKey}`)) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Parse request body
    const body: SendReviewRequestBody = await request.json();
    const { bookingId, userId, provider, contactInfo } = body;

    // For testing, we'll skip booking validation
    // and use hardcoded values instead
    const bookingName = "Test User";

    // 4. Send review request
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    if (provider === 'line') {
      // Send LINE notification
      await fetch(`${baseUrl}/api/notifications/line/review-request`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: contactInfo,
          bookingName: bookingName,
          reviewUrl: GOOGLE_REVIEW_URL,
          voucherImageUrl: VOUCHER_IMAGE_URL
        })
      });
    } else {
      // Send email notification
      await fetch(`${baseUrl}/api/notifications/email/review-request`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: contactInfo,
          userName: bookingName,
          reviewUrl: GOOGLE_REVIEW_URL,
          voucherImageUrl: VOUCHER_IMAGE_URL
        })
      });
    }

    // 5. Return success response
    return NextResponse.json({
      success: true,
      message: `Review request sent via ${provider} to ${contactInfo}`,
      booking: bookingId
    });
  } catch (error) {
    console.error('Exception in sending review request:', error);
    return NextResponse.json(
      { error: 'An error occurred while sending the review request' },
      { status: 500 }
    );
  }
} 



==== app\auth\error\page.tsx (73 lines) ====

'use client';

import { useSearchParams } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';

export default function ErrorPage() {
  const searchParams = useSearchParams();
  const error = searchParams?.get('error') || '';

  const getErrorMessage = (error: string) => {
    switch (error) {
      case 'AccessDenied':
        return 'Access denied. Please make sure you have granted all required permissions.';
      case 'Configuration':
        return 'There is a problem with the server configuration.';
      case 'Verification':
        return 'The verification link may have expired or has already been used.';
      case 'OAuthSignin':
        return 'Error occurred while signing in with the provider.';
      case 'OAuthCallback':
        return 'Error occurred while processing the authentication callback.';
      case 'OAuthCreateAccount':
        return 'Could not create user account.';
      case 'EmailCreateAccount':
        return 'Could not create user account with email.';
      case 'Callback':
        return 'Error occurred during the authentication callback.';
      default:
        return 'An unexpected error occurred. Please try again.';
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center px-4">
      <div className="w-full max-w-md space-y-8 text-center">
        <div className="flex flex-col items-center">
          <div className="relative w-[180px] h-[60px] mb-8">
            <Image
              src="/images/logo_v1.png"
              alt="LENGOLF Logo"
              fill
              priority
              sizes="180px"
              className="object-contain"
            />
          </div>
          <h2 className="mt-6 text-2xl font-bold text-gray-900">
            Authentication Error
          </h2>
          <p className="mt-2 text-sm text-gray-600">
            {error ? getErrorMessage(error) : 'An error occurred during authentication'}
          </p>
        </div>

        <div className="mt-8 space-y-4">
          <Link
            href="/auth/login"
            className="w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
          >
            Try Again
          </Link>
          <Link
            href="/"
            className="w-full flex justify-center py-3 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
          >
            Back to Home
          </Link>
        </div>
      </div>
    </div>
  );
} 



==== app\error.tsx (13 lines) ====

'use client';

import ErrorPage from '@/components/shared/ErrorPage';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return <ErrorPage error={error} reset={reset} />;
} 



==== app\globals.css (99 lines) ====

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary-color: #005a32;
  --neutral-color: #000000;
  --accent-color: #ffffff;
  --background-color: #f0f0f0;
  --foreground-color: #171717;
  --footer-bg-color: #f5fef9;
  --footer-heading-color: #2b6f36;
  --footer-text-color: #9fa4a5;
}

body {
  @apply min-h-screen bg-gray-50;
  font-feature-settings: "rlig" 1, "calt" 1;
}

@layer base {
  body {
    @apply bg-background text-foreground;
  }
}

/* Custom styles for react-phone-number-input */
.custom-phone-input {
  /* Add overall left padding to the main wrapper */
  padding-left: 0.75rem; /* px-3 */
  /* Ensure other paddings (top, bottom, right) on the wrapper are as intended or from Tailwind classes */
  /* For example, if your other inputs have py-2, the PhoneInput wrapper also needs it if not handled by TW classes */
}

.custom-phone-input .PhoneInputInput {
  /* Match padding of other inputs, but left padding is now handled by the wrapper */
  padding-top: 0.5rem; /* py-2 */
  padding-bottom: 0.5rem; /* py-2 */
  padding-left: 0; /* Left padding is now on .custom-phone-input wrapper */
  padding-right: 0.75rem; /* px-3 for the right side of the text input */

  /* Ensure it takes full width within its container */
  width: 100%;

  /* Remove default browser focus outline if wrapper handles focus */
  outline: none;

  /* Remove default border if wrapper handles border */
  border: none;

  /* Ensure the input field itself doesn't have a conflicting background if the wrapper sets one */
  background-color: transparent;
  
  /* Inherit font properties */
  font-size: inherit;
  line-height: inherit;
}

.custom-phone-input .PhoneInputCountry {
  /* Align country select with the input part */
  /* display: flex; Remove this as it might not be needed and can alter layout */
  /* align-items: center; Remove this as it might not be needed */
}

.custom-phone-input .PhoneInputCountrySelect {
  display: flex;
  align-items: center;
  /* Remove padding-left from here as it's now on the main wrapper */
  /* padding-left: 0.75rem; */ 
  /* You might want to adjust other padding here if the clickable area is too small/large,
     but primarily this is for centering the flag icon. */
  /* padding-right: 0.25rem; */ /* Example right padding for the selector itself */
}

.custom-phone-input .PhoneInputCountryIcon {
  /* This ensures the flag is treated as a block-level element within the flex container,
     which can help with consistent alignment. Adjust margin as needed. */
  display: block; 
  margin-right: 0.375rem; /* approx 6px, adjust for spacing between flag and the +66 text */
  /* If flags appear too large or small, you can constrain them, e.g.: */
  /* max-height: 1.2em; */
  /* max-width: 1.8em; */
}

/* Adjust height of the input to match others if padding isn't enough */
/* For example, if other inputs are h-10 (2.5rem) and py-2 (0.5rem padding top/bottom) */
/* The input field content area is 1.5rem. Check computed height of other inputs. */
/* .custom-phone-input .PhoneInputInput,
.custom-phone-input .PhoneInputCountrySelect {
  height: 2.5rem; /* Example: Adjust to match computed height of other inputs */
/*   box-sizing: border-box;
} */

/* Ensure the flag icon is reasonably sized if needed */
/* .custom-phone-input .PhoneInputCountryIcon {
  width: 1.5em; 
  height: 1.5em;
} */




==== app\layout.tsx (226 lines) ====

import type { Metadata, Viewport } from "next";
import { Poppins } from "next/font/google";
import "./globals.css";
import { Providers } from "./providers";
import Script from 'next/script';

const poppins = Poppins({
  subsets: ['latin'],
  weight: ['400', '500', '600', '700'],
  variable: '--font-poppins',
  display: 'swap',
});

export const viewport: Viewport = {
  width: 'device-width',
  initialScale: 1,
  maximumScale: 5,
};

export const metadata: Metadata = {
  title: {
    default: "LENGOLF - Indoor Golf Simulator in Bangkok | Book Your Bay",
    template: "%s | LENGOLF Bangkok"
  },
  description: "Experience Bangkok's premier indoor golf simulator at LENGOLF. Located at Mercury Ville @ BTS Chidlom. State-of-the-art Korean simulators, professional coaching, and great food & drinks. Book your bay now!",
  keywords: [
    "golf simulator bangkok",
    "indoor golf bangkok",
    "golf practice bangkok",
    "golf lessons bangkok",
    "lengolf",
    "mercury ville golf",
    "chidlom golf",
    "golf booking bangkok",
    "korean golf simulator",
    "golf training bangkok"
  ],
  authors: [{ name: "LENGOLF" }],
  creator: "LENGOLF",
  publisher: "LENGOLF",
  formatDetection: {
    email: false,
    address: false,
    telephone: false,
  },
  metadataBase: new URL('https://booking.len.golf'),
  alternates: {
    canonical: '/',
  },
  openGraph: {
    title: "LENGOLF - Bangkok's Premier Indoor Golf Simulator Experience",
    description: "Experience Bangkok's top-rated indoor golf simulator in the heart of the city! Located at Mercury Ville @ BTS Chidlom, LENGOLF offers state-of-the-art Korean simulators in a fun, relaxed environment. Perfect for all skill levels with great food & drinks. Book your bay now! ðŸŒï¸â€â™‚ï¸âœ¨",
    url: 'https://booking.len.golf',
    siteName: 'LENGOLF Bangkok',
    images: [
      {
        url: 'https://booking.len.golf/images/lengolf.jpg',
        width: 1200,
        height: 630,
        alt: 'LENGOLF Indoor Golf Simulator Facility',
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  twitter: {
    card: 'summary_large_image',
    title: 'LENGOLF - Indoor Golf Simulator in Bangkok',
    description: 'Book your golf simulator bay at LENGOLF Bangkok. Perfect for practice, lessons, or fun with friends. Located at Mercury Ville @ BTS Chidlom.',
    images: ['https://booking.len.golf/images/lengolf.jpg'],
  },
  category: 'sports',
  icons: {
    icon: [
      { url: '/favicon.ico' },
      { url: '/favicon.svg', type: 'image/svg+xml' },
      { url: '/favicon-96x96.png', sizes: '96x96', type: 'image/png' },
    ],
    apple: [
      { url: '/apple-touch-icon.png', sizes: '180x180', type: 'image/png' },
    ],
    other: [
      { url: '/web-app-manifest-192x192.png', sizes: '192x192', type: 'image/png', rel: 'icon' },
      { url: '/web-app-manifest-512x512.png', sizes: '512x512', type: 'image/png', rel: 'icon' },
    ],
  },
  manifest: '/site.webmanifest',
  verification: {
    google: 'your-google-site-verification', // You'll need to add your actual verification code
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${poppins.variable} font-sans`}>
      <head>
        {/* Google Tag Manager */}
        <Script id="google-tag-manager" strategy="afterInteractive">
          {`
            // Safety check for TikTok Pixel
            window.ttq = window.ttq || { 
              track: function() {}, 
              page: function() {},
              batch: function() {}
            };
            
            (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
            new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
            })(window,document,'script','dataLayer','GTM-MKCHVJKW');

            // Initialize dataLayer
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'GTM-MKCHVJKW', {
              linker: {
                domains: ['len.golf'],
                decorate_forms: false
              }
            });
          `}
        </Script>

        {/* JSON-LD Structured Data */}
        <Script
          id="structured-data"
          type="application/ld+json"
          dangerouslySetInnerHTML={{
            __html: JSON.stringify({
              '@context': 'https://schema.org',
              '@type': 'SportsActivityLocation',
              name: 'LENGOLF Bangkok',
              description: 'Premier indoor golf simulator facility in Bangkok with state-of-the-art Korean simulators, professional coaching, and great amenities.',
              url: 'https://booking.len.golf',
              telephone: '+66966682335',
              address: {
                '@type': 'PostalAddress',
                streetAddress: 'The Mercury Ville @ BTS Chidlom, Floor 4',
                addressLocality: 'Bangkok',
                addressRegion: 'Bangkok',
                postalCode: '10330',
                addressCountry: 'TH'
              },
              geo: {
                '@type': 'GeoCoordinates',
                latitude: '13.7445',
                longitude: '100.5431'
              },
              openingHoursSpecification: {
                '@type': 'OpeningHoursSpecification',
                dayOfWeek: [
                  'Monday',
                  'Tuesday',
                  'Wednesday',
                  'Thursday',
                  'Friday',
                  'Saturday',
                  'Sunday'
                ],
                opens: '10:00',
                closes: '23:00'
              },
              priceRange: 'à¸¿à¸¿à¸¿',
              amenityFeature: [
                {
                  '@type': 'LocationFeatureSpecification',
                  name: 'Golf Simulators',
                  value: true
                },
                {
                  '@type': 'LocationFeatureSpecification',
                  name: 'Professional Coaching',
                  value: true
                },
                {
                  '@type': 'LocationFeatureSpecification',
                  name: 'Equipment Rental',
                  value: true
                }
              ]
            })
          }}
        />
        <link 
          rel="stylesheet" 
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" 
          integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" 
          crossOrigin="anonymous" 
          referrerPolicy="no-referrer" 
        />
      </head>
      <body>
        {/* Google Tag Manager (noscript) */}
        <noscript>
          <iframe
            src="https://www.googletagmanager.com/ns.html?id=GTM-MKCHVJKW"
            height="0"
            width="0"
            style={{ display: 'none', visibility: 'hidden' }}
          />
        </noscript>
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}




==== app\loading.tsx (5 lines) ====

import LoadingPage from '@/components/shared/LoadingPage';

export default function Loading() {
  return <LoadingPage />;
} 



==== app\not-found.tsx (5 lines) ====

import NotFoundPage from '@/components/shared/NotFoundPage';

export default function NotFound() {
  return <NotFoundPage />;
} 



==== app\page.tsx (4 lines) ====

export default function RootPage() {
  return null;
}




==== app\providers.tsx (14 lines) ====

'use client';

import { SessionProvider } from 'next-auth/react';
// import { GtmUserProfileProvider } from '@/components/providers/GtmUserProfileProvider';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <SessionProvider>
      {/* <GtmUserProfileProvider> */}
        {children}
      {/* </GtmUserProfileProvider> */}
    </SessionProvider>
  );
} 



==== components\icons\index.tsx (44 lines) ====

import { SVGProps } from 'react'

interface IconProps extends SVGProps<SVGSVGElement> {
  className?: string;
}

export function Logo() {
  return (
    <svg width="200" height="100" viewBox="0 0 200 100" fill="none" xmlns="http://www.w3.org/2000/svg">
      <text x="50%" y="50%" dominantBaseline="middle" textAnchor="middle" fontSize="24" fill="#005a32" fontWeight="bold">
        LENGOLF
      </text>
    </svg>
  );
}

export function GoogleIcon() {
  return (
    <svg className="h-5 w-5 mr-2" viewBox="0 0 48 48">
      <path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"/>
      <path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"/>
      <path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z"/>
      <path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z"/>
    </svg>
  );
}

export const FacebookIcon = ({ className, ...props }: IconProps) => (
  <svg viewBox="0 0 24 24" fill="currentColor" {...props} className={className}>
    <path d="M9.198 21.5h4v-8.01h3.604l.396-3.98h-4V7.5a1 1 0 011-1h3v-4h-3a5 5 0 00-5 5v2.01h-2l-.396 3.98h2.396v8.01z" />
  </svg>
)

export const LineIcon = ({ className, ...props }: IconProps) => (
  <svg viewBox="0 0 24 24" fill="currentColor" {...props} className={className}>
    <path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.346 0 .627.285.627.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346 0 .628.285.628.63v4.771zm-2.466 0c0 .344-.281.629-.627.629H4.29c-.346 0-.63-.285-.63-.629V8.108c0-.345.284-.63.63-.63h2.386c.346 0 .627.285.627.63v4.771zM10.102 12.5a.63.63 0 01-.631.629H7.089a.631.631 0 01-.631-.629V8.108c0-.345.285-.63.631-.63h2.382a.63.63 0 01.631.63V12.5z"/>
  </svg>
)

export const UserIcon = ({ className, ...props }: IconProps) => (
  <svg viewBox="0 0 24 24" fill="currentColor" {...props} className={className}>
    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z" />
  </svg>
) 



==== components\providers\GtmUserProfileProvider.tsx (90 lines) ====

'use client';

import { useSession } from 'next-auth/react';
import { useEffect, useState } from 'react';
import { createClient } from '@/utils/supabase/client';
import { pushProfileDataToGtm } from '@/utils/gtm';

export interface UserProfileData {
  profileId: string | null;
  stableHashId: string | null;
}

/**
 * Provider that pushes user profile data to the Google Tag Manager data layer
 * This makes profileId and stableHashId available for all GTM tracking
 */
export function GtmUserProfileProvider({ children }: { children: React.ReactNode }) {
  const { data: session, status } = useSession();
  const [profileData, setProfileData] = useState<UserProfileData>({
    profileId: null,
    stableHashId: null,
  });

  // Fetch user profile data and push to GTM data layer
  useEffect(() => {
    // Only run if user is authenticated and we have their ID
    if (status === 'authenticated' && session?.user?.id) {
      const fetchProfileData = async () => {
        try {
          const supabase = createClient();
          const userId = session.user.id;

          // Get profile data directly
          const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('id')
            .eq('id', userId)
            .single();

          if (profileError) {
            console.error('Error fetching profile data:', profileError);
            return;
          }

          // Get CRM mapping to find stable hash ID
          const { data: crmMappings, error: crmError } = await supabase
            .from('crm_customer_mapping')
            .select('stable_hash_id, crm_customer_id, match_confidence, updated_at')
            .eq('profile_id', userId)
            .eq('is_matched', true)
            .order('match_confidence', { ascending: false }) // Highest confidence first
            .order('updated_at', { ascending: false }); // Most recent first

          if (crmError) {
            console.error('Error fetching CRM mappings:', crmError);
          }

          // Use the best mapping (first in sorted list)
          const bestMapping = crmMappings && crmMappings.length > 0 ? crmMappings[0] : null;
          
          if (crmMappings && crmMappings.length > 1) {
            console.warn(`Multiple CRM mappings found (${crmMappings.length}), using highest confidence one`);
          }

          // Set profile data for GTM
          const userData = {
            profileId: userId,
            stableHashId: bestMapping?.stable_hash_id || null,
            customerID: bestMapping?.crm_customer_id || null // For backward compatibility
          };

          // Update state
          setProfileData({
            profileId: userData.profileId,
            stableHashId: userData.stableHashId
          });

          // Push to GTM data layer
          pushProfileDataToGtm(userData);
        } catch (error) {
          console.error('Error in GTM profile data provider:', error);
        }
      };

      fetchProfileData();
    }
  }, [session?.user?.id, status]);

  return <>{children}</>;
} 



==== components\shared\ErrorPage.tsx (43 lines) ====

'use client';

import { useEffect } from 'react';
import Link from 'next/link';

export default function ErrorPage({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error(error);
  }, [error]);

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-4">
      <div className="text-center">
        <h2 className="mb-4 text-2xl font-bold text-gray-900">
          Something went wrong!
        </h2>
        <p className="mb-8 text-gray-600">
          {error.message || 'An unexpected error occurred'}
        </p>
        <div className="space-x-4">
          <button
            onClick={reset}
            className="inline-block rounded-lg bg-green-700 px-6 py-2 text-sm font-semibold text-white transition-colors hover:bg-green-800"
          >
            Try again
          </button>
          <Link
            href="/"
            className="inline-block rounded-lg bg-gray-100 px-6 py-2 text-sm font-semibold text-gray-700 transition-colors hover:bg-gray-200"
          >
            Go home
          </Link>
        </div>
      </div>
    </main>
  );
} 



==== components\shared\LoadingPage.tsx (10 lines) ====

export default function LoadingPage() {
  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <h2 className="text-2xl font-semibold text-gray-900">Loading...</h2>
        <p className="mt-2 text-gray-600">Please wait while we load your content.</p>
      </div>
    </div>
  );
} 



==== components\shared\NotFoundPage.tsx (18 lines) ====

import Link from 'next/link';

export default function NotFoundPage() {
  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <h2 className="text-2xl font-semibold text-gray-900">Page Not Found</h2>
        <p className="mt-2 text-gray-600">The page you're looking for doesn't exist.</p>
        <Link
          href="/"
          className="mt-4 inline-block rounded-lg bg-green-700 px-6 py-2 text-sm font-semibold text-white transition-colors hover:bg-green-800"
        >
          Go Home
        </Link>
      </div>
    </div>
  );
} 



==== components\shared\PageTransition.tsx (19 lines) ====

'use client';

import { motion } from 'framer-motion';

export function PageTransition({ children }: { children: React.ReactNode }) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0 }}
      transition={{ 
        duration: 0.2,
        ease: 'easeOut'
      }}
    >
      {children}
    </motion.div>
  );
} 



==== components\ui\Button.tsx (40 lines) ====

'use client';

import { ButtonHTMLAttributes } from 'react';
import { twMerge } from 'tailwind-merge';

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'outline' | 'google' | 'facebook' | 'line' | 'guest';
  isLoading?: boolean;
}

export function Button({
  children,
  className,
  variant = 'primary',
  isLoading = false,
  disabled,
  ...props
}: ButtonProps) {
  const baseStyles = 'w-full rounded-md px-4 py-2.5 text-center text-sm font-medium shadow-sm disabled:opacity-50 transition-colors';
  
  const variants = {
    primary: 'bg-green-700 text-white hover:bg-green-800',
    secondary: 'bg-gray-600 text-white hover:bg-gray-700',
    outline: 'bg-white text-gray-700 ring-1 ring-inset ring-gray-300 hover:bg-gray-50',
    google: 'bg-white text-gray-700 ring-1 ring-inset ring-gray-300 hover:bg-gray-50',
    facebook: 'bg-[#1877F2] text-white hover:bg-[#166FE5]',
    line: 'bg-[#00B900] text-white hover:bg-[#00A000]',
    guest: 'bg-gray-600 text-white hover:bg-gray-700',
  };

  return (
    <button
      className={twMerge(baseStyles, variants[variant], className)}
      disabled={isLoading || disabled}
      {...props}
    >
      {isLoading ? 'Please wait...' : children}
    </button>
  );
} 



==== jest.config.js (20 lines) ====

const nextJest = require('next/jest')

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
})

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  modulePathIgnorePatterns: ['.next'],
  testPathIgnorePatterns: ['<rootDir>/.next/', '<rootDir>/node_modules/']
}

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig) 



==== jest.setup.js (124 lines) ====

import '@testing-library/jest-dom' 

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    prefetch: jest.fn(),
  }),
  useSearchParams: () => ({
    get: jest.fn(),
  }),
}));

// Mock cache functions
jest.mock('@/lib/cache', () => ({
  calendarCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
  authCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
  getCacheKey: {
    auth: jest.fn(),
    calendar: jest.fn(),
  },
  updateCalendarCache: jest.fn(),
}));

// Mock debug functions
jest.mock('@/lib/debug', () => ({
  debug: {
    log: jest.fn(),
  },
}));

// Mock web APIs
if (typeof global.Request === 'undefined') {
  global.Request = class MockRequest {
    constructor(input, init) {
      this.input = input;
      this.init = init;
      this.method = init?.method || 'GET';
      this.body = init?.body;
    }

    async json() {
      return JSON.parse(this.body);
    }
  };
}

if (typeof global.Response === 'undefined') {
  global.Response = class MockResponse {
    constructor(body, init = {}) {
      this._body = body;
      this.status = init.status || 200;
      this.ok = this.status >= 200 && this.status < 300;
      this.headers = new Headers(init.headers);
    }

    async json() {
      return JSON.parse(this._body);
    }

    get body() {
      return this._body;
    }
  };
}

// Mock NextResponse
jest.mock('next/server', () => {
  return {
    NextResponse: {
      json: (data, init) => {
        const jsonStr = JSON.stringify(data);
        const response = new Response(jsonStr, init);
        Object.defineProperty(response, 'json', {
          value: async () => data
        });
        return response;
      },
    },
  };
});

// Mock performance API
if (typeof global.performance === 'undefined') {
  global.performance = {
    now: () => Date.now(),
  };
}

// Mock Headers API
if (typeof global.Headers === 'undefined') {
  global.Headers = class MockHeaders {
    constructor(init = {}) {
      this._headers = new Map();
      Object.entries(init).forEach(([key, value]) => {
        this._headers.set(key.toLowerCase(), value);
      });
    }

    get(key) {
      return this._headers.get(key.toLowerCase()) || null;
    }

    set(key, value) {
      this._headers.set(key.toLowerCase(), value);
    }
  };
}

// Mock URL API
if (typeof global.URL === 'undefined') {
  global.URL = class MockURL {
    constructor(url) {
      this.href = url;
    }
  };
} 



==== lib\bayConfig.ts (13 lines) ====

export type BayName = "Bay 1 (Bar)" | "Bay 2" | "Bay 3 (Entrance)";

export const BAY_DISPLAY_NAMES: Record<string, BayName> = {
  "Bay 1": "Bay 1 (Bar)",
  "Bay 2": "Bay 2",
  "Bay 3": "Bay 3 (Entrance)"
};

export const BAY_COLORS: Record<BayName, string> = {
  "Bay 1 (Bar)": "7",    // Purple/violet color
  "Bay 2": "6",          // Orange/coral color
  "Bay 3 (Entrance)": "4" // Green color
}; 



==== lib\bookingCalendarConfig.ts (18 lines) ====

export const BOOKING_CALENDARS = {
  'Bay 1': process.env.BOOKING_CALENDAR_BAY1_ID!,
  'Bay 2': process.env.BOOKING_CALENDAR_BAY2_ID!,
  'Bay 3': process.env.BOOKING_CALENDAR_BAY3_ID!,
} as const;

// Validate required environment variables
const missingVars = Object.entries(BOOKING_CALENDARS).filter(([_, value]) => !value);

if (missingVars.length > 0) {
  throw new Error(
    `Missing required environment variables for booking calendars: ${missingVars
      .map(([key]) => `BOOKING_CALENDAR_${key.replace(' ', '')}_ID`)
      .join(', ')}`
  );
}

export type BookingBay = keyof typeof BOOKING_CALENDARS; 



==== lib\cache.ts (82 lines) ====

import NodeCache from 'node-cache';
import { calendar, AVAILABILITY_CALENDARS } from '@/lib/googleApiConfig';
import { format, addDays, setHours, setMinutes, setSeconds } from 'date-fns';

// Cache instances
export const calendarCache = new NodeCache({
  stdTTL: 300, // 5 minutes
  checkperiod: 60, // Check for expired entries every minute
});

export const authCache = new NodeCache({
  stdTTL: 60, // 1 minute
  checkperiod: 30, // Check for expired entries every 30 seconds
});

// Cache keys
export const getCacheKey = {
  calendar: (date: string) => `calendar_${date}`,
  auth: (userId: string) => `auth_${userId}`,
};

// Function to fetch calendar events for a specific date
async function fetchCalendarEvents(date: Date) {
  const startOfDay = setSeconds(setMinutes(setHours(date, 0), 0), 0);
  const endOfDay = setSeconds(setMinutes(setHours(date, 23), 59), 59);

  const bayEvents = await Promise.all(
    Object.values(AVAILABILITY_CALENDARS).map(calendarId =>
      calendar.events.list({
        calendarId,
        timeMin: format(startOfDay, "yyyy-MM-dd'T'HH:mm:ssxxx"),
        timeMax: format(endOfDay, "yyyy-MM-dd'T'HH:mm:ssxxx"),
        singleEvents: true,
        orderBy: 'startTime',
        timeZone: 'Asia/Bangkok',
      })
    )
  );

  return bayEvents.flatMap(response => response.data.items || []);
}

// Function to update cache for next 3 days
export async function updateCalendarCache() {
  try {
    const today = new Date();
    const dates = [
      today,
      addDays(today, 1),
      addDays(today, 2)
    ];

    await Promise.all(dates.map(async (date) => {
      const dateKey = format(date, 'yyyy-MM-dd');
      const cacheKey = getCacheKey.calendar(dateKey);
      const events = await fetchCalendarEvents(date);
      calendarCache.set(cacheKey, events);
      console.log(`Updated cache for ${dateKey}`);
    }));

    console.log('Calendar cache updated successfully');
  } catch (error) {
    console.error('Error updating calendar cache:', error);
  }
}

// Start background cache update
let cacheInterval: NodeJS.Timeout;

export function startCacheUpdates() {
  // Initial update
  updateCalendarCache();

  // Update every 5 minutes
  cacheInterval = setInterval(updateCalendarCache, 5 * 60 * 1000);
}

export function stopCacheUpdates() {
  if (cacheInterval) {
    clearInterval(cacheInterval);
  }
} 



==== lib\debug.ts (133 lines) ====

const DEBUG = true;

interface DebugLog {
  timestamp: string;
  type: string;
  args: string;
}

// Check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Force logs to persist in localStorage
const persistLog = (type: string, ...args: any[]) => {
  const timestamp = new Date().toISOString();
  const log: DebugLog = {
    timestamp,
    type,
    args: JSON.stringify(args, null, 2)
  };

  try {
    if (isBrowser) {
      // Browser-side logging
      // Get existing logs
      const logs: DebugLog[] = JSON.parse(localStorage.getItem('debug_logs') || '[]');
      logs.push(log);
      // Keep only last 100 logs
      if (logs.length > 100) logs.shift();
      localStorage.setItem('debug_logs', JSON.stringify(logs));

      // Also log to console
      console.group(`[${type}] ${timestamp}`);
      console.info('Arguments:', ...args);
      console.groupEnd();

      // Create or update debug overlay
      let overlay = document.getElementById('debug-overlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'debug-overlay';
        overlay.style.cssText = `
          position: fixed;
          bottom: 0;
          right: 0;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 10px;
          font-family: monospace;
          font-size: 12px;
          max-height: 200px;
          max-width: 400px;
          overflow: auto;
          z-index: 9999;
        `;
        document.body.appendChild(overlay);
      }

      // Update overlay content
      const logEntry = document.createElement('div');
      logEntry.style.borderBottom = '1px solid rgba(255,255,255,0.2)';
      logEntry.style.padding = '5px 0';
      logEntry.innerHTML = `
        <div style="color: ${type === 'ERROR' ? '#ff6b6b' : type === 'WARN' ? '#ffd93d' : '#4cd137'}">
          [${type}] ${new Date().toLocaleTimeString()}
        </div>
        <div>${JSON.stringify(args)}</div>
      `;
      overlay.appendChild(logEntry);
      overlay.scrollTop = overlay.scrollHeight;
    } else {
      // Server-side logging
      console.log(`[${type}] ${timestamp}:`, ...args);
    }
  } catch (e) {
    console.error('Failed to persist log:', e);
  }
};

export const debug = {
  log: (...args: any[]) => {
    if (DEBUG) {
      persistLog('DEBUG', ...args);
    }
  },
  error: (...args: any[]) => {
    if (DEBUG) {
      persistLog('ERROR', ...args);
    }
  },
  warn: (...args: any[]) => {
    if (DEBUG) {
      persistLog('WARN', ...args);
    }
  },
  // Get all logs (client-side only)
  getLogs: (): DebugLog[] => {
    if (isBrowser) {
      try {
        return JSON.parse(localStorage.getItem('debug_logs') || '[]');
      } catch (e) {
        return [];
      }
    }
    return [];
  },
  // Clear logs (client-side only)
  clearLogs: () => {
    if (isBrowser) {
      localStorage.removeItem('debug_logs');
      const overlay = document.getElementById('debug-overlay');
      if (overlay) {
        overlay.innerHTML = '';
      }
    }
  },
  // Show logs in UI (client-side only)
  showLogs: () => {
    if (isBrowser) {
      const logs = debug.getLogs();
      const overlay = document.getElementById('debug-overlay');
      if (overlay) {
        overlay.innerHTML = logs.map((log: DebugLog) => `
          <div style="border-bottom: 1px solid rgba(255,255,255,0.2); padding: 5px 0;">
            <div style="color: ${log.type === 'ERROR' ? '#ff6b6b' : log.type === 'WARN' ? '#ffd93d' : '#4cd137'}">
              [${log.type}] ${new Date(log.timestamp).toLocaleTimeString()}
            </div>
            <div>${log.args}</div>
          </div>
        `).join('');
      }
    }
  }
}; 



==== lib\emailService.ts (133 lines) ====

import nodemailer from 'nodemailer';

interface EmailConfirmation {
  userName: string;
  subjectName?: string; // Name to use in email subject
  email: string;
  date: string;
  startTime: string;
  endTime: string;
  duration: number;
  numberOfPeople: number;
  bayNumber?: string;
  phoneNumber?: string;
  packageInfo?: string;
  customerNotes?: string;
}

const transporter = nodemailer.createTransport({
  host: '27.254.86.99', // Direct IP address instead of mail.len.golf
  port: 587,
  secure: false, // Use false since port 587 doesn't use SSL
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD,
  },
  tls: {
    rejectUnauthorized: false, // Allow self-signed certificates if necessary
  },
});

export async function sendConfirmationEmail(booking: EmailConfirmation) {
  // Create the email subject without the name
  const emailSubject = `LENGOLF Booking Confirmation - ${booking.date} at ${booking.startTime}`;

  const emailContent = `
    <div style="font-family: Arial, sans-serif; color: #333; max-width: 600px; margin: 0 auto; border: 1px solid #ddd; border-radius: 8px; padding: 20px; background-color: #ffffff;">
        <!-- Logo Section -->
        <div style="text-align: center; margin-bottom: 20px;">
            <img src="https://www.len.golf/wp-content/uploads/2024/06/Logo.png" alt="LENGOLF Logo" style="max-width: 200px;">
        </div>

        <!-- Header -->
        <h2 style="color: #1a3308; text-align: center; margin-bottom: 20px;">Booking Confirmed!</h2>

        <!-- Greeting -->
        <p style="font-size: 16px; line-height: 1.5; color: #1a3308; margin-bottom: 20px;">
            Dear <strong>${booking.userName}</strong>,
        </p>
        <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
            Thank you for your booking. Here are your booking details:
        </p>

        <!-- Booking Details Table -->
        <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 15px;">
            <tr>
                <th style="text-align: left; padding: 10px; background-color: #f9f9f9; border-bottom: 1px solid #ddd;">Date</th>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">${booking.date}</td>
            </tr>
            <tr>
                <th style="text-align: left; padding: 10px; background-color: #f9f9f9; border-bottom: 1px solid #ddd;">Start Time</th>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">${booking.startTime}</td>
            </tr>
            <tr>
                <th style="text-align: left; padding: 10px; background-color: #f9f9f9; border-bottom: 1px solid #ddd;">End Time</th>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">${booking.endTime}</td>
            </tr>
            <tr>
                <th style="text-align: left; padding: 10px; background-color: #f9f9f9; border-bottom: 1px solid #ddd;">Duration</th>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">${booking.duration} hour(s)</td>
            </tr>
            <tr>
                <th style="text-align: left; padding: 10px; background-color: #f9f9f9; border-bottom: 1px solid #ddd;">Number of People</th>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">${booking.numberOfPeople}</td>
            </tr>
            ${booking.customerNotes ? `
            <tr>
                <th style="text-align: left; padding: 10px; background-color: #f9f9f9; border-bottom: 1px solid #ddd;">Notes/Requests</th>
                <td style="padding: 10px; border-bottom: 1px solid #ddd; white-space: pre-wrap;">${booking.customerNotes}</td>
            </tr>
            ` : ''}
        </table>

        <!-- Closing Message -->
        <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
            We look forward to seeing you! If you have any questions, feel free to reach out to us.
        </p>

        <!-- Booking Modification Disclaimer -->
        <p style="font-size: 14px; line-height: 1.5; color: #777; margin-bottom: 20px;">
            <em>If you need to modify your booking, please email us at <a href="mailto:info@len.golf" style="color: #8dc743; text-decoration: none;">info@len.golf</a> or contact us via Phone / LINE.</em>
        </p>

        <!-- Footer -->
        <div style="font-size: 14px; color: #777; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd;">
            <p style="margin: 5px 0; text-align: center;">
                <strong>Phone Number:</strong> <a href="tel:+66966682335" style="color: #8dc743; text-decoration: none;">+66 96 668 2335</a>
            </p>
            <p style="margin: 5px 0; text-align: center;">
                <strong>LINE:</strong> <a href="https://lin.ee/UwwOr84" style="color: #8dc743; text-decoration: none;">@lengolf</a>
            </p>
            <p style="margin: 5px 0; text-align: center;">
                <strong>Maps Link:</strong> <a href="https://maps.app.goo.gl/U6rgZyjCwC46dABy6" style="color: #8dc743; text-decoration: none;">How to find us</a>
            </p>
            <p style="margin: 5px 0; text-align: center;">
                <strong>Address:</strong> 4th Floor, Mercury Ville at BTS Chidlom
            </p>
            <div style="text-align: center; margin-top: 20px;">
                <a href="https://len.golf" style="text-decoration: none; color: white; background-color: #1a3308; padding: 8px 15px; border-radius: 5px; font-size: 14px;">
                    Visit Our Website
                </a>
            </div>
            <p style="font-size: 12px; margin-top: 15px; color: #777; text-align: center;">
                &copy; 2024 LENGOLF. All rights reserved.
            </p>
        </div>
    </div>
  `.trim();

  const mailOptions = {
    from: 'LENGOLF <notification@len.golf>',
    to: booking.email,
    subject: emailSubject,
    html: emailContent,
  };

  try {
    await transporter.sendMail(mailOptions);
    return true;
  } catch (error) {
    console.error('Failed to send confirmation email:', error);
    return false;
  }
} 



==== lib\env.ts (9 lines) ====

export const getEnvVar = (key: string): string => {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Environment variable ${key} is not set`);
  }
  return value;
};

export const LINE_NOTIFY_TOKEN = getEnvVar('LINE_NOTIFY_TOKEN'); 



==== lib\googleApiConfig.ts (49 lines) ====

import { GoogleAuth } from 'google-auth-library';
import { google } from 'googleapis';

if (!process.env.SERVICE_ACCOUNT_KEY_BASE64) {
  throw new Error('Missing SERVICE_ACCOUNT_KEY_BASE64 environment variable');
}

// Parse the base64-encoded service account key
let credentials;
try {
  credentials = JSON.parse(
    Buffer.from(process.env.SERVICE_ACCOUNT_KEY_BASE64, 'base64').toString('utf-8')
  );
} catch (error) {
  console.error('Failed to parse SERVICE_ACCOUNT_KEY_BASE64:', error);
  throw error;
}

// Instantiate GoogleAuth with the parsed credentials and required scopes
const auth = new GoogleAuth({
  credentials: credentials,
  scopes: [
    'https://www.googleapis.com/auth/calendar',
    'https://www.googleapis.com/auth/calendar.events',
  ],
});

export const AVAILABILITY_CALENDARS = {
  'Bay 1 (Bar)': process.env.AVAILABILITY_CALENDAR_BAY1_ID!,
  'Bay 2': process.env.AVAILABILITY_CALENDAR_BAY2_ID!,
  'Bay 3 (Entrance)': process.env.AVAILABILITY_CALENDAR_BAY3_ID!,
} as const;

// Validate required environment variables
const missingVars = Object.entries(AVAILABILITY_CALENDARS).filter(([_, value]) => !value);

if (missingVars.length > 0) {
  throw new Error(
    `Missing required environment variables for availability calendars: ${missingVars
      .map(([key]) => `AVAILABILITY_CALENDAR_${key.replace(/[ ()]/g, '')}_ID`)
      .join(', ')}`
  );
}

const calendar = google.calendar({ version: 'v3', auth });

export { calendar, auth };

export type AvailabilityBay = keyof typeof AVAILABILITY_CALENDARS; 



==== lib\init.ts (12 lines) ====

import { startCacheUpdates } from './cache';

// Start background processes
if (process.env.NODE_ENV !== 'development' || process.env.ENABLE_CACHE_IN_DEV === 'true') {
  console.log('Starting background cache updates...');
  startCacheUpdates();
}

process.on('SIGTERM', () => {
  console.log('Shutting down...');
  process.exit(0);
}); 



==== lib\lineNotifyService.ts (43 lines) ====

import { LINE_NOTIFY_TOKEN } from './env';

interface BookingNotification {
  customerName: string;
  email: string;
  phoneNumber: string;
  bookingDate: string;
  bookingStartTime: string;
  bookingEndTime: string;
  bayNumber: string;
  duration: number;
  numberOfPeople: number;
  crmCustomerId?: string;
  profileId?: string;
  skipCrmMatch?: boolean;
  packageInfo?: string;
  bookingName?: string;
  crmCustomerData?: any;
  bookingId?: string;
  channel?: string;
}

export async function sendBookingNotification(booking: BookingNotification) {
  try {
    const response = await fetch('/api/notifications/line', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(booking),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to send LINE notification');
    }

    return true;
  } catch (error) {
    console.error('Failed to send LINE notification:', error);
    return false;
  }
} 



==== lib\reviewRequestScheduler.ts (86 lines) ====

/**
 * Review Request Scheduler using Supabase Cron
 * 
 * This module provides functions to schedule review requests using Supabase Cron,
 * which is tightly integrated with our Supabase database.
 * 
 * Instead of using an external service, we simply store the request in our database
 * and let Supabase Cron trigger our webhook endpoint at the appropriate time.
 */

import { createServerClient } from '@/utils/supabase/server';
import { addMinutes, addHours, parse } from 'date-fns';
import { zonedTimeToUtc } from 'date-fns-tz';

const TIMEZONE = 'Asia/Bangkok';

interface ScheduleOptions {
  bookingId: string;
  userId: string;
  provider: 'line' | 'email';
  contactInfo: string;
  delayMinutes?: number; // Optional direct delay in minutes
}

/**
 * Schedule a review request using Supabase Database
 * Supabase Cron will be configured to periodically check for review requests that are due
 */
export async function scheduleReviewRequest(options: ScheduleOptions): Promise<boolean> {
  try {
    const supabase = createServerClient();
    let scheduledTime: Date;
    
    // If specific delay minutes are provided, use them from current time
    if (options.delayMinutes) {
      // Calculate scheduled time using provided delay
      const now = new Date();
      scheduledTime = addMinutes(now, options.delayMinutes);
      console.log(`Scheduling review request using delay of ${options.delayMinutes} minutes from now`);
    } else {
      // Look up the booking details to calculate based on end time
      const { data: booking, error: bookingError } = await supabase
        .from('bookings')
        .select('date, start_time, duration')
        .eq('id', options.bookingId)
        .single();
      
      if (bookingError || !booking) {
        console.error('Error fetching booking details for review scheduling:', bookingError);
        return false;
      }
      
      // Calculate the end time of the booking
      const parsedDateTime = parse(`${booking.date} ${booking.start_time}`, 'yyyy-MM-dd HH:mm', new Date());
      const startTimeUtc = zonedTimeToUtc(parsedDateTime, TIMEZONE);
      const endTimeUtc = addHours(startTimeUtc, booking.duration);
      
      // Add 30 minutes after the booking ends
      scheduledTime = addMinutes(endTimeUtc, 30);
      console.log(`Scheduling review request for 30 minutes after booking ends at ${scheduledTime.toISOString()}`);
    }
    
    // Create database record
    const { error } = await supabase
      .from('scheduled_review_requests')
      .insert({
        booking_id: options.bookingId,
        user_id: options.userId,
        scheduled_time: scheduledTime.toISOString(),
        provider: options.provider,
        contact_info: options.contactInfo,
        sent: false
      });
    
    if (error) {
      console.error('Error creating scheduled review request in database:', error);
      return false;
    }
    
    console.log(`Review request scheduled in database for ${scheduledTime.toISOString()}`);
    return true;
  } catch (error) {
    console.error('Error scheduling review request:', error);
    return false;
  }
} 



==== middleware.ts (175 lines) ====

import { NextResponse } from 'next/server';
import { getToken } from 'next-auth/jwt';
import type { NextRequest } from 'next/server';

// Rate limiting map
const ipRequestMap = new Map<string, { count: number; timestamp: number }>();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute
const MAX_REQUESTS_PER_WINDOW = 120; // 120 requests per minute (doubled from before)

// Bot detection patterns
const BOT_USER_AGENTS = [
  /crawler/i,
  /spider/i,
  /crawling/i,
  /headless/i,
  /scraper/i,
  /python/i,
  /curl/i,
  /wget/i,
  /phantom/i,
  /selenium/i
];

// Allowed bots (these bots should be allowed to access the site)
const ALLOWED_BOTS = [
  /googlebot/i,
  /google-adsbot/i,
  /adsbot-google/i,
  /mediapartners-google/i,
  /google web preview/i,
  /google favicon/i,
  /adsbot/i,           // Additional Google Ads bots
  /adspreview/i,       // Google Ads Preview and Diagnosis tool
  /google-adwords/i,   // Google AdWords
  /google-shopping/i,  // Google Shopping
  /google-xrawler/i,   // Google ad verification
  /adservice.google/i  // Google Ad Service
];

// Suspicious behavior patterns
const SUSPICIOUS_PATTERNS = {
  noUserAgent: true,
  emptyReferer: true,
  multipleParallelRequests: true
};

function isBot(request: NextRequest): boolean {
  const userAgent = request.headers.get('user-agent') || '';
  const referer = request.headers.get('referer');
  const acceptLanguage = request.headers.get('accept-language');
  const acceptEncoding = request.headers.get('accept-encoding');

  // Check if it's an allowed bot first - this has priority
  if (ALLOWED_BOTS.some(pattern => pattern.test(userAgent))) {
    return false; // Allow these bots to access the site
  }

  // Only check for obvious bot patterns in user agent
  if (BOT_USER_AGENTS.some(pattern => pattern.test(userAgent))) {
    return true;
  }

  // Only block if no user agent at all
  if (!userAgent) {
    return true;
  }

  // Block if ALL headers are missing (likely a bot)
  if (!userAgent && !referer && !acceptLanguage && !acceptEncoding) {
    return true;
  }

  return false;
}

function shouldRateLimit(request: NextRequest): boolean {
  // Don't rate limit static assets or auth routes
  if (
    request.nextUrl.pathname.startsWith('/_next/') ||
    request.nextUrl.pathname.startsWith('/api/auth') ||
    request.nextUrl.pathname.startsWith('/auth') ||
    request.nextUrl.pathname.startsWith('/images/')
  ) {
    return false;
  }

  const ip = request.headers.get('x-forwarded-for')?.split(',')[0] || '';
  const now = Date.now();

  // Clean up old entries
  Array.from(ipRequestMap.entries()).forEach(([storedIp, data]) => {
    if (now - data.timestamp > RATE_LIMIT_WINDOW) {
      ipRequestMap.delete(storedIp);
    }
  });

  // Get or create rate limit data for this IP
  const rateData = ipRequestMap.get(ip) || { count: 0, timestamp: now };

  // Reset count if outside window
  if (now - rateData.timestamp > RATE_LIMIT_WINDOW) {
    rateData.count = 1;
    rateData.timestamp = now;
  } else {
    rateData.count++;
  }

  ipRequestMap.set(ip, rateData);

  return rateData.count > MAX_REQUESTS_PER_WINDOW;
}

export async function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;
  const userAgent = request.headers.get('user-agent') || '';

  // Allow access to public routes immediately
  if (
    pathname.startsWith('/api/auth') ||
    pathname.startsWith('/auth') ||
    pathname.startsWith('/images/') ||
    pathname.startsWith('/_next/') ||
    pathname.includes('/favicon.')
  ) {
    return NextResponse.next();
  }

  // Check for bots and rate limiting
  if (isBot(request)) {
    return new NextResponse('Access Denied', { status: 403 });
  }

  if (shouldRateLimit(request)) {
    return new NextResponse('Too Many Requests', { status: 429 });
  }

  // Special handling for Google Ads bots
  const isGoogleAdsBot = ALLOWED_BOTS.some(pattern => pattern.test(userAgent));
  
  // Redirect root to login UNLESS it's a Google Ads bot
  if (pathname === '/' && !isGoogleAdsBot) {
    return NextResponse.redirect(new URL('/bookings', request.url));
  }
  
  // Allow Google Ads bots to access any page without authentication
  if (isGoogleAdsBot) {
    return NextResponse.next();
  }

  try {
    // Check for NextAuth session token
    const token = await getToken({
      req: request,
      secret: process.env.NEXTAUTH_SECRET,
    });

    return NextResponse.next();
  } catch (error) {
    console.error('Middleware error:', error);
    return NextResponse.redirect(new URL('/auth/login', request.url));
  }
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (images, etc.)
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}; 



==== next-env.d.ts (7 lines) ====

/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference types="next/navigation-types/compat/navigation" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.




==== next.config.js (31 lines) ====

/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  reactStrictMode: true,
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'www.len.golf',
      },
      {
        protocol: 'https',
        hostname: 'len.golf',
      },
      {
        protocol: 'https',
        hostname: 'lh3.googleusercontent.com',
      },
      {
        protocol: 'https',
        hostname: 'platform-lookaside.fbsbx.com',
      },
      {
        protocol: 'https',
        hostname: 'profile.line-scdn.net',
      },
    ],
  },
}

module.exports = nextConfig 



==== next.config.ts (8 lines) ====

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;




==== pages\api\adsbot-test.ts (29 lines) ====

import { NextApiRequest, NextApiResponse } from 'next';

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  // Get the user agent
  const userAgent = req.headers['user-agent'] || '';
  
  // Check if it's a Google AdsBot
  const isGoogleAdsBot = 
    /googlebot/i.test(userAgent) ||
    /google-adsbot/i.test(userAgent) ||
    /adsbot-google/i.test(userAgent) ||
    /mediapartners-google/i.test(userAgent);
  
  // Log the access
  console.log(`[${new Date().toISOString()}] AdsBot Test Access:`, {
    userAgent,
    isGoogleAdsBot,
    ip: req.headers['x-forwarded-for'] || req.socket.remoteAddress,
    path: req.url
  });
  
  // Return a simple response
  res.status(200).json({
    success: true,
    message: 'Access logged',
    isGoogleAdsBot,
    userAgent
  });
} 



==== postcss.config.js (6 lines) ====

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
} 



==== public\googlebot-test.html (14 lines) ====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google AdsBots Test Page</title>
</head>
<body>
    <h1>Google AdsBots Test Page</h1>
    <p>This page is used to verify that Google's AdsBots can access the website.</p>
    <p>If you can see this page, it means the site is accessible to Google's crawlers.</p>
    <p>Test page created: May 2024</p>
</body>
</html> 



==== public\test-adsbot.html (53 lines) ====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google AdsBots Test Page</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .success {
            color: green;
            font-weight: bold;
        }
        .instructions {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        h1 {
            color: #333;
        }
    </style>
</head>
<body>
    <h1>Google AdsBots Test Page</h1>
    <p class="success">âœ… If you can see this page, the server is responding correctly.</p>
    <p>This page is accessible at: <strong>https://booking.len.golf/test-adsbot.html</strong></p>
    
    <div class="instructions">
        <h2>How to Test Google AdsBots Access:</h2>
        <ol>
            <li>Use an online user-agent switcher tool like <a href="https://www.webconfs.com/user-agent-switcher.php" target="_blank">WebConfs User Agent Switcher</a></li>
            <li>Enter this URL: <code>https://booking.len.golf/test-adsbot.html</code></li>
            <li>Set the user agent to one of these Google AdsBots strings:
                <ul>
                    <li><code>AdsBot-Google (+http://www.google.com/adsbot.html)</code></li>
                    <li><code>AdsBot-Google-Mobile-Apps</code></li>
                    <li><code>Mediapartners-Google</code></li>
                </ul>
            </li>
            <li>If the tool can access this page with those user agents, Google's AdsBots should be able to access your site</li>
        </ol>
    </div>
    
    <p>Test page created: May 2024</p>
</body>
</html> 



==== scripts\clean-duplicate-mappings.js (99 lines) ====

require('dotenv').config();
const { createClient } = require('@supabase/supabase-js');

async function createSupabaseClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );
}

async function cleanupDuplicateMappings() {
  const supabase = await createSupabaseClient();
  console.log('ðŸ‘‹ Starting duplicate CRM mapping cleanup...');
  
  try {
    // STEP 1: Find all profiles with multiple mappings
    console.log('Finding profiles with duplicate mappings...');
    
    const { data: profileCounts, error: countError } = await supabase
      .from('crm_customer_mapping')
      .select('profile_id, count(*)')
      .eq('is_matched', true)
      .group('profile_id')
      .order('count', { ascending: false });
      
    if (countError) {
      console.error('Error finding duplicate mappings:', countError);
      return;
    }
    
    // Filter to only include profiles with multiple mappings
    const profilesWithDuplicates = profileCounts.filter(p => p.count > 1);
    
    if (profilesWithDuplicates.length === 0) {
      console.log('âœ… No duplicate mappings found. Database is clean!');
      return;
    }
    
    console.log(`ðŸ” Found ${profilesWithDuplicates.length} profiles with duplicate mappings`);
    console.table(profilesWithDuplicates);
    
    // STEP 2: Process each profile with duplicates
    for (const profile of profilesWithDuplicates) {
      const profileId = profile.profile_id;
      console.log(`\nProcessing profile: ${profileId} (${profile.count} mappings)...`);
      
      // Get all mappings for this profile
      const { data: mappings, error: mappingsError } = await supabase
        .from('crm_customer_mapping')
        .select('*')
        .eq('profile_id', profileId)
        .eq('is_matched', true)
        .order('match_confidence', { ascending: false })
        .order('updated_at', { ascending: false });
        
      if (mappingsError) {
        console.error(`Error fetching mappings for profile ${profileId}:`, mappingsError);
        continue;
      }
      
      console.log(`Found ${mappings.length} mappings for profile ${profileId}`);
      
      // Keep the best mapping (highest confidence, most recent)
      const bestMapping = mappings[0];
      console.log(`Best mapping: Customer ID ${bestMapping.crm_customer_id}, Confidence: ${bestMapping.match_confidence}, Updated: ${bestMapping.updated_at}`);
      
      // Collect IDs of mappings to delete
      const mappingsToDelete = mappings.slice(1);
      const idsToDelete = mappingsToDelete.map(m => m.id);
      
      console.log(`Will delete ${idsToDelete.length} mappings: ${idsToDelete.join(', ')}`);
      
      // Delete the duplicates
      if (idsToDelete.length > 0) {
        const { error: deleteError } = await supabase
          .from('crm_customer_mapping')
          .delete()
          .in('id', idsToDelete);
          
        if (deleteError) {
          console.error(`Error deleting mappings for profile ${profileId}:`, deleteError);
        } else {
          console.log(`âœ… Successfully cleaned up mappings for profile ${profileId}`);
        }
      }
    }
    
    console.log('\nâœ… Duplicate mapping cleanup complete!');
    
  } catch (error) {
    console.error('Error in cleanup process:', error);
  }
}

// Run the cleanup function
cleanupDuplicateMappings().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
}); 



==== scripts\mark-reviews-as-sent.js (72 lines) ====

#!/usr/bin/env node

/**
 * Script to mark all pending review requests as sent
 * 
 * Usage:
 *   node scripts/mark-reviews-as-sent.js
 */

const { createClient } = require('@supabase/supabase-js');

// Configure Supabase client
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL || 'YOUR_SUPABASE_URL';
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || 'YOUR_SUPABASE_SERVICE_ROLE_KEY';

// Create a Supabase client with the service role key
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

async function markReviewsAsSent() {
  console.log('Marking all pending review requests as sent...');
  
  try {
    // Get all pending review requests
    const { data: pendingRequests, error: fetchError } = await supabase
      .from('scheduled_review_requests')
      .select('*')
      .eq('sent', false);

    if (fetchError) {
      console.error('Error fetching pending review requests:', fetchError);
      return;
    }
    
    if (!pendingRequests || pendingRequests.length === 0) {
      console.log('No pending review requests found');
      return;
    }
    
    console.log(`Found ${pendingRequests.length} pending review requests`);
    
    // Mark each request as sent
    const { data: updateResult, error: updateError } = await supabase
      .from('scheduled_review_requests')
      .update({ sent: true })
      .eq('sent', false);
    
    if (updateError) {
      console.error('Error updating review requests:', updateError);
      return;
    }
    
    console.log(`âœ… Successfully marked all pending review requests as sent`);
    return pendingRequests.length;
  } catch (error) {
    console.error('Error in markReviewsAsSent:', error);
    throw error;
  }
}

// Execute the function
markReviewsAsSent()
  .then((count) => {
    if (count) {
      console.log(`Marked ${count} review requests as sent`);
    }
    console.log('Script completed successfully');
    process.exit(0);
  })
  .catch(error => {
    console.error('Script failed:', error);
    process.exit(1);
  }); 



==== scripts\process-review-requests.js (69 lines) ====

#!/usr/bin/env node

/**
 * Script to process scheduled review requests
 * 
 * This script can be run via a cron job every 5 minutes to process
 * any pending review requests that are due to be sent.
 * 
 * Usage:
 *   CRON_API_KEY=your_secret_key node scripts/process-review-requests.js
 */

const fetch = require('node-fetch');

// Configuration
const API_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
const CRON_API_KEY = process.env.CRON_API_KEY;

if (!CRON_API_KEY) {
  console.error('Error: CRON_API_KEY environment variable is not set');
  process.exit(1);
}

async function processReviewRequests() {
  console.log(`[${new Date().toISOString()}] Processing scheduled review requests...`);
  
  try {
    const response = await fetch(`${API_URL}/api/notifications/process-review-requests`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${CRON_API_KEY}`
      }
    });
    
    const result = await response.json();
    
    if (!response.ok) {
      console.error('Error from API:', result.error || response.statusText);
      process.exit(1);
    }
    
    // Log results
    if (result.processed === 0) {
      console.log('No pending review requests to process');
    } else {
      console.log(`Processed ${result.processed} review requests`);
      console.log(`  âœ… Successful: ${result.successful}`);
      console.log(`  âŒ Failed: ${result.failed}`);
      
      if (result.failed > 0) {
        console.log('\nFailed requests:');
        result.results
          .filter(r => !r.success)
          .forEach(r => {
            console.log(`  - ID ${r.id}: ${r.error}`);
          });
      }
    }
    
    process.exit(0);
  } catch (error) {
    console.error('Execution error:', error.message);
    process.exit(1);
  }
}

// Run the main function
processReviewRequests(); 



==== scripts\schedule-test-review.js (182 lines) ====

#!/usr/bin/env node

/**
 * Script to schedule a test review request directly in the database
 * 
 * Usage:
 *   SUPABASE_URL=your-url SUPABASE_SERVICE_KEY=your-key node scripts/schedule-test-review.js --provider=email --to=user@example.com --name="John Doe" --when="2025-03-17 16:25:00"
 *   SUPABASE_URL=your-url SUPABASE_SERVICE_KEY=your-key node scripts/schedule-test-review.js --provider=line --to=Uf4177a1781df7fd215e6d2749fd00296 --name="Jane Smith" --when="2025-03-17 16:25:00"
 */

const { createClient } = require('@supabase/supabase-js');
const { v4: uuidv4 } = require('uuid');

// Constants
const GOOGLE_REVIEW_URL = 'https://g.page/r/CXwvpW56UsBgEAE/review';
const LINE_VOUCHER_IMAGE_URL = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher.png';
const EMAIL_VOUCHER_IMAGE_URL = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher_email.png';

// Check for required environment variables
const requiredEnvVars = ['SUPABASE_URL', 'SUPABASE_SERVICE_KEY'];
const missingEnvVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingEnvVars.length > 0) {
  console.error('Error: Missing required environment variables: ' + missingEnvVars.join(', '));
  console.error('\nUsage:');
  console.error('  SUPABASE_URL=your-url SUPABASE_SERVICE_KEY=your-key node scripts/schedule-test-review.js [options]');
  process.exit(1);
}

// Parse command line arguments
const args = process.argv.slice(2).reduce((acc, arg) => {
  const match = arg.match(/^--([^=]+)=(.*)$/);
  if (match) {
    acc[match[1]] = match[2];
  }
  return acc;
}, {});

// Validate required arguments
const requiredArgs = ['provider', 'to', 'name'];
const missingArgs = requiredArgs.filter(arg => !args[arg]);

if (missingArgs.length > 0) {
  console.error('Error: Missing required arguments: ' + missingArgs.join(', '));
  console.error('\nUsage:');
  console.error('  node scripts/schedule-test-review.js --provider=email --to=user@example.com --name="John Doe" --when="2025-03-17 16:25:00"');
  console.error('  node scripts/schedule-test-review.js --provider=line --to=Uf4177a1781df7fd215e6d2749fd00296 --name="Jane Smith" --when="2025-03-17 16:25:00"');
  process.exit(1);
}

// Validate provider
if (args.provider !== 'email' && args.provider !== 'line') {
  console.error('Error: Provider must be either "email" or "line"');
  process.exit(1);
}

// Create Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY,
  { auth: { persistSession: false } }
);

async function scheduleTestReviewRequest() {
  try {
    // Generate mock booking ID if not provided
    const bookingId = args.bookingId || `TEST-${new Date().getTime()}`;
    
    // Parse scheduled time (default to now + 5 minutes if not provided)
    let scheduledTime;
    if (args.when) {
      // Parse the provided time string
      scheduledTime = new Date(args.when);
      
      // Check if it's a valid date
      if (isNaN(scheduledTime.getTime())) {
        console.error('Error: Invalid date/time format. Please use YYYY-MM-DD HH:MM:SS format.');
        process.exit(1);
      }
    } else {
      // Default to 5 minutes from now
      scheduledTime = new Date();
      scheduledTime.setMinutes(scheduledTime.getMinutes() + 5);
    }
    
    // Format date for display
    const formattedDate = scheduledTime.toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      timeZoneName: 'short'
    });
    
    // Use the predefined voucher image URL or override with env var if provided
    const voucherImageUrl = process.env.REVIEW_VOUCHER_IMAGE_URL || (args.provider === 'line' ? LINE_VOUCHER_IMAGE_URL : EMAIL_VOUCHER_IMAGE_URL);
    
    console.log(`
=== TEST REVIEW REQUEST ===
Provider:       ${args.provider}
Recipient:      ${args.to}
Name:           ${args.name}
Booking:        ${bookingId}
Scheduled Time: ${formattedDate}
Review URL:     ${GOOGLE_REVIEW_URL}
Voucher Image:  ${voucherImageUrl}
=====================
`);
    
    // Create a test booking if needed (for foreign key constraint)
    let userId = '00000000-0000-0000-0000-000000000000';
    
    // Check if the test booking already exists
    const { data: existingBooking } = await supabase
      .from('bookings')
      .select('id')
      .eq('id', bookingId)
      .maybeSingle();
    
    if (!existingBooking) {
      console.log(`Creating test booking with ID: ${bookingId}`);
      
      // Create a test booking
      const { error: bookingError } = await supabase
        .from('bookings')
        .insert({
          id: bookingId,
          name: args.name,
          email: args.provider === 'email' ? args.to : 'test@example.com',
          phone_number: '0000000000',
          date: new Date().toISOString().split('T')[0],
          start_time: '12:00',
          duration: 1,
          number_of_people: 1,
          user_id: userId,
          bay: 'test-bay',
          status: 'confirmed'
        });
      
      if (bookingError) {
        console.error('Error creating test booking:', bookingError);
        console.log('Continuing with schedule request...');
      }
    } else {
      console.log(`Using existing booking with ID: ${bookingId}`);
    }
    
    // Insert scheduled review request
    const { data, error } = await supabase
      .from('scheduled_review_requests')
      .insert({
        id: uuidv4(),
        booking_id: bookingId,
        user_id: userId,
        scheduled_time: scheduledTime.toISOString(),
        provider: args.provider,
        contact_info: args.to,
        sent: false,
        created_at: new Date().toISOString()
      })
      .select()
      .single();
    
    if (error) {
      console.error('Error scheduling review request:', error);
      process.exit(1);
    }
    
    console.log('âœ… Test review request scheduled successfully!');
    console.log(data);
    
    process.exit(0);
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

// Run the function
scheduleTestReviewRequest(); 



==== scripts\send-test-review-request.js (101 lines) ====

#!/usr/bin/env node

/**
 * Script to manually send a test review request
 * 
 * Usage:
 *   node scripts/send-test-review-request.js --provider=email --to=dgeiermann@gmail.com --name="John Doe"
 *   node scripts/send-test-review-request.js --provider=line --to=Uf4177a1781df7fd215e6d2749fd00296 --name="Jane Smith"
 */

const fetch = require('node-fetch');

// Configuration
const API_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
const REVIEW_URL = 'https://g.page/r/CXwvpW56UsBgEAE/review';
const LINE_VOUCHER_IMAGE_URL = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher.png';
const EMAIL_VOUCHER_IMAGE_URL = 'https://www.len.golf/wp-content/uploads/2025/03/google_review_voucher_email.png';

// Parse command line arguments
const args = process.argv.slice(2).reduce((acc, arg) => {
  const match = arg.match(/^--([^=]+)=(.*)$/);
  if (match) {
    acc[match[1]] = match[2];
  }
  return acc;
}, {});

// Validate required arguments
const requiredArgs = ['provider', 'to', 'name'];
const missingArgs = requiredArgs.filter(arg => !args[arg]);

if (missingArgs.length > 0) {
  console.error('Error: Missing required arguments: ' + missingArgs.join(', '));
  console.error('\nUsage:');
  console.error('  node scripts/send-test-review-request.js --provider=email --to=user@example.com --name="John Doe"');
  console.error('  node scripts/send-test-review-request.js --provider=line --to=Uf4177a1781df7fd215e6d2749fd00296 --name="Jane Smith"');
  process.exit(1);
}

// Validate provider
if (args.provider !== 'email' && args.provider !== 'line') {
  console.error('Error: Provider must be either "email" or "line"');
  process.exit(1);
}

async function sendTestReviewRequest() {
  console.log(`Sending test ${args.provider} review request to ${args.to}...`);
  
  try {
    // Prepare request body based on provider
    let endpoint, body;
    
    if (args.provider === 'line') {
      endpoint = `${API_URL}/api/notifications/line/review-request`;
      body = {
        userId: args.to,
        bookingName: args.name,
        reviewUrl: REVIEW_URL,
        voucherImageUrl: LINE_VOUCHER_IMAGE_URL
      };
    } else {
      endpoint = `${API_URL}/api/notifications/email/review-request`;
      body = {
        email: args.to,
        userName: args.name,
        reviewUrl: REVIEW_URL,
        voucherImageUrl: EMAIL_VOUCHER_IMAGE_URL
      };
    }
    
    // Send request
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });
    
    const result = await response.json();
    
    if (!response.ok) {
      console.error('Error from API:', result.error || response.statusText);
      if (result.details) {
        console.error('Details:', result.details);
      }
      process.exit(1);
    }
    
    console.log('âœ… Review request sent successfully!');
    console.log(result);
    
    process.exit(0);
  } catch (error) {
    console.error('Execution error:', error);
    process.exit(1);
  }
}

// Run the main function
sendTestReviewRequest(); 



==== scripts\setup-supabase-cron.js (206 lines) ====

#!/usr/bin/env node

/**
 * Script to set up Supabase Cron settings
 * 
 * This script helps configure the required database settings for the 
 * review request scheduler using Supabase Cron.
 * 
 * Usage:
 *   SUPABASE_URL=https://bisimqmtxjsptehhqpeg.supabase.co SUPABASE_SERVICE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJpc2ltcW10eGpzcHRlaGhxcGVnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzOTY5MzEsImV4cCI6MjA1Mzk3MjkzMX0.NZ_mEOOoaKEG1p9LBXkULWwSIr-rWmCbksVZq3OzSYE API_KEY=15e6434f4d5cda3725f9935dd3ad44eaf2a4e803f603c9d50eff9cd7e64bcfe4 WEBHOOK_URL=https://41fb-2405-9800-b870-9483-5481-cfba-8c6e-7e71.ngrok-free.app/api/notifications/process-review-requests node scripts/setup-supabase-cron.js
 */

const { createClient } = require('@supabase/supabase-js');

// Check for required environment variables
const requiredVars = ['SUPABASE_URL', 'SUPABASE_SERVICE_KEY', 'API_KEY', 'WEBHOOK_URL'];
const missingVars = requiredVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  console.error('Error: Missing required environment variables: ' + missingVars.join(', '));
  console.error('\nUsage:');
  console.error('  SUPABASE_URL=your-supabase-url SUPABASE_SERVICE_KEY=your-service-key API_KEY=your-api-key WEBHOOK_URL=your-webhook-url node scripts/setup-supabase-cron.js');
  process.exit(1);
}

// Create Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_KEY,
  { auth: { persistSession: false } }
);

async function setupCronSettings() {
  console.log('Setting up Supabase Cron settings...');
  
  try {
    // 1. Set the API key using Postgres settings
    const { data: apiKeyResult, error: apiKeyError } = await supabase.rpc(
      'set_pg_setting',
      { 
        setting_name: 'app.cron_api_key', 
        setting_value: process.env.API_KEY 
      }
    );
    
    if (apiKeyError) {
      throw new Error(`Failed to set API key: ${apiKeyError.message}`);
    }
    
    console.log('âœ… API key set successfully');
    
    // 2. Set the webhook URL using Postgres settings
    const { data: webhookResult, error: webhookError } = await supabase.rpc(
      'set_pg_setting',
      { 
        setting_name: 'app.review_request_webhook_url', 
        setting_value: process.env.WEBHOOK_URL 
      }
    );
    
    if (webhookError) {
      throw new Error(`Failed to set webhook URL: ${webhookError.message}`);
    }
    
    console.log('âœ… Webhook URL set successfully');
    
    // 3. Verify the cron extension exists
    const { data: extensionData, error: extensionError } = await supabase.from('pg_extension')
      .select('*')
      .eq('extname', 'pg_cron')
      .maybeSingle();
    
    if (extensionError) {
      console.warn('Warning: Could not verify pg_cron extension:', extensionError.message);
    } else {
      if (extensionData) {
        console.log('âœ… pg_cron extension is installed');
      } else {
        console.warn('âš ï¸ pg_cron extension may not be installed. Run the migration first.');
      }
    }
    
    // 4. Check for existing cron job
    const { data: jobData, error: jobError } = await supabase
      .rpc('check_cron_job', { job_name: 'check-review-requests' });
    
    if (jobError) {
      console.warn('Warning: Could not check cron job:', jobError.message);
    } else {
      if (jobData && jobData.exists) {
        console.log('âœ… Cron job is scheduled');
      } else {
        console.warn('âš ï¸ Cron job may not be scheduled. Run the migration to create it.');
      }
    }
    
    console.log('\nSetup complete!');
    console.log('\nIMPORTANT: Make sure you have run the migration scripts to create the pg_cron extension and scheduled job.');
    
  } catch (error) {
    console.error('Error setting up Supabase Cron:', error);
    process.exit(1);
  }
}

// Create the stored procedures if they don't exist
async function createHelperFunctions() {
  try {
    // Create function to set PostgreSQL settings
    const setSettingSQL = `
      create or replace function set_pg_setting(setting_name text, setting_value text)
      returns boolean
      language plpgsql
      security definer
      as $$
      begin
        execute format('alter database %I set %s = %L', current_database(), setting_name, setting_value);
        return true;
      exception
        when others then
          raise exception 'Failed to set setting %: %', setting_name, sqlerrm;
      end;
      $$;
    `;
    
    // Create function to check if a cron job exists
    const checkJobSQL = `
      create or replace function check_cron_job(job_name text)
      returns json
      language plpgsql
      security definer
      as $$
      declare
        job_exists boolean;
      begin
        select exists(select 1 from cron.job where jobname = job_name) into job_exists;
        return json_build_object('exists', job_exists);
      exception
        when others then
          raise exception 'Failed to check job %: %', job_name, sqlerrm;
      end;
      $$;
    `;
    
    // Execute SQL statements
    const { error: setSettingError } = await supabase.rpc('exec_sql', { sql: setSettingSQL });
    if (setSettingError) {
      throw new Error(`Failed to create set_pg_setting function: ${setSettingError.message}`);
    }
    
    const { error: checkJobError } = await supabase.rpc('exec_sql', { sql: checkJobSQL });
    if (checkJobError) {
      throw new Error(`Failed to create check_cron_job function: ${checkJobError.message}`);
    }
    
    console.log('âœ… Helper functions created');
    
  } catch (error) {
    console.error('Error creating helper functions:', error);
    console.error('You may need to create these functions manually in the SQL editor.');
  }
}

// Create exec_sql function if it doesn't exist
async function createExecSqlFunction() {
  try {
    const { data, error } = await supabase.query(`
      create or replace function exec_sql(sql text)
      returns void
      language plpgsql
      security definer
      as $$
      begin
        execute sql;
      exception
        when others then
          raise exception 'SQL execution failed: %', sqlerrm;
      end;
      $$;
    `);
    
    if (error) {
      console.error('Error creating exec_sql function:', error.message);
      console.log('Continuing with setup...');
    } else {
      console.log('âœ… exec_sql function created');
    }
  } catch (error) {
    console.error('Error creating exec_sql function:', error);
    console.log('Continuing with setup...');
  }
}

// Run the setup
async function run() {
  try {
    await createExecSqlFunction();
    await createHelperFunctions();
    await setupCronSettings();
  } catch (error) {
    console.error('Setup failed:', error);
    process.exit(1);
  }
}

run(); 



==== scripts\sync-customer-matching.js (577 lines) ====

#!/usr/bin/env node
const path = require('path');
const { createClient } = require('@supabase/supabase-js');
const { levenshtein } = require('natural');
const fs = require('fs');

console.log('=== Starting Customer Matching Sync ===');

// Display help message
function showHelp() {
  console.log(`
Customer Matching Script - Matches booking profiles with CRM customer records

Usage:
  node sync-customer-matching.js [options]

Options:
  --help                Show this help message
  --all                 Process all profiles (default: false)
  --profile <id>        Process a specific profile by ID
  --maxDistance <number> Set maximum edit distance for phone similarity (default: 3)
  --debug               Enable debug mode (default: true)

Examples:
  # Process a single specific profile
  node sync-customer-matching.js --profile 44b0cd15-c901-4517-9743-31c68032259d
  
  # Process all profiles
  node sync-customer-matching.js --all
  
  # Process all profiles with debug mode off
  node sync-customer-matching.js --all --debug false
  `);
  process.exit(0);
}

// Get credentials from environment variables or use defaults
const CREDENTIALS = {
  // Booking Supabase
  SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://bisimqmtxjsptehhqpeg.supabase.co',
  SUPABASE_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJpc2ltcW10eGpzcHRlaGhxcGVnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzOTY5MzEsImV4cCI6MjA1Mzk3MjkzMX0.NZ_mEOOoaKEG1p9LBXkULWwSIr-rWmCbksVZq3OzSYE',
  
  // CRM Supabase
  CRM_SUPABASE_URL: process.env.NEXT_PUBLIC_CRM_SUPABASE_URL || 'https://dujqvigihnlfnvmcdrko.supabase.co',
  CRM_SUPABASE_KEY: process.env.NEXT_PUBLIC_CRM_SUPABASE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1anF2aWdpaG5sZm52bWNkcmtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzM3NTQyNDYsImV4cCI6MjA0OTMzMDI0Nn0.N-KIgE6_nfAY9LarJgFYFjBvjQ6awVgDmUtsBbNzhZM'
};

// Parse command line arguments
const args = process.argv.slice(2).reduce((acc, arg) => {
  if (arg.startsWith('--')) {
    const [key, value] = arg.substring(2).split('=');
    acc[key] = value || true;
  }
  return acc;
}, {});

// Show help if requested
if (args.help) {
  showHelp();
}

console.log('Command line arguments:', args);

// Configuration with defaults and command line overrides - with environment variable support
const CONFIG = {
  confidenceThreshold: parseFloat(process.env.CONFIDENCE_THRESHOLD || args.confidenceThreshold || 0.85),
  debugMode: (process.env.DEBUG_MODE === 'true') || args.debug === 'true',
  processAllProfiles: args.all === true || args.all === 'true',
  targetProfileId: args.profileId || null,
  maxPhoneEditDistance: parseInt(args.maxPhoneEditDistance || 2, 10)
};

// Debug output for processAllProfiles setting
console.log(`processAllProfiles setting: ${CONFIG.processAllProfiles}`);
console.log(`--all argument value: ${args.all}`);

// Simple logging function
function log(message, type = 'info') {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] [${type.toUpperCase()}] ${message}`);
}

/**
 * Create Supabase client for the booking database
 */
function createBookingClient() {
  console.log('Creating Booking Supabase client...');
  return createClient(CREDENTIALS.SUPABASE_URL, CREDENTIALS.SUPABASE_KEY);
}

/**
 * Create Supabase client for the CRM database
 */
function createCrmClient() {
  console.log('Creating CRM Supabase client...');
  return createClient(CREDENTIALS.CRM_SUPABASE_URL, CREDENTIALS.CRM_SUPABASE_KEY);
}

/**
 * Fetch all customers from the CRM
 */
async function fetchAllCrmCustomers() {
  console.log('Fetching CRM customers...');
  
  try {
    const supabase = createCrmClient();
    const { data, error } = await supabase
      .from('customers')  // Correct table name
      .select('*');
    
    if (error) {
      throw error;
    }
    
    console.log(`Fetched ${data.length} customers from CRM`);
    return data;
  } catch (error) {
    console.error('Error fetching CRM customers:', error);
    throw error; // Don't fall back to sample data, let the error propagate
  }
}

/**
 * Normalize phone number for comparison
 * @param {string} phone - The phone number to normalize
 * @returns {string} - The normalized phone number
 */
function normalizePhoneNumber(phone) {
  if (!phone) return '';
  
  // Convert to string if not already
  phone = String(phone);
  
  // Remove all non-digit characters
  let normalized = phone.replace(/\D/g, '');
  
  // For Thai mobile numbers, if it starts with '0', convert to '+66'
  if (normalized.startsWith('0')) {
    normalized = normalized.substring(1);
  }
  
  // For international format, if it starts with country code, extract the last 9 digits
  if (normalized.startsWith('66') || normalized.startsWith('661')) {
    normalized = normalized.substring(2);
  }
  
  // For international format without +, if it starts with other country codes
  if (normalized.length > 9 && !normalized.startsWith('66')) {
    // Extract the last 9 digits for comparison
    normalized = normalized.substring(normalized.length - 9);
  }
  
  // Try to consistently extract the last N digits for comparison
  // This helps match numbers that might be formatted differently but are actually the same
  if (normalized.length > 8) {
    // Keep the last 9 digits for consistency when comparing
    normalized = normalized.substring(Math.max(0, normalized.length - 9));
  }
  
  // Log for debugging
  if (normalized) {
    console.log(`Normalized phone number: ${phone} -> ${normalized}`);
  }
  
  return normalized;
}

/**
 * Normalize text for comparison
 * @param {string} text - The text to normalize
 * @returns {string} - The normalized text
 */
function normalizeText(text) {
  if (!text) return '';
  
  // Convert to string if not already
  text = String(text);
  
  // Convert to lowercase and remove extra spaces
  return text.toLowerCase().trim();
}

/**
 * Extract first and last name from display name
 * @param {string} displayName - Full display name
 * @returns {Object} - Object with first and last name
 */
function extractNameParts(displayName) {
  if (!displayName) return { first: '', last: '' };
  
  const parts = displayName.split(' ').filter(Boolean);
  if (parts.length === 0) return { first: '', last: '' };
  if (parts.length === 1) return { first: parts[0], last: '' };
  
  return {
    first: parts[0],
    last: parts.slice(1).join(' ')
  };
}

/**
 * Calculate Levenshtein distance between two strings
 * @param {string} a - First string
 * @param {string} b - Second string
 * @returns {number} - The edit distance between the strings
 */
function levenshteinDistance(a, b) {
  if (!a || !b) return 0;
  
  const matrix = [];
  
  // Initialize the matrix
  for (let i = 0; i <= a.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= b.length; j++) {
    matrix[0][j] = j;
  }
  
  // Fill the matrix
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,      // deletion
        matrix[i][j - 1] + 1,      // insertion
        matrix[i - 1][j - 1] + cost // substitution
      );
    }
  }
  
  return matrix[a.length][b.length];
}

/**
 * Calculate similarity score between two phone numbers
 * @param {string} phone1 - First phone number
 * @param {string} phone2 - Second phone number
 * @returns {number} - Similarity score between 0 and 1
 */
function phoneNumberSimilarity(phone1, phone2) {
  if (!phone1 || !phone2) return 0;
  
  // For very short numbers, require exact match
  if (phone1.length < 8 || phone2.length < 8) {
    return phone1 === phone2 ? 1 : 0;
  }
  
  // Calculate edit distance
  const distance = levenshteinDistance(phone1, phone2);
  
  // Calculate similarity score
  // For longer phone numbers, we allow more differences
  const maxLength = Math.max(phone1.length, phone2.length);
  const similarityThreshold = Math.min(3, Math.floor(maxLength * 0.2)); 
  
  let similarity = 0;
  if (distance === 0) {
    similarity = 1; // Exact match
  } else if (distance === 1) {
    similarity = 0.9; // Off by just one digit
  } else if (distance === 2) {
    similarity = 0.8; // Off by two digits
  } else if (distance <= similarityThreshold) {
    similarity = 0.7; // Similar enough but not very close
  }
  
  // Only log phone comparisons in debug mode and when there's an actual match
  if (process.env.DEBUG_PHONE_COMPARISON === 'true' && similarity > 0) {
    console.log(`Phone comparison: '${phone1}' vs '${phone2}' - distance: ${distance}, similarity: ${similarity.toFixed(2)}`);
  }
  
  return similarity;
}

/**
 * Match a profile with CRM customers
 * @param {Object} profile - The profile to match
 * @param {Array} crmCustomers - Array of CRM customers to match against
 * @returns {Object} - The match result with match, score, and reasons
 */
function matchProfile(profile, crmCustomers) {
  console.log(`Matching profile: ${profile.display_name}, phone: ${profile.phone_number}`);
  
  let bestMatch = null;
  let bestScore = 0;
  let bestReasons = [];
  
  // Extract name parts from display name
  const nameParts = extractNameParts(profile.display_name || '');
  
  // Normalize the profile data for comparison
  const normalizedProfilePhone = normalizePhoneNumber(profile.phone_number || '');
  const normalizedProfileFirstName = normalizeText(nameParts.first || '');
  const normalizedProfileLastName = normalizeText(nameParts.last || '');
  const normalizedProfileEmail = normalizeText(profile.email || '');
  
  console.log(`Normalized profile data: phone=${normalizedProfilePhone}, firstName=${normalizedProfileFirstName}, lastName=${normalizedProfileLastName}`);
  
  // Check each CRM customer for a match
  for (const customer of crmCustomers) {
    let score = 0;
    const reasons = [];
    
    // Extract name parts from customer name
    const customerNameParts = extractNameParts(customer.customer_name || '');
    
    // Normalize the customer data for comparison
    const normalizedCustomerPhone = normalizePhoneNumber(customer.contact_number || '');
    const normalizedCustomerFirstName = normalizeText(customerNameParts.first || '');
    const normalizedCustomerLastName = normalizeText(customerNameParts.last || '');
    const normalizedCustomerEmail = normalizeText(customer.email || '');
    
    // Phone number matching with improved fuzzy matching
    if (normalizedProfilePhone && normalizedCustomerPhone) {
      // Calculate phone similarity score
      const phoneSimilarity = phoneNumberSimilarity(normalizedProfilePhone, normalizedCustomerPhone);
      
      if (phoneSimilarity === 1) {
        score += 0.7; // Exact match
        reasons.push('exact_phone_match');
      } else if (phoneSimilarity >= 0.9) {
        score += 0.6; // Off by just one digit
        reasons.push('very_similar_phone_match');
      } else if (phoneSimilarity >= 0.8) {
        score += 0.5; // Off by two digits
        reasons.push('similar_phone_match');
      } else if (phoneSimilarity >= 0.7) {
        score += 0.3; // Similar enough
        reasons.push('partial_phone_match');
      } else if (normalizedProfilePhone.includes(normalizedCustomerPhone) || 
                normalizedCustomerPhone.includes(normalizedProfilePhone)) {
        score += 0.2;
        reasons.push('substring_phone_match');
      }
    }
    
    // Name matching
    if (normalizedProfileFirstName && normalizedCustomerFirstName) {
      if (normalizedProfileFirstName === normalizedCustomerFirstName) {
        score += 0.5; // Increased from 0.4 for exact name matches
        reasons.push('exact_first_name_match');
      } else if (normalizedProfileFirstName.includes(normalizedCustomerFirstName) || 
                normalizedCustomerFirstName.includes(normalizedProfileFirstName)) {
        score += 0.2;
        reasons.push('partial_first_name_match');
      }
    }
    
    if (normalizedProfileLastName && normalizedCustomerLastName) {
      if (normalizedProfileLastName === normalizedCustomerLastName) {
        score += 0.5; // Increased from 0.4 for exact name matches
        reasons.push('exact_last_name_match');
      } else if (normalizedProfileLastName.includes(normalizedCustomerLastName) || 
                normalizedCustomerLastName.includes(normalizedProfileLastName)) {
        score += 0.2;
        reasons.push('partial_last_name_match');
      }
    }
    
    // Email matching (exact match only)
    if (normalizedProfileEmail && normalizedCustomerEmail && 
        normalizedProfileEmail === normalizedCustomerEmail) {
      score += 0.5;
      reasons.push('exact_email_match');
    }
    
    // Cap the score at 1.0
    score = Math.min(score, 1.0);
    
    console.log(`Match score for ${customer.customer_name}: ${score} (${reasons.join(', ')})`);
    
    // Update best match if this score is higher
    if (score > bestScore) {
      bestMatch = customer;
      bestScore = score;
      bestReasons = reasons;
    }
  }
  
  return {
    match: bestMatch,
    score: bestScore,
    reasons: bestReasons
  };
}

/**
 * Create or update a mapping between a profile and a CRM customer
 */
async function createMapping(supabase, profile, customer, score, reasons) {
  // Only create mappings for matches above the confidence threshold
  if (score < CONFIG.confidenceThreshold) {
    console.log(`Skipping mapping creation for profile ${profile.id} - confidence score ${score.toFixed(2)} is below threshold (${CONFIG.confidenceThreshold})`);
    return { operation: 'skip', reason: 'low_confidence' };
  }

  console.log(`Creating mapping for profile ${profile.id} to customer ${customer.id}`);
  
  try {
    const mappingData = {
      profile_id: profile.id,
      crm_customer_id: customer.id,
      match_confidence: score.toFixed(2),
      match_method: Array.isArray(reasons) ? reasons.join(',') : reasons,
      stable_hash_id: customer.stable_hash_id || '',
      is_matched: true,
      crm_customer_data: customer // Include the entire customer object
    };
    
    // Use PostgreSQL's upsert functionality with the profile_id constraint
    console.log(`Upserting mapping for profile ${profile.id}`);
    const { data, error } = await supabase
      .from('crm_customer_mapping')
      .upsert(mappingData, {
        onConflict: 'profile_id'
      });
    
    if (error) {
      console.error(`Error upserting mapping: ${error.message}`);
      throw error;
    }
    
    return { operation: 'upsert', data };
  } catch (error) {
    console.error(`Error creating mapping for profile ${profile.id}:`, error);
    throw error;
  }
}

/**
 * Main function to run the customer matching process
 */
async function main() {
  log('Starting customer matching', 'info');
  log(`Configuration: confidenceThreshold=${CONFIG.confidenceThreshold}, debugMode=${CONFIG.debugMode}, processAllProfiles=${CONFIG.processAllProfiles}`, 'info');
  
  console.log('Creating Supabase client...');
  const supabase = createBookingClient();
  console.log('Supabase client created');
  
  console.log('Fetching profiles...');
  let query = supabase.from('profiles').select('*');
  
  // Determine whether to process all profiles or just a specific one
  if (CONFIG.processAllProfiles) {
    log('Processing ALL profiles (--all flag is set)', 'info');
    // No filter - will process all profiles
  } else if (CONFIG.targetProfileId) {
    log(`Targeting specific profile ID: ${CONFIG.targetProfileId}`, 'info');
    query = query.eq('id', CONFIG.targetProfileId);
  } else {
    log('No target profile specified and --all flag not set. Using default profile ID.', 'warn');
    query = query.eq('id', '44b0cd15-c901-4517-9743-31c68032259d');
  }
  
  const { data: profiles, error } = await query;
  
  if (error) {
    console.error('Error fetching profiles:', error);
    log(`Error fetching profiles: ${error.message}`, 'error');
    return false;
  }
  
  if (!profiles || profiles.length === 0) {
    console.error('No profiles found');
    log('No profiles found', 'error');
    return false;
  }
  
  console.log(`Fetched ${profiles.length} profiles`);
  log(`Fetched ${profiles.length} profiles`, 'info');
  
  console.log('Fetching CRM customers...');
  const crmCustomers = await fetchAllCrmCustomers();
  console.log(`Fetched ${crmCustomers.length} CRM customers`);
  
  // Process profiles
  console.log('Processing profiles...');
  let matchCount = 0;
  let lowerMatchCount = 0;
  let notMatchedCount = 0;  // Re-add this to track profiles with no matches
  
  // Make sure we have all the confidence levels
  const confidenceLevels = {
    '0.0-0.1': 0,
    '0.1-0.2': 0,
    '0.2-0.3': 0,
    '0.3-0.4': 0,
    '0.4-0.5': 0,
    '0.5-0.6': 0,
    '0.6-0.7': 0,
    '0.7-0.8': 0,
    '0.8-0.9': 0,
    '0.9-1.0': 0
  };
  
  for (const profile of profiles) {
    try {
      console.log(`Processing profile ${profile.id} (${profile.display_name})`);
      const { match, score, reasons } = matchProfile(profile, crmCustomers);
      
      if (match) {
        if (score >= 0.6) {
          // Only count as a match if score >= 0.6
          matchCount++;
          // ... create mapping code ...
          await createMapping(supabase, profile, match, score, reasons);
        } else if (score >= 0.4) {
          // Track lower confidence matches but don't create mappings
          lowerMatchCount++;
          console.log(`Lower confidence match found for profile ${profile.id} with score ${score.toFixed(1)}`);
        } else {
          console.log(`No match found for profile ${profile.id} (best score: ${score.toFixed(1)})`);
        }

        // Track confidence level statistics regardless of whether we create a mapping
        if (score >= 0.2 && score < 0.3) confidenceLevels['0.2-0.3']++;
        else if (score >= 0.3 && score < 0.4) confidenceLevels['0.3-0.4']++;
        else if (score >= 0.4 && score < 0.5) confidenceLevels['0.4-0.5']++;
        else if (score >= 0.5 && score < 0.6) confidenceLevels['0.5-0.6']++;
        else if (score >= 0.6 && score < 0.7) confidenceLevels['0.6-0.7']++;
        else if (score >= 0.7 && score < 0.8) confidenceLevels['0.7-0.8']++;
        else if (score >= 0.8 && score < 0.9) confidenceLevels['0.8-0.9']++;
        else if (score >= 0.9) confidenceLevels['0.9-1.0']++;
      } else {
        console.log(`No match found for profile ${profile.id}`);
        notMatchedCount++;
      }
    } catch (error) {
      console.error(`Error processing profile ${profile.id}:`, error);
      log(`Error processing profile ${profile.id}: ${error.message}`, 'error');
    }
  }
  
  // Log statistics
  console.log('=== Matching Statistics ===');
  console.log(`Profiles processed: ${profiles.length}`);
  console.log(`High confidence matches (>=0.6): ${matchCount}`);
  console.log(`Lower confidence matches (0.4-0.6): ${lowerMatchCount}`);
  console.log(`Total matches found: ${matchCount + lowerMatchCount}`);
  console.log(`Not matched: ${notMatchedCount}`);
  
  // Log confidence level breakdown
  console.log('=== Confidence Level Breakdown ===');
  for (const [level, count] of Object.entries(confidenceLevels)) {
    if (count > 0) {
      console.log(`  ${level}: ${count} profiles`);
    }
  }
  
  log(`Matching complete. High confidence (mapped): ${matchCount}, Lower confidence (not mapped): ${lowerMatchCount}, Not matched: ${notMatchedCount}`, 'info');
  
  if (typeof lowerMatchCount !== 'undefined') {
    log(`Note: ${lowerMatchCount} profiles had match scores between 0.4-0.6 but were not mapped due to confidence threshold`, 'info');
  }
  
  console.log('Main function completed');
  return true;
}

// Run the main function
console.log('Calling main function...');
main().then(success => {
  if (success) {
    log('Script completed successfully', 'info');
    process.exit(0);
  } else {
    log('Script completed with errors', 'error');
    process.exit(1);
  }
}).catch(err => {
  console.error('Error in main function:', err);
  log(`Unhandled error: ${err.message}`, 'error');
  process.exit(1);
});



==== scripts\sync-packages.js (395 lines) ====

#!/usr/bin/env node
const path = require('path');
const { createClient } = require('@supabase/supabase-js');
const fs = require('fs');

console.log('=== Starting Package Sync Script ===');

// Get credentials from environment variables or use defaults
const CREDENTIALS = {
  // Booking Supabase
  SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://bisimqmtxjsptehhqpeg.supabase.co',
  SUPABASE_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJpc2ltcW10eGpzcHRlaGhxcGVnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzgzOTY5MzEsImV4cCI6MjA1Mzk3MjkzMX0.NZ_mEOOoaKEG1p9LBXkULWwSIr-rWmCbksVZq3OzSYE',
  
  // CRM Supabase
  CRM_SUPABASE_URL: process.env.NEXT_PUBLIC_CRM_SUPABASE_URL || 'https://dujqvigihnlfnvmcdrko.supabase.co',
  CRM_SUPABASE_KEY: process.env.NEXT_PUBLIC_CRM_SUPABASE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1anF2aWdpaG5sZm52bWNkcmtvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzM3NTQyNDYsImV4cCI6MjA0OTMzMDI0Nn0.N-KIgE6_nfAY9LarJgFYFjBvjQ6awVgDmUtsBbNzhZM'
};

// Parse command line arguments
const args = process.argv.slice(2).reduce((acc, arg) => {
  if (arg.startsWith('--')) {
    const [key, value] = arg.substring(2).split('=');
    acc[key] = value || true;
  }
  return acc;
}, {});

// Configuration with defaults and command line overrides
const CONFIG = {
  batchSize: parseInt(args.batchSize || 20, 10),
  debugMode: (process.env.DEBUG_MODE === 'true') || args.debug === 'true',
  profileId: args.profileId || null,
  stableHashId: args.stableHashId || null
};

// Output directory for logs and results
const OUTPUT_DIR = path.join(__dirname, '..', 'logs');
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Log file for the sync process
const LOG_FILE = path.join(OUTPUT_DIR, `package-sync-${new Date().toISOString().replace(/:/g, '-')}.log`);
const logStream = fs.createWriteStream(LOG_FILE, { flags: 'a' });

/**
 * Helper function to log message to console and file
 */
function log(message, type = 'info', obj = null) {
  const timestamp = new Date().toISOString();
  let logMessage = `[${timestamp}] [${type}] ${message}`;
  
  console.log(logMessage);
  logStream.write(logMessage + '\n');
  
  // If we have an object to log, pretty print it
  if (obj) {
    const objStr = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2);
    console.log(objStr);
    logStream.write(objStr + '\n');
  }
}

/**
 * Create a client for the CRM database
 */
function createCrmClient() {
  console.log('Creating CRM Supabase client...');
  return createClient(CREDENTIALS.CRM_SUPABASE_URL, CREDENTIALS.CRM_SUPABASE_KEY);
}

/**
 * Create a client for the main booking database
 */
function createMainClient() {
  console.log('Creating Booking Supabase client...');
  return createClient(CREDENTIALS.SUPABASE_URL, CREDENTIALS.SUPABASE_KEY);
}

/**
 * Fetch all CRM customer mappings that have stable_hash_id
 */
async function fetchMappingsWithStableHashId() {
  log('Fetching CRM customer mappings with stable_hash_id...');
  const supabase = createMainClient();
  
  // Build the query - only get mappings with stable_hash_id
  let query = supabase
    .from('crm_customer_mapping')
    .select('*')
    .eq('is_matched', true)
    .not('stable_hash_id', 'is', null);
  
  // Add filter for specific profile if provided
  if (CONFIG.profileId) {
    query = query.eq('profile_id', CONFIG.profileId);
    log(`Filtering for specific profile: ${CONFIG.profileId}`);
  }
  
  // Add filter for specific stable hash ID if provided
  if (CONFIG.stableHashId) {
    query = query.eq('stable_hash_id', CONFIG.stableHashId);
    log(`Filtering for specific stable hash ID: ${CONFIG.stableHashId}`);
  }
  
  const { data, error } = await query;
  
  if (error) {
    log(`Error fetching CRM mappings: ${error.message}`, 'error');
    throw error;
  }
  
  log(`Found ${data.length} CRM customer mappings with stable_hash_id`);
  return data;
}

/**
 * Fetch packages for a customer using stable_hash_id from the CRM database
 * using the database function that has been fixed
 */
async function fetchPackagesByStableHashId(stableHashId) {
  log(`Fetching packages for stable_hash_id: ${stableHashId}`);
  const supabase = createCrmClient();
  
  try {
    // Call the fixed database function
    const { data: packages, error } = await supabase
      .rpc('get_packages_by_hash_id', { p_stable_hash_id: stableHashId });
    
    if (error) {
      log(`Error using database function: ${error.message}`, 'error');
      return [];
    }
    
    log(`Found ${packages.length} packages for stable_hash_id ${stableHashId}`);
    return packages;
  } catch (e) {
    log(`Exception using database function: ${e.message}`, 'error');
    return [];
  }
}

/**
 * Check if the crm_packages table needs migration and perform it if necessary
 */
async function migrateProfilePackagesTable() {
  log('Checking if crm_packages table needs schema migration...');
  const supabase = createMainClient();
  
  try {
    // First, check if the table exists at all
    const { data: tableExists, error: tableError } = await supabase
      .rpc('execute_sql', { 
        sql: `SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' 
          AND table_name = 'crm_packages'
        )` 
      });
    
    if (tableError) {
      log(`Error checking if table exists: ${tableError.message}`, 'warn');
      return false;
    }
    
    // If table doesn't exist, no migration needed (it will be created with correct schema)
    if (!tableExists || !tableExists.length || !tableExists[0].exists) {
      log('Table crm_packages does not exist yet, it will be created with the correct schema.');
      return false;
    }
    
    // Check if foreign key constraints already exist
    const { data: hasForeignKey, error: fkError } = await supabase
      .rpc('execute_sql', { 
        sql: `SELECT EXISTS (
          SELECT FROM information_schema.table_constraints
          WHERE constraint_name = 'fk_crm_packages_stable_hash_id'
          AND table_name = 'crm_packages'
        )` 
      });
    
    if (fkError) {
      log(`Error checking foreign key constraint: ${fkError.message}`, 'warn');
    } else if (hasForeignKey && hasForeignKey.length && hasForeignKey[0].exists) {
      log('Foreign key constraint already exists, no migration needed.');
      return false;
    }
    
    log('Table needs migration to update constraints...', 'warn');
    
    // Add the foreign key constraint
    const { error: alterError } = await supabase
      .rpc('execute_sql', { 
        sql: `
          ALTER TABLE crm_packages
          ADD CONSTRAINT fk_crm_packages_stable_hash_id
          FOREIGN KEY (stable_hash_id)
          REFERENCES crm_customer_mapping(stable_hash_id)
        ` 
      });
    
    if (alterError) {
      log(`Error adding foreign key constraint: ${alterError.message}`, 'error');
      return false;
    }
    
    log('Foreign key constraint added successfully');
    return true;
  } catch (e) {
    log(`Exception during migration check: ${e.message}`, 'error');
    return false;
  }
}

/**
 * Sync packages to the booking database's crm_packages table
 * using stable_hash_id as the relationship key
 */
async function syncPackagesToBookingDb(packages, mapping) {
  if (!packages || packages.length === 0) {
    log(`No packages to sync for mapping ${mapping.id}`);
    return { added: 0, updated: 0, deleted: 0, errors: 0 };
  }
  
  log(`Syncing ${packages.length} packages for stable_hash_id ${mapping.stable_hash_id}`);
  const supabase = createMainClient();
  
  let added = 0;
  let updated = 0;
  let deleted = 0;
  let errors = 0;
  
  try {
    // Step 1: First, get the count of existing packages
    const { data: existingPackages, error: countError } = await supabase
      .from('crm_packages')
      .select('id')
      .eq('stable_hash_id', mapping.stable_hash_id);
    
    if (countError) {
      log(`Error counting existing packages: ${countError.message}`, 'error');
      errors++;
    } else {
      const countToDelete = existingPackages?.length || 0;
      
      // Step 2: Delete existing packages
      const { error: deleteError } = await supabase
        .from('crm_packages')
        .delete()
        .eq('stable_hash_id', mapping.stable_hash_id);
      
      if (deleteError) {
        log(`Error deleting existing packages: ${deleteError.message}`, 'error');
        errors++;
      } else {
        deleted = countToDelete;
        log(`Deleted ${deleted} existing packages for stable_hash_id ${mapping.stable_hash_id}`);
      }
    }
    
    // Step 3: Insert all new packages
    const packagesToInsert = packages.map(pkg => ({
      // Required fields for our schema
      stable_hash_id: mapping.stable_hash_id,
      crm_package_id: pkg.crm_package_id || pkg.id,
      first_use_date: pkg.first_use_date,
      expiration_date: pkg.expiration_date,
      remaining_hours: pkg.remaining_hours,
      package_type_name: pkg.package_type_name,
      // Other fields
      customer_name: pkg.customer_name || '',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }));
    
    if (packagesToInsert.length > 0) {
      const { error: insertError } = await supabase
        .from('crm_packages')
        .insert(packagesToInsert);
      
      if (insertError) {
        log(`Error inserting new packages: ${insertError.message}`, 'error');
        errors++;
      } else {
        added = packagesToInsert.length;
        log(`Added ${added} new packages for stable_hash_id ${mapping.stable_hash_id}`);
      }
    }
    
    return { added, updated, deleted, errors };
  } catch (e) {
    log(`Exception in syncPackagesToBookingDb: ${e.message}`, 'error');
    return { added, updated, deleted, errors: errors + 1 };
  }
}

/**
 * Main function to run the package sync
 */
async function main() {
  try {
    // Log configuration
    log(`Starting package sync with configuration:`, 'info', {
      batchSize: CONFIG.batchSize,
      debugMode: CONFIG.debugMode,
      profileId: CONFIG.profileId || 'all',
      stableHashId: CONFIG.stableHashId || 'any'
    });
    
    // Check if the table needs migration and perform it if needed
    await migrateProfilePackagesTable();
    
    // Get all mappings with stable_hash_id
    const mappings = await fetchMappingsWithStableHashId();
    
    if (mappings.length === 0) {
      log('No mappings with stable_hash_id found. Run sync-customer-matching.js first to create mappings.', 'warn');
      return;
    }
    
    // Process in batches
    const BATCH_SIZE = CONFIG.batchSize;
    const batches = [];
    
    for (let i = 0; i < mappings.length; i += BATCH_SIZE) {
      batches.push(mappings.slice(i, i + BATCH_SIZE));
    }
    
    let totalPackages = 0;
    let totalAdded = 0;
    let totalUpdated = 0;
    let totalDeleted = 0;
    let totalErrors = 0;
    
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
      const batch = batches[batchIndex];
      log(`Processing batch ${batchIndex + 1} of ${batches.length}`);
      
      for (let j = 0; j < batch.length; j++) {
        const mapping = batch[j];
        log(`Processing mapping ${j + 1}/${batch.length} for stable_hash_id ${mapping.stable_hash_id}`);
        
        if (!mapping.stable_hash_id) {
          log(`Skipping mapping ${mapping.id} - no stable_hash_id present`, 'warn');
          continue;
        }
        
        // Get packages for this stable_hash_id from CRM
        const packages = await fetchPackagesByStableHashId(mapping.stable_hash_id);
        totalPackages += packages.length;
        
        // Sync packages to booking database
        if (packages.length > 0) {
          const { added, updated, deleted, errors } = await syncPackagesToBookingDb(packages, mapping);
          totalAdded += added;
          totalUpdated += updated;
          totalDeleted += deleted;
          totalErrors += errors;
          
          log(`Processed ${packages.length} packages for stable_hash_id ${mapping.stable_hash_id} (Added: ${added}, Deleted: ${deleted}, Errors: ${errors})`);
        } else {
          log(`No packages found for stable_hash_id ${mapping.stable_hash_id}`);
        }
      }
      
      // Add a small delay between batches to avoid rate limits
      if (batchIndex < batches.length - 1) {
        log(`Batch ${batchIndex + 1} complete. Taking a short break before processing the next batch...`);
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    // Log summary
    log('====== Package Sync Completed ======');
    log(`Total Mappings Processed: ${mappings.length}`);
    log(`Total Packages Found: ${totalPackages}`);
    log(`Total Packages Added: ${totalAdded}`);
    log(`Total Packages Deleted: ${totalDeleted}`);
    log(`Total Errors: ${totalErrors}`);
    
  } catch (error) {
    log(`Error in sync process: ${error.message}`, 'error');
    logStream.end();
    process.exit(1);
  } finally {
    logStream.end();
  }
}

// Run the main function
main().catch(error => {
  log(`Unhandled error: ${error.message}`, 'error');
  logStream.end();
  process.exit(1);
}); 



==== scripts\test-email-notification.js (1 lines) ====

 



==== scripts\test-google-auth.ts (70 lines) ====

/**
 * Google Authentication Test
 * 
 * This script tests whether the Google service account is properly configured
 * Use: npx ts-node scripts/test-google-auth.ts
 */

import { auth } from '../lib/googleApiConfig';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config({ path: '.env.local' });

async function testGoogleAuth() {
  console.log('=== GOOGLE AUTH TEST ===\n');
  
  try {
    console.log('Testing service account authentication...');
    
    // Attempt to get an access token from the credentials
    const client = await auth.getClient();
    const token = await client.getAccessToken();
    
    if (token && token.token) {
      console.log('âœ… Authentication successful!');
      console.log(`   Access token obtained: ${token.token.substring(0, 10)}...`);
      
      // Access token type if available
      const tokenType = token.res?.headers?.['token-type'] || 'Bearer';
      console.log(`   Token type: ${tokenType}`);
      
      console.log(`   Token expires in: ${token.res?.data?.expires_in} seconds`);
      
      // Check if service account key is properly loaded
      const decoded = Buffer.from(process.env.SERVICE_ACCOUNT_KEY_BASE64 || '', 'base64').toString('utf8');
      const credentials = JSON.parse(decoded);
      
      console.log('\nService Account Details:');
      console.log(`   Client Email: ${credentials.client_email}`);
      console.log(`   Project ID: ${credentials.project_id}`);
      
      return true;
    } else {
      console.log('âŒ Authentication failed: No token received');
      return false;
    }
  } catch (error: any) {
    console.log('âŒ Authentication failed with error:');
    console.log(`   Error message: ${error.message}`);
    
    if (error.response) {
      console.log(`   Status: ${error.response.status}`);
      console.log(`   Status Text: ${error.response.statusText}`);
      console.log(`   Error Details:`, error.response.data?.error || {});
    }
    
    return false;
  }
}

// Run the test
testGoogleAuth()
  .then((success) => {
    console.log('\nGoogle authentication test completed');
    process.exit(success ? 0 : 1);
  })
  .catch((error) => {
    console.error('Error running authentication test:', error);
    process.exit(1);
  }); 



==== scripts\test-line-notification.js (100 lines) ====

#!/usr/bin/env node

/**
 * Script to test sending a LINE notification directly
 * 
 * Usage:
 *   node scripts/test-line-notification.js
 */

const fetch = require('node-fetch');

// Configuration
const LINE_MESSAGING_API = 'https://api.line.me/v2/bot/message/push';
const LINE_CHANNEL_ACCESS_TOKEN = 'YOUR_LINE_CHANNEL_ACCESS_TOKEN'; // Replace with actual token

// Test recipient
const TEST_USER_ID = 'Uf4177a1781df7fd215e6d2749fd00296';
const TEST_NAME = 'Test User';
const REVIEW_URL = 'https://g.page/r/CXwvpW56UsBgEAE/review';
const VOUCHER_IMAGE_URL = 'https://www.len.golf/wp-content/uploads/2024/06/Logo.png';

async function sendTestLineMessage() {
  console.log(`Sending test LINE message to ${TEST_USER_ID}...`);
  
  try {
    // Build LINE message
    const message = {
      to: TEST_USER_ID,
      messages: [
        {
          type: 'text',
          text: `Thank you for visiting LENGOLF, ${TEST_NAME}! We hope you enjoyed your golf session. ðŸŒï¸â€â™‚ï¸`
        },
        {
          type: 'text',
          text: 'Your feedback is important to us! Please consider leaving us a Google review and receive a special thank you offer: 1 FREE HOUR + 1 FREE SOFT DRINK on your next visit!'
        },
        {
          type: 'template',
          altText: 'Leave a Google Review for LENGOLF - Get 1 FREE HOUR + FREE DRINK',
          template: {
            type: 'buttons',
            thumbnailImageUrl: VOUCHER_IMAGE_URL,
            imageAspectRatio: 'rectangle',
            imageSize: 'cover',
            title: 'LENGOLF Special Offer',
            text: '1 FREE HOUR + FREE DRINK on your next visit!',
            actions: [
              {
                type: 'uri',
                label: 'Write a Review',
                uri: REVIEW_URL
              }
            ]
          }
        },
        {
          type: 'text',
          text: 'To redeem your offer, please show both your Google review and this LINE message during your next visit. Thank you!'
        }
      ]
    };

    // Send LINE message
    const response = await fetch(LINE_MESSAGING_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${LINE_CHANNEL_ACCESS_TOKEN}`
      },
      body: JSON.stringify(message)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`LINE API error: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const responseData = await response.json();
    
    console.log('âœ… LINE message sent successfully!');
    console.log('Response:', responseData);
    
    return responseData;
  } catch (error) {
    console.error('Error sending LINE message:', error);
    throw error;
  }
}

// Execute the function
sendTestLineMessage()
  .then(() => {
    console.log('Script completed successfully');
    process.exit(0);
  })
  .catch(error => {
    console.error('Script failed:', error);
    process.exit(1);
  }); 



==== scripts\test-process-reviews.js (159 lines) ====

#!/usr/bin/env node

/**
 * Script to test the process-review-requests endpoint with detailed logging
 * 
 * Usage:
 *   CRON_API_KEY=your_api_key node scripts/test-process-reviews.js
 */

const fetch = require('node-fetch');
const fs = require('fs');
const path = require('path');

// Configuration
const API_URL = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
const CRON_API_KEY = process.env.CRON_API_KEY || '2f93c28600516c88c346b197246515c6ce9b82aade54311a75031578bc75da42';
const LOG_FILE = path.join(__dirname, 'process-reviews-test.log');

if (!CRON_API_KEY) {
  console.error('Error: CRON_API_KEY environment variable is not set and no default provided');
  process.exit(1);
}

// Function to log to both console and file
function log(message, isError = false) {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ${message}`;
  
  if (isError) {
    console.error(logMessage);
  } else {
    console.log(logMessage);
  }
  
  // Also log to file
  fs.appendFileSync(LOG_FILE, logMessage + '\n');
}

async function processReviewRequests() {
  log('--- Starting test of process-review-requests endpoint ---');
  log(`API URL: ${API_URL}`);
  log(`API Key: ${CRON_API_KEY.substring(0, 5)}...${CRON_API_KEY.substring(CRON_API_KEY.length - 5)}`);
  
  try {
    // First make a request without the Authorization header to test auth
    log('Testing authentication - making request without auth header...');
    try {
      const noAuthResponse = await fetch(`${API_URL}/api/notifications/process-review-requests`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      const noAuthResult = await noAuthResponse.json();
      
      if (noAuthResponse.status === 401) {
        log('âœ… Authentication check passed - received 401 without auth header');
      } else {
        log(`âŒ Authentication check failed - expected 401 but got ${noAuthResponse.status}`, true);
        log(`Response: ${JSON.stringify(noAuthResult)}`, true);
      }
    } catch (noAuthError) {
      log(`Error in no-auth test: ${noAuthError.message}`, true);
    }
    
    // Make the actual request with auth
    log('Making request with authorization...');
    const fullUrl = `${API_URL}/api/notifications/process-review-requests`;
    log(`Full URL: ${fullUrl}`);
    
    const response = await fetch(fullUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${CRON_API_KEY}`
      }
    });
    
    log(`Response status: ${response.status} ${response.statusText}`);
    
    // Log the response headers
    const headers = {};
    response.headers.forEach((value, name) => {
      headers[name] = value;
    });
    log(`Response headers: ${JSON.stringify(headers)}`);
    
    // Get the response body
    const responseText = await response.text();
    log(`Response body (raw): ${responseText}`);
    
    let result;
    try {
      result = JSON.parse(responseText);
      log(`Response parsed: ${JSON.stringify(result, null, 2)}`);
    } catch (parseError) {
      log(`Failed to parse response as JSON: ${parseError.message}`, true);
      log('Response was not valid JSON', true);
    }
    
    if (!response.ok) {
      log(`Error from API: ${result?.error || response.statusText}`, true);
      if (result?.details) {
        log(`Details: ${JSON.stringify(result.details)}`, true);
      }
    } else {
      log('âœ… Request successful');
      
      if (result?.processed === 0) {
        log('No pending review requests to process');
      } else {
        log(`Processed ${result?.processed} review requests`);
        log(`  âœ… Successful: ${result?.successful}`);
        log(`  âŒ Failed: ${result?.failed}`);
        
        if (result?.failed > 0) {
          log('Failed requests:');
          result.results
            .filter(r => !r.success)
            .forEach(r => {
              log(`  - ID ${r.id}: ${r.error}`, true);
            });
        }
        
        if (result?.successful > 0) {
          log('Successful requests:');
          result.results
            .filter(r => r.success)
            .forEach(r => {
              log(`  - ID ${r.id} (${r.provider}): ${r.contact_info}`);
            });
        }
      }
    }
    
    log('--- Test completed ---');
    
    return result;
  } catch (error) {
    log(`Execution error: ${error.message}`, true);
    if (error.stack) {
      log(`Stack trace: ${error.stack}`, true);
    }
    log('--- Test failed ---', true);
    throw error;
  }
}

// Execute the function
processReviewRequests()
  .then(() => {
    log('Script completed successfully');
    process.exit(0);
  })
  .catch(error => {
    log(`Script failed: ${error.message}`, true);
    process.exit(1);
  }); 



==== tailwind.config.ts (28 lines) ====

import type { Config } from "tailwindcss";

export default {
  content: [
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./lib/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: "var(--primary-color)",
        neutral: "var(--neutral-color)",
        accent: "var(--accent-color)",
        background: "var(--background-color)",
        foreground: "var(--foreground-color)",
        "footer-bg": "var(--footer-bg-color)",
        "footer-heading": "var(--footer-heading-color)",
        "footer-text": "var(--footer-text-color)",
      },
      fontFamily: {
        sans: ['var(--font-poppins)', 'system-ui', 'sans-serif'],
      },
    },
  },
  plugins: [],
} satisfies Config;




==== types\env.d.ts (10 lines) ====

declare namespace NodeJS {
  interface ProcessEnv {
    NEXT_PUBLIC_SUPABASE_URL: string;
    NEXT_PUBLIC_SUPABASE_ANON_KEY: string;
    NEXT_PUBLIC_SITE_URL: string;
    NEXT_PUBLIC_GOOGLE_CLIENT_ID: string;
    NEXT_PUBLIC_FACEBOOK_CLIENT_ID: string;
    NEXT_PUBLIC_LINE_CLIENT_ID: string;
  }
} 



==== types\index.ts (8 lines) ====

export type BookingFormData = {
  bay_number: number;
  date: Date;
  start_time: string;
  duration: number;
};

export type { Booking } from './supabase'; 



==== types\next-auth.d.ts (15 lines) ====

import 'next-auth';

declare module 'next-auth' {
  interface Session {
    user: {
      id: string;
      name?: string | null;
      email?: string | null;
      image?: string | null;
      provider?: string;
      phone?: string | null;
    }
    accessToken?: string;
  }
} 



==== types\supabase.ts (150 lines) ====

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Booking = Database['public']['Tables']['bookings']['Row'];
export type Profile = Database['public']['Tables']['profiles']['Row'];
export type CrmCustomerMapping = Database['public']['Tables']['crm_customer_mapping']['Row'];

export interface Database {
  public: {
    Tables: {
      profiles: {
        Row: {
          id: string
          line_id: string | null
          display_name: string | null
          name: string | null
          email: string | null
          phone_number: string | null
          picture_url: string | null
          provider: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          line_id?: string | null
          display_name?: string | null
          name?: string | null
          email?: string | null
          phone_number?: string | null
          picture_url?: string | null
          provider?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          line_id?: string | null
          display_name?: string | null
          name?: string | null
          email?: string | null
          phone_number?: string | null
          picture_url?: string | null
          provider?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      bookings: {
        Row: {
          id: string
          user_id: string
          name: string
          email: string
          phone_number: string
          date: string
          start_time: string
          duration: number
          number_of_people: number
          bay: string | null
          status: 'confirmed' | 'cancelled'
          calendar_event_id?: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          user_id: string
          name: string
          email: string
          phone_number: string
          date: string
          start_time: string
          duration: number
          number_of_people: number
          bay?: string | null
          status?: 'confirmed' | 'cancelled'
          calendar_event_id?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          user_id?: string
          name?: string
          email?: string
          phone_number?: string
          date?: string
          start_time?: string
          duration?: number
          number_of_people?: number
          bay?: string | null
          status?: 'confirmed' | 'cancelled'
          calendar_event_id?: string | null
          created_at?: string
          updated_at?: string
        }
      }
      crm_customer_mapping: {
        Row: {
          id: string
          profile_id: string
          crm_customer_id: string
          crm_customer_data: Json
          is_matched: boolean
          match_method: 'auto' | 'manual'
          match_confidence: number
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          profile_id: string
          crm_customer_id: string
          crm_customer_data?: Json
          is_matched?: boolean
          match_method?: 'auto' | 'manual'
          match_confidence?: number
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          profile_id?: string
          crm_customer_id?: string
          crm_customer_data?: Json
          is_matched?: boolean
          match_method?: 'auto' | 'manual'
          match_confidence?: number
          created_at?: string
          updated_at?: string
        }
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
  }
} 



==== utils\booking-formatter.ts (123 lines) ====

import { format } from 'date-fns';

interface Booking {
  id: string;
  name: string;
  email: string;
  phone_number: string;
  date: string;
  start_time: string;
  duration: number;
  number_of_people: number;
  user_id?: string;
  package_info?: string;
}

interface CrmData {
  id?: string;
  name?: string;
  [key: string]: any;
}

interface BayInfo {
  id: string;
  displayName?: string;
}

interface BookingDataParams {
  booking: Booking;
  crmData?: CrmData | null;
  bayInfo: BayInfo;
}

export function formatBookingData({
  booking,
  crmData,
  bayInfo
}: BookingDataParams) {
  // Log the input data for debugging
  console.log(`formatBookingData - Input:`, {
    bookingName: booking.name,
    crmDataName: crmData?.name,
    hasCrmData: !!crmData
  });
  
  // Determine customer name
  const customerName = crmData?.name || booking.name;
  console.log(`formatBookingData - Using customer name: "${customerName}"`);
  
  // Calculate end time
  const endTime = calculateEndTime(booking.start_time, booking.duration);
  
  // Format date
  const formattedDate = format(new Date(booking.date), 'MMMM d, yyyy');
  
  // Create standardized booking data for all services
  return {
    // Common fields for all services
    bookingId: booking.id,
    customerName: customerName,
    email: booking.email,
    phoneNumber: booking.phone_number,
    
    // Format dates and times consistently
    date: booking.date,
    formattedDate: formattedDate,
    startTime: booking.start_time,
    endTime: endTime,
    
    // Bay information
    bayId: bayInfo.id,
    bayName: bayInfo.displayName || bayInfo.id,
    
    // User and CRM data
    userId: booking.user_id,
    crmCustomerId: crmData?.id,
    isNewCustomer: !crmData?.id,
    
    // Additional booking details
    duration: booking.duration,
    numberOfPeople: booking.number_of_people,
    
    // Service-specific formatted data
    calendar: {
      summary: `${crmData?.name || booking.name} (${booking.phone_number}) (${booking.number_of_people}) at ${bayInfo.displayName || bayInfo.id}`,
      description: generateCalendarDescription(booking, bayInfo, crmData)
    },
    emailData: {
      userDisplayName: customerName,
      subject: `Your LENGOLF Booking Confirmation - ${formattedDate}`
    },
    lineNotification: {
      bookingName: booking.name,
      customerLabel: crmData?.id ? (crmData?.name || booking.name) : "New Customer"
    }
  };
}

// Helper to calculate end time from start time and duration
function calculateEndTime(startTime: string, duration: number): string {
  const [hours, minutes] = startTime.split(':').map(Number);
  const totalMinutes = hours * 60 + minutes + duration * 60;
  const endHours = Math.floor(totalMinutes / 60) % 24;
  const endMinutes = totalMinutes % 60;
  return `${endHours.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;
}

// Helper to generate a consistent calendar description
function generateCalendarDescription(
  booking: Booking, 
  bayInfo: BayInfo, 
  crmData?: CrmData | null
): string {
  return `Customer Name: ${crmData?.name || booking.name}
Contact: ${booking.phone_number}
Email: ${booking.email}
Type: ${booking.package_info || 'Normal Bay Rate'}
Pax: ${booking.number_of_people}
Bay: ${bayInfo.displayName || bayInfo.id}
Date: ${format(new Date(booking.date), 'EEEE, MMMM d')}
Time: ${booking.start_time} - ${calculateEndTime(booking.start_time, booking.duration)}
Via: Website
Booking ID: ${booking.id}`;
} 



==== utils\customer-matching.ts (685 lines) ====

import { createCrmClient } from './supabase/crm';
import { createServerClient } from './supabase/server';
import { syncPackagesForProfile } from './supabase/crm-packages';
import type { Database } from '@/types/supabase';

// Types
export interface CrmCustomer {
  id: string;
  name: string; // This will store customer_name from CRM
  email?: string;
  phone_number?: string;
  stable_hash_id?: string;
  additional_data: Record<string, any>;
  // Add customer_name as an alias for compatibility
  customer_name?: string;
}

export interface Profile {
  id: string;
  name?: string;
  email?: string;
  phone_number?: string;
  display_name?: string;
}

export interface MatchResult {
  matched: boolean;
  confidence: number;
  crmCustomerId?: string;
  reasons?: string[];
}

export interface CrmCustomerMapping {
  id: string;
  profile_id: string;
  crm_customer_id: string;
  crm_customer_data: CrmCustomer;
  is_matched: boolean;
  match_method: string;
  match_confidence: number;
  created_at: string;
  updated_at: string;
  stable_hash_id?: string;
}

// Configuration for matching
const CONFIG = {
  confidenceThreshold: 0.6,
  maxPhoneEditDistance: 3
};

/**
 * Calculate Levenshtein distance between two strings
 * @param a - First string
 * @param b - Second string
 * @returns The edit distance between the strings
 */
function levenshteinDistance(a: string, b: string): number {
  if (!a || !b) return 0;
  
  const matrix: number[][] = [];
  
  // Initialize the matrix
  for (let i = 0; i <= a.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= b.length; j++) {
    matrix[0][j] = j;
  }
  
  // Fill the matrix
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,      // deletion
        matrix[i][j - 1] + 1,      // insertion
        matrix[i - 1][j - 1] + cost // substitution
      );
    }
  }
  
  return matrix[a.length][b.length];
}

/**
 * Calculate similarity score between two phone numbers
 * @param phone1 - First phone number
 * @param phone2 - Second phone number
 * @returns Similarity score between 0 and 1
 */
function phoneNumberSimilarity(phone1: string, phone2: string): number {
  if (!phone1 || !phone2) return 0;
  
  // For very short numbers, require exact match
  if (phone1.length < 8 || phone2.length < 8) {
    return phone1 === phone2 ? 1 : 0;
  }
  
  // Calculate edit distance
  const distance = levenshteinDistance(phone1, phone2);
  
  // Calculate similarity score
  // For longer phone numbers, we allow more differences
  const maxLength = Math.max(phone1.length, phone2.length);
  const similarityThreshold = Math.min(CONFIG.maxPhoneEditDistance, Math.floor(maxLength * 0.2)); 
  
  let similarity = 0;
  if (distance === 0) {
    similarity = 1; // Exact match
  } else if (distance === 1) {
    similarity = 0.9; // Off by just one digit
  } else if (distance === 2) {
    similarity = 0.8; // Off by two digits
  } else if (distance <= similarityThreshold) {
    similarity = 0.7; // Similar enough but not very close
  }
  
  // Only log phone comparisons in debug mode and when there's an actual match
  if (process.env.DEBUG_PHONE_COMPARISON === 'true' && similarity > 0) {
    console.log(`Phone comparison: '${phone1}' vs '${phone2}' - distance: ${distance}, similarity: ${similarity.toFixed(2)}`);
  }
  
  return similarity;
}

/**
 * Extract first and last name from display name
 */
function extractNameParts(displayName?: string) {
  if (!displayName) return { first: '', last: '' };
  
  const parts = displayName.split(' ').filter(Boolean);
  if (parts.length === 0) return { first: '', last: '' };
  if (parts.length === 1) return { first: parts[0], last: '' };
  
  return {
    first: parts[0],
    last: parts.slice(1).join(' ')
  };
}

/**
 * Normalize phone number for comparison
 */
function normalizePhoneNumber(phone?: string): string {
  if (!phone) return '';
  
  // Convert to string if not already
  phone = String(phone);
  
  // Remove all non-digit characters
  let normalized = phone.replace(/\D/g, '');
  
  // For Thai mobile numbers, if it starts with '0', convert to '+66'
  if (normalized.startsWith('0')) {
    normalized = normalized.substring(1);
  }
  
  // For international format, if it starts with country code, extract the last 9 digits
  if (normalized.startsWith('66') || normalized.startsWith('661')) {
    normalized = normalized.substring(2);
  }
  
  // For international format without +, if it starts with other country codes
  if (normalized.length > 9 && !normalized.startsWith('66')) {
    // Extract the last 9 digits for comparison
    normalized = normalized.substring(normalized.length - 9);
  }
  
  // Try to consistently extract the last N digits for comparison
  // This helps match numbers that might be formatted differently but are actually the same
  if (normalized.length > 8) {
    // Keep the last 9 digits for consistency when comparing
    normalized = normalized.substring(Math.max(0, normalized.length - 9));
  }
  
  return normalized;
}

/**
 * Normalize text for comparison
 */
function normalizeText(text?: string): string {
  if (!text) return '';
  return String(text).toLowerCase().trim();
}

/**
 * Calculate match confidence between a profile and a CRM customer
 * Direct port of the matching logic from sync-customer-matching.js
 */
function calculateMatchConfidence(profile: Profile, customer: CrmCustomer): { confidence: number; reasons: string[] } {
  let score = 0;
  const reasons: string[] = [];
  
  // Extract name parts
  const profileNameParts = extractNameParts(profile.display_name || profile.name);
  const customerNameParts = extractNameParts(customer.name);
  
  // Normalize the profile data for comparison
  const normalizedProfilePhone = normalizePhoneNumber(profile.phone_number);
  const normalizedProfileFirstName = normalizeText(profileNameParts.first);
  const normalizedProfileLastName = normalizeText(profileNameParts.last);
  const normalizedProfileEmail = normalizeText(profile.email);
  
  // Normalize the customer data for comparison
  const normalizedCustomerPhone = normalizePhoneNumber(customer.phone_number);
  const normalizedCustomerFirstName = normalizeText(customerNameParts.first);
  const normalizedCustomerLastName = normalizeText(customerNameParts.last);
  const normalizedCustomerEmail = normalizeText(customer.email);
  
  // Phone number matching with improved fuzzy matching
  if (normalizedProfilePhone && normalizedCustomerPhone) {
    // Calculate phone similarity score
    const phoneSimilarity = phoneNumberSimilarity(normalizedProfilePhone, normalizedCustomerPhone);
    
    if (phoneSimilarity === 1) {
      score += 0.7; // Exact match
      reasons.push('exact_phone_match');
    } else if (phoneSimilarity >= 0.9) {
      score += 0.6; // Off by just one digit
      reasons.push('very_similar_phone_match');
    } else if (phoneSimilarity >= 0.8) {
      score += 0.5; // Off by two digits
      reasons.push('similar_phone_match');
    } else if (phoneSimilarity >= 0.7) {
      score += 0.3; // Similar enough
      reasons.push('partial_phone_match');
    } else if (normalizedProfilePhone.includes(normalizedCustomerPhone) || 
              normalizedCustomerPhone.includes(normalizedProfilePhone)) {
      score += 0.2;
      reasons.push('substring_phone_match');
    }
  }
  
  // Name matching
  if (normalizedProfileFirstName && normalizedCustomerFirstName) {
    if (normalizedProfileFirstName === normalizedCustomerFirstName) {
      score += 0.5;
      reasons.push('exact_first_name_match');
    } else if (normalizedProfileFirstName.includes(normalizedCustomerFirstName) || 
              normalizedCustomerFirstName.includes(normalizedProfileFirstName)) {
      score += 0.2;
      reasons.push('partial_first_name_match');
    }
  }
  
  if (normalizedProfileLastName && normalizedCustomerLastName) {
    if (normalizedProfileLastName === normalizedCustomerLastName) {
      score += 0.5;
      reasons.push('exact_last_name_match');
    } else if (normalizedProfileLastName.includes(normalizedCustomerLastName) || 
              normalizedCustomerLastName.includes(normalizedProfileLastName)) {
      score += 0.2;
      reasons.push('partial_last_name_match');
    }
  }
  
  // Email matching (exact match only)
  if (normalizedProfileEmail && normalizedCustomerEmail && 
      normalizedProfileEmail === normalizedCustomerEmail) {
    score += 0.5;
    reasons.push('exact_email_match');
  }
  
  // Cap the score at 1.0
  score = Math.min(score, 1.0);
  
  return { confidence: score, reasons };
}

/**
 * Match a profile with CRM customers
 * This is the main function that should be called when a user logs in or makes a booking
 * Uses the exact same logic as the sync script
 */
export async function matchProfileWithCrm(profileId: string): Promise<MatchResult | null> {
  try {
    // Get the profile details
    const supabase = createServerClient();
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', profileId)
      .single();
    
    if (profileError || !profile) {
      console.error('Error fetching profile:', profileError);
      return null;
    }
    
    // Skip profiles without any matching data
    if (!profile.phone_number && !profile.email && !profile.name && !profile.display_name) {
      console.log(`Profile ${profileId} has no data for matching`);
      return null;
    }
    
    // Fetch CRM customers
    const crmSupabase = createCrmClient();
    const { data: customers, error: customersError } = await crmSupabase
      .from('customers')
      .select('*');
    
    if (customersError) {
      console.error('Error fetching CRM customers:', customersError);
      return null;
    }
    
    // Find potential matches
    let bestMatch: { customer: CrmCustomer; confidence: number; reasons: string[] } | null = null;
    
    for (const rawCustomer of customers) {
      // Transform raw customer data to our CrmCustomer type
      const customer: CrmCustomer = {
        id: String(rawCustomer.id),
        name: String(rawCustomer.customer_name || ''),
        customer_name: String(rawCustomer.customer_name || ''), // Add this for compatibility
        email: rawCustomer.email,
        phone_number: rawCustomer.contact_number,
        stable_hash_id: rawCustomer.stable_hash_id,
        additional_data: rawCustomer // Store all raw data
      };
      
      const matchResult = calculateMatchConfidence(profile, customer);
      
      if (!bestMatch || matchResult.confidence > bestMatch.confidence) {
        bestMatch = {
          customer,
          ...matchResult
        };
      }
    }
    
    if (!bestMatch) {
      return {
        matched: false,
        confidence: 0
      };
    }
    
    // Apply match boosting for high-quality but borderline matches
    const originalConfidence = bestMatch.confidence;
    let isHighConfidence = originalConfidence >= CONFIG.confidenceThreshold;

    // If we have a phone match that's close to threshold, boost it 
    if (!isHighConfidence && 
        bestMatch.confidence >= CONFIG.confidenceThreshold - 0.1 && 
        (bestMatch.reasons.includes('exact_phone_match') || 
         bestMatch.reasons.includes('very_similar_phone_match'))) {
      
      // Boost the confidence score to meet the threshold
      bestMatch.confidence = CONFIG.confidenceThreshold;
      bestMatch.reasons.push('boosted_phone_match');
      
      console.log(`Boosted match confidence from ${originalConfidence.toFixed(2)} to ${bestMatch.confidence.toFixed(2)} based on phone match`);
      
      // Now this match will be considered high confidence
      isHighConfidence = true;
    }
    
    // Store the mapping if confidence is high enough
    if (isHighConfidence) {
      const now = new Date().toISOString();

      // Create a descriptive match method based on the reasons
      let matchMethod = 'sync_script';
      if (bestMatch.reasons.length > 0) {
        // Add the primary match reason
        if (bestMatch.reasons.includes('exact_phone_match')) {
          matchMethod += '_phone';
        } else if (bestMatch.reasons.includes('exact_email_match')) {
          matchMethod += '_email';
        } else if (bestMatch.reasons.includes('exact_first_name_match') && bestMatch.reasons.includes('exact_last_name_match')) {
          matchMethod += '_full_name';
        } else if (bestMatch.reasons.includes('exact_first_name_match')) {
          matchMethod += '_first_name';
        }
      }
      
      try {
        // Prepare the mapping data
        const mappingData = {
          profile_id: profileId,
          crm_customer_id: bestMatch.customer.id,
          crm_customer_data: {
            ...bestMatch.customer,
            // Ensure both name and customer_name are set for compatibility
            name: bestMatch.customer.name || bestMatch.customer.customer_name,
            customer_name: bestMatch.customer.customer_name || bestMatch.customer.name
          },
          is_matched: true,
          match_method: matchMethod,
          match_confidence: bestMatch.confidence,
          stable_hash_id: bestMatch.customer.stable_hash_id,
          created_at: now,
          updated_at: now
        };
        
        console.log(`Saving CRM mapping for profile ${profileId}:`, JSON.stringify(mappingData, null, 2));
        
        // Now use PostgreSQL's efficient upsert functionality
        const { data: upsertResult, error: upsertError } = await supabase
          .from('crm_customer_mapping')
          .upsert(mappingData, {
            onConflict: 'profile_id' // Using the new unique constraint
          });
          
        if (upsertError) {
          console.error('Failed to save CRM mapping to database:', upsertError);
          throw upsertError;
        } else {
          console.log(`Successfully saved CRM mapping for profile ${profileId} to customer ${bestMatch.customer.id}`);
        }
        
        // Quick verify the mapping exists now (optional, can be removed for production)
        const { data: verifyMapping, error: verifyError } = await supabase
          .from('crm_customer_mapping')
          .select('id, crm_customer_id')
          .eq('profile_id', profileId)
          .maybeSingle();
          
        if (verifyError || !verifyMapping) {
          console.warn('Verification check for mapping failed, but upsert reported success');
        } else {
          console.log(`Verified mapping saved successfully: ${verifyMapping.id}`);
        }
      } catch (error) {
        console.error('Error managing CRM mappings:', error);
        // Re-throw the error so it's not silently caught
        throw error;
      }

      // After successful matching, sync packages
      await syncPackagesForProfile(profileId).catch(err => {
        // Log but don't fail the matching process
        console.error('Error syncing packages after match:', err);
      });
    }
    
    return {
      matched: isHighConfidence,
      confidence: bestMatch.confidence,
      crmCustomerId: bestMatch.customer.id,
      reasons: bestMatch.reasons
    };
    
  } catch (error) {
    console.error('Error matching profile with CRM:', error);
    return null;
  }
}

/**
 * Normalize CRM customer data to ensure both name and customer_name are set
 * This helps maintain compatibility between different data formats
 */
export function normalizeCrmCustomerData(customerData: any): CrmCustomer | null {
  if (!customerData) return null;
  
  // Create a normalized copy
  const normalized: CrmCustomer = {
    ...customerData,
    id: String(customerData.id || ''),
    additional_data: customerData.additional_data || customerData
  };
  
  // Ensure both name and customer_name are set
  normalized.name = customerData.name || customerData.customer_name || '';
  normalized.customer_name = customerData.customer_name || customerData.name || '';
  
  return normalized;
}

/**
 * Get the CRM customer mapped to a profile
 */
export async function getCrmCustomerForProfile(profileId: string): Promise<CrmCustomer | null> {
  const supabase = createServerClient();
  
  const { data, error } = await supabase
    .from('crm_customer_mapping')
    .select('*')
    .eq('profile_id', profileId)
    .eq('is_matched', true)
    .order('updated_at', { ascending: false })
    .limit(1)
    .single();
  
  if (error || !data) {
    return null;
  }
  
  // Normalize the data before returning
  return normalizeCrmCustomerData(data.crm_customer_data);
}

/**
 * Efficiently retrieve or create a CRM mapping for a profile.
 * First checks for existing mapping, then attempts matching only if needed.
 * This approach is optimized for performance in user-facing operations.
 * 
 * @param profileId The profile ID to find or create mapping for
 * @param options Configuration options
 * @returns CRM mapping data or null if unavailable
 */
export async function getOrCreateCrmMapping(
  profileId: string,
  options: {
    source?: string,
    timeoutMs?: number,
    forceRefresh?: boolean
  } = {}
): Promise<{
  profileId: string,
  crmCustomerId: string,
  stableHashId: string,
  confidence: number,
  isNewMatch: boolean
} | null> {
  const {
    source = 'unknown',
    timeoutMs = 5000,
    forceRefresh = false
  } = options;

  try {
    const supabase = createServerClient();
    
    console.log(`[CRM Mapping] Starting for profile ${profileId} (source: ${source})`);
    
    // STEP 1: Check for existing mapping (fast path)
    if (!forceRefresh) {
      // Modified query to handle multiple mappings - get all matches and sort by confidence
      const { data: mappings, error: mappingError } = await supabase
        .from('crm_customer_mapping')
        .select('profile_id, crm_customer_id, stable_hash_id, match_confidence, match_method, updated_at')
        .eq('profile_id', profileId)
        .eq('is_matched', true)
        .order('match_confidence', { ascending: false }) // Highest confidence first
        .order('updated_at', { ascending: false }); // Most recent first
        
      if (mappingError) {
        console.error('Error checking for existing mappings:', mappingError);
      } else if (mappings && mappings.length > 0) {
        // Use the first mapping (highest confidence, most recent)
        const bestMapping = mappings[0];
        
        console.log(`[CRM Mapping] Found existing mapping for profile ${profileId}:`, {
          crmCustomerId: bestMapping.crm_customer_id,
          stableHashId: bestMapping.stable_hash_id,
          confidence: bestMapping.match_confidence
        });
        
        // Sync packages asynchronously without awaiting to keep operations fast
        syncPackagesForProfile(profileId).catch(err => {
          console.warn('Failed to sync packages for existing mapping:', err);
        });
        
        return {
          profileId,
          crmCustomerId: bestMapping.crm_customer_id,
          stableHashId: bestMapping.stable_hash_id,
          confidence: bestMapping.match_confidence,
          isNewMatch: false
        };
      } else {
        console.log(`[CRM Mapping] No existing mapping found for profile ${profileId}`);
      }
    }
    
    // STEP 2: Attempt a match with timeout (slower path)
    const timeoutPromise = new Promise<null>((_, reject) => {
      setTimeout(() => reject(new Error(`CRM matching timed out after ${timeoutMs}ms`)), timeoutMs);
    });
    
    try {
      // Race the matching process against the timeout
      const matchResult = await Promise.race([
        matchProfileWithCrm(profileId),
        timeoutPromise
      ]);
      
      if (matchResult?.matched) {
        console.log('Successfully matched profile with CRM', {
          profileId,
          crmCustomerId: matchResult.crmCustomerId,
          confidence: matchResult.confidence,
          reasons: matchResult.reasons
        });
        
        // Give the database a moment to complete any ongoing writes
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Retrieve the mapping data
        const { data: newMapping, error: mappingError } = await supabase
          .from('crm_customer_mapping')
          .select('stable_hash_id, crm_customer_id, match_confidence')
          .eq('profile_id', profileId)
          .maybeSingle();
          
        if (mappingError) {
          console.error('Error retrieving mapping after match:', mappingError);
        } else if (!newMapping) {
          console.warn('Mapping not found after successful match');
        } else {
          console.log('Retrieved mapping details', {
            profileId,
            crmCustomerId: newMapping.crm_customer_id,
            stableHashId: newMapping.stable_hash_id
          });
        }
        
        // Return the mapping information
        return {
          profileId,
          crmCustomerId: matchResult.crmCustomerId || '',
          stableHashId: newMapping?.stable_hash_id || '',
          confidence: matchResult.confidence,
          isNewMatch: true
        };
      } else {
        console.log('Profile could not be matched with CRM', {
          profileId,
          confidence: matchResult?.confidence || 0,
          reasons: matchResult?.reasons || []
        });
      }
    } catch (error) {
      // Improved error handling - check for constraint and timeout errors
      console.warn('Error during CRM matching', {
        error: error instanceof Error 
          ? { message: error.message, stack: error.stack, code: (error as any).code }
          : error,
        profileId
      });
      
      // Always check if a mapping exists, regardless of the error type
      try {
        // Short delay to let any pending database operations complete
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Check for an existing mapping
        const { data: existingMapping } = await supabase
          .from('crm_customer_mapping')
          .select('stable_hash_id, crm_customer_id, match_confidence')
          .eq('profile_id', profileId)
          .maybeSingle();
          
        if (existingMapping) {
          console.info('Found existing mapping despite matching error', {
            profileId,
            crmCustomerId: existingMapping.crm_customer_id,
            stableHashId: existingMapping.stable_hash_id
          });
          
          return {
            profileId,
            crmCustomerId: existingMapping.crm_customer_id,
            stableHashId: existingMapping.stable_hash_id || '',
            confidence: existingMapping.match_confidence,
            isNewMatch: false
          };
        } else {
          console.warn('No mapping found after error recovery attempt');
        }
      } catch (recoveryError) {
        console.error('Error in recovery attempt', {
          error: recoveryError,
          profileId
        });
      }
    }
    
    return null;
  } catch (error) {
    console.error('Unexpected error in getOrCreateCrmMapping', {
      error: error instanceof Error 
        ? { message: error.message, stack: error.stack }
        : error
    });
    return null;
  }
} 



==== utils\date.ts (30 lines) ====

import { formatInTimeZone, zonedTimeToUtc, utcToZonedTime } from 'date-fns-tz';

export const TIMEZONE = 'Asia/Bangkok';

/**
 * Gets the current time in Bangkok timezone
 * @returns ISO string of current time in Bangkok timezone
 */
export function getCurrentBangkokTime(): Date {
  return utcToZonedTime(new Date(), TIMEZONE);
}

/**
 * Formats a date in Bangkok timezone
 * @param date Date to format
 * @param format Format string to use
 * @returns Formatted date string in Bangkok timezone
 */
export function formatBangkokTime(date: Date | string, format: string): string {
  return formatInTimeZone(new Date(date), TIMEZONE, format);
}

/**
 * Converts a date to Bangkok timezone
 * @param date Date to convert
 * @returns Date object in Bangkok timezone
 */
export function toBangkokTime(date: Date | string): Date {
  return zonedTimeToUtc(new Date(date), TIMEZONE);
} 



==== utils\gtm.ts (47 lines) ====

/**
 * Google Tag Manager (GTM) utilities
 */

interface UserProfileData {
  profileId: string | null;
  stableHashId: string | null;
  customerID?: string | null;
}

/**
 * Push user profile data to the GTM data layer
 * @param profileData - User profile data to push to the data layer
 */
export function pushProfileDataToGtm(profileData: UserProfileData): void {
  if (typeof window === 'undefined') return;
  
  window.dataLayer = window.dataLayer || [];
  window.dataLayer.push({
    event: 'userProfileAvailable',
    profileId: profileData.profileId,
    stableHashId: profileData.stableHashId,
    customerID: profileData.customerID || null  // For backward compatibility
  });
}

/**
 * Push a generic event to the GTM data layer
 * @param eventName - Name of the event to push
 * @param eventData - Additional data to include with the event
 */
export function pushEventToGtm(eventName: string, eventData?: Record<string, any>): void {
  if (typeof window === 'undefined') return;
  
  window.dataLayer = window.dataLayer || [];
  window.dataLayer.push({
    event: eventName,
    ...eventData
  });
}

// TypeScript definition for global dataLayer
declare global {
  interface Window {
    dataLayer: any[];
  }
} 



==== utils\logger.ts (18 lines) ====

const logger = {
  info: (message: string, ...args: any[]) => {
    console.log(`[INFO] ${message}`, ...args);
  },
  error: (message: string, error?: any) => {
    console.error(`[ERROR] ${message}`, error);
  },
  warn: (message: string, ...args: any[]) => {
    console.warn(`[WARN] ${message}`, ...args);
  },
  debug: (message: string, ...args: any[]) => {
    if (process.env.NODE_ENV === 'development') {
      console.debug(`[DEBUG] ${message}`, ...args);
    }
  },
};

export default logger; 



==== utils\logging.ts (102 lines) ====

import { createServerClient } from './supabase/server';
import { v4 as uuidv4 } from 'uuid';

// Store a unique identifier for each request
const requestIdStorage = {
  id: '',
  generateNewId: () => {
    requestIdStorage.id = uuidv4();
    return requestIdStorage.id;
  },
  getId: () => requestIdStorage.id || requestIdStorage.generateNewId()
};

/**
 * Log a message to the Supabase CRM matching logs table
 * 
 * @param message Message to log
 * @param context Additional context data (will be stored as JSON)
 * @param options Additional logging options
 */
export async function logToCrm(
  message: string, 
  context: any = {}, 
  options: {
    level?: 'info' | 'warn' | 'error' | 'debug',
    profileId?: string,
    stableHashId?: string,
    crmCustomerId?: string | number,
    source?: string,
    requestId?: string
  } = {}
) {
  try {
    const {
      level = 'info',
      profileId = null,
      stableHashId = null,
      crmCustomerId = null,
      source = 'api',
      requestId = requestIdStorage.getId()
    } = options;
    
    const supabase = createServerClient();
    
    const { error } = await supabase
      .from('crm_matching_logs')
      .insert({
        level,
        message,
        context: typeof context === 'object' ? context : { data: context },
        request_id: requestId,
        profile_id: profileId?.toString(),
        stable_hash_id: stableHashId?.toString(),
        crm_customer_id: crmCustomerId?.toString(),
        source
      });
      
    if (error) {
      console.error('Error writing to CRM matching logs:', error);
    }
    
    // Also log to console for immediate visibility
    const consoleMsg = `[${level.toUpperCase()}][CRM][${source}] ${message}`;
    switch (level) {
      case 'error':
        console.error(consoleMsg, context);
        break;
      case 'warn':
        console.warn(consoleMsg, context);
        break;
      case 'debug':
        console.debug(consoleMsg, context);
        break;
      case 'info':
      default:
        console.log(consoleMsg, context);
    }
    
  } catch (error) {
    // Fallback to console if the DB logging fails
    console.error('Failed to log to CRM matching logs table:', error);
    console.log(`[FALLBACK LOG] ${message}`, context);
  }
}

// Convenience methods
export const crmLogger = {
  info: (message: string, context: any = {}, options = {}) => 
    logToCrm(message, context, { ...options, level: 'info' }),
    
  warn: (message: string, context: any = {}, options = {}) => 
    logToCrm(message, context, { ...options, level: 'warn' }),
    
  error: (message: string, context: any = {}, options = {}) => 
    logToCrm(message, context, { ...options, level: 'error' }),
    
  debug: (message: string, context: any = {}, options = {}) => 
    logToCrm(message, context, { ...options, level: 'debug' }),
    
  // Generate a new request ID
  newRequest: () => requestIdStorage.generateNewId()
}; 



==== utils\parallel-processing.ts (20 lines) ====

interface ParallelOptions {
  timeout?: number;
}

type Task<T> = () => Promise<T>;

export async function executeParallel<T>(tasks: Task<T>[], options: ParallelOptions = {}): Promise<T[]> {
  const { timeout = 10000 } = options;
  
  return Promise.all(
    tasks.map(task => {
      // Add timeout to each task
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error(`Task timed out after ${timeout}ms`)), timeout);
      });
      
      return Promise.race([task(), timeoutPromise]);
    })
  );
} 



==== utils\supabase\client.ts (23 lines) ====

import { createClient as createSupabaseClient } from '@supabase/supabase-js'
import type { Database } from '@/types/supabase'
import type { SupabaseClient } from '@supabase/supabase-js'

let supabaseInstance: SupabaseClient<Database> | null = null

export function createClient(): SupabaseClient<Database> {
  if (supabaseInstance) {
    return supabaseInstance
  }

  supabaseInstance = createSupabaseClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      auth: {
        persistSession: false // We don't need auth persistence
      }
    }
  )

  return supabaseInstance
} 



==== utils\supabase\crm-packages.ts (168 lines) ====

import { createCrmClient } from './crm';
import { createServerClient } from './server';

// Types
export interface CrmPackage {
  id: string;
  crm_package_id: string;
  first_use_date?: string;
  expiration_date: string;
  remaining_hours?: number;
  package_type_name: string;
  customer_name: string;
  stable_hash_id: string;
}

interface RawCrmPackage {
  id: string | number;
  crm_package_id?: string;
  first_use_date?: string;
  expiration_date?: string;
  remaining_hours?: number;
  package_type_name?: string;
  customer_name?: string;
}

/**
 * Fetch packages for a profile using their CRM mapping
 */
export async function getPackagesForProfile(profileId: string): Promise<CrmPackage[]> {
  try {
    const supabase = createServerClient();
    
    // First get the CRM mapping for this profile
    const { data: mapping, error: mappingError } = await supabase
      .from('crm_customer_mapping')
      .select('stable_hash_id')
      .eq('profile_id', profileId)
      .eq('is_matched', true)
      .single();
    
    if (mappingError || !mapping?.stable_hash_id) {
      console.error('No valid CRM mapping found:', mappingError);
      return [];
    }

    // Get packages using stable_hash_id
    return await getPackagesByStableHashId(mapping.stable_hash_id);
  } catch (error) {
    console.error('Error getting packages for profile:', error);
    return [];
  }
}

/**
 * Fetch packages for a customer using stable_hash_id from the CRM database
 */
async function getPackagesByStableHashId(stableHashId: string): Promise<CrmPackage[]> {
  try {
    const crmSupabase = createCrmClient();
    
    // Call the database function to get packages
    const { data: packages, error } = await crmSupabase
      .rpc('get_packages_by_hash_id', { p_stable_hash_id: stableHashId });
    
    if (error) {
      console.error('Error getting packages by hash ID:', error);
      return [];
    }

    // Transform and filter packages
    const validPackages = (packages || [])
      .filter((pkg: RawCrmPackage) => {
        // Only include packages that:
        // 1. Have an expiration date
        // 2. Haven't expired
        const expirationDate = pkg.expiration_date ? new Date(pkg.expiration_date) : null;
        return expirationDate && expirationDate > new Date();
      })
      .map((pkg: RawCrmPackage): CrmPackage => ({
        id: String(pkg.id),
        crm_package_id: pkg.crm_package_id || String(pkg.id),
        first_use_date: pkg.first_use_date,
        expiration_date: pkg.expiration_date || new Date().toISOString(),
        remaining_hours: pkg.remaining_hours,
        package_type_name: pkg.package_type_name || 'Unknown Package',
        customer_name: pkg.customer_name || '',
        stable_hash_id: stableHashId
      }));

    return validPackages;
  } catch (error) {
    console.error('Error in getPackagesByStableHashId:', error);
    return [];
  }
}

/**
 * Sync packages for a profile to our local database
 * This should be called after a successful CRM customer match
 */
export async function syncPackagesForProfile(profileId: string): Promise<void> {
  try {
    const supabase = createServerClient();
    
    // Get the CRM mapping
    const { data: mapping, error: mappingError } = await supabase
      .from('crm_customer_mapping')
      .select('stable_hash_id')
      .eq('profile_id', profileId)
      .eq('is_matched', true)
      .single();
    
    if (mappingError || !mapping?.stable_hash_id) {
      console.error('No valid CRM mapping found:', mappingError);
      return;
    }

    // Get packages from CRM
    const packages = await getPackagesByStableHashId(mapping.stable_hash_id);
    
    if (packages.length > 0) {
      // Upsert packages
      const { error: upsertError } = await supabase
        .from('crm_packages')
        .upsert(
          packages.map(pkg => ({
            ...pkg,
            updated_at: new Date().toISOString()
          })),
          {
            onConflict: 'id',
            ignoreDuplicates: false
          }
        );
      
      if (upsertError) {
        console.error('Error upserting packages:', upsertError);
      }
    }

    // Delete any packages that are no longer valid
    // (i.e., packages in our DB that weren't in the latest sync)
    if (packages.length > 0) {
      const validIds = packages.map(pkg => pkg.id);
      const { error: deleteError } = await supabase
        .from('crm_packages')
        .delete()
        .eq('stable_hash_id', mapping.stable_hash_id)
        .not('id', 'in', `(${validIds.join(',')})`);

      if (deleteError) {
        console.error('Error cleaning up old packages:', deleteError);
      }
    } else {
      // If no packages found, delete all packages for this stable_hash_id
      const { error: deleteError } = await supabase
        .from('crm_packages')
        .delete()
        .eq('stable_hash_id', mapping.stable_hash_id);

      if (deleteError) {
        console.error('Error deleting old packages:', deleteError);
      }
    }
  } catch (error) {
    console.error('Error syncing packages for profile:', error);
  }
} 



==== utils\supabase\crm.ts (27 lines) ====

import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';

let crmSupabaseInstance: ReturnType<typeof createClient<Database>> | null = null;

/**
 * Creates a singleton client connection to the CRM Supabase instance
 */
export function createCrmClient() {
  if (crmSupabaseInstance) {
    return crmSupabaseInstance;
  }

  const supabaseUrl = process.env.NEXT_PUBLIC_CRM_SUPABASE_URL;
  const supabaseKey = process.env.NEXT_PUBLIC_CRM_SUPABASE_KEY;
  
  if (!supabaseUrl || !supabaseKey) {
    throw new Error('CRM Supabase environment variables are not set');
  }
  
  crmSupabaseInstance = createClient<Database>(supabaseUrl, supabaseKey, {
    auth: { persistSession: false }
  });

  return crmSupabaseInstance;
}




==== utils\supabase\middleware.ts (61 lines) ====

import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'
import type { Database } from '@/types/supabase'

export async function updateSession(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  await supabase.auth.getSession()

  return response
} 



==== utils\supabase\server.ts (22 lines) ====

import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';

let supabaseServerClient: ReturnType<typeof createClient<Database>> | null = null;

export function createServerClient() {
  if (supabaseServerClient) {
    return supabaseServerClient;
  }

  supabaseServerClient = createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      auth: {
        persistSession: false // We don't need auth persistence
      }
    }
  );

  return supabaseServerClient;
} 



==== __tests__\availability.test.ts (255 lines) ====

import { POST } from '@/app/api/availability/route';
import { calendar } from '@/lib/googleApiConfig';
import { createClient } from '@/utils/supabase/server';
import { updateCalendarCache } from '@/lib/cache';

// Mock the dependencies
jest.mock('@/lib/googleApiConfig', () => ({
  calendar: {
    events: {
      list: jest.fn()
    }
  },
  AVAILABILITY_CALENDARS: {
    'Bay 1 (Bar)': 'bay1@calendar.com',
    'Bay 2': 'bay2@calendar.com',
    'Bay 3 (Entrance)': 'bay3@calendar.com'
  }
}));

jest.mock('@/utils/supabase/server', () => ({
  createClient: jest.fn()
}));

jest.mock('@/lib/cache', () => ({
  calendarCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
  authCache: {
    get: jest.fn(),
    set: jest.fn(),
  },
  getCacheKey: {
    auth: jest.fn(),
    calendar: jest.fn(),
  },
  updateCalendarCache: jest.fn(),
}));

// Mock Request/Response
global.Request = class MockRequest extends Request {
  constructor(input: RequestInfo | URL, init?: RequestInit) {
    super(input, init);
  }
};

describe('Availability API', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock Supabase authentication
    (createClient as jest.Mock).mockImplementation(() => ({
      auth: {
        getUser: () => Promise.resolve({ data: { user: { id: 'test-user' } }, error: null })
      }
    }));

    // Mock updateCalendarCache to resolve immediately
    (updateCalendarCache as jest.Mock).mockResolvedValue(undefined);
  });

  it('should correctly calculate available slots with real booking data', async () => {
    // Mock the calendar events for a full day
    const mockEvents = [
      // Bay 1 events
      {
        data: {
          items: [
            {
              summary: 'Tomer Liran - Bay 1',
              start: { dateTime: '2025-02-11T12:00:00+07:00' },
              end: { dateTime: '2025-02-11T13:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Benz - Bay 1',
              start: { dateTime: '2025-02-11T13:00:00+07:00' },
              end: { dateTime: '2025-02-11T14:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Shooting Pro Ratchavin - Bay 1',
              start: { dateTime: '2025-02-11T14:00:00+07:00' },
              end: { dateTime: '2025-02-11T14:45:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Peach C. - Bay 1',
              start: { dateTime: '2025-02-11T15:00:00+07:00' },
              end: { dateTime: '2025-02-11T17:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Chen Nan (Ian) - Bay 1',
              start: { dateTime: '2025-02-11T17:00:00+07:00' },
              end: { dateTime: '2025-02-11T18:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Poppee - Bay 1',
              start: { dateTime: '2025-02-11T18:00:00+07:00' },
              end: { dateTime: '2025-02-11T19:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Chris Lee - Bay 1',
              start: { dateTime: '2025-02-11T19:00:00+07:00' },
              end: { dateTime: '2025-02-11T20:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Y.Nakano - Bay 1',
              start: { dateTime: '2025-02-11T20:00:00+07:00' },
              end: { dateTime: '2025-02-11T21:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            },
            {
              summary: 'Bond - Bay 1',
              start: { dateTime: '2025-02-11T21:00:00+07:00' },
              end: { dateTime: '2025-02-11T22:00:00+07:00' },
              organizer: { email: 'bay1@calendar.com' }
            }
          ]
        }
      },
      // Bay 2 events
      {
        data: {
          items: [
            {
              summary: 'Paul Watts - Bay 2',
              start: { dateTime: '2025-02-11T10:00:00+07:00' },
              end: { dateTime: '2025-02-11T11:00:00+07:00' },
              organizer: { email: 'bay2@calendar.com' }
            },
            {
              summary: 'Benz Narongkorn - Bay 2',
              start: { dateTime: '2025-02-11T11:00:00+07:00' },
              end: { dateTime: '2025-02-11T13:00:00+07:00' },
              organizer: { email: 'bay2@calendar.com' }
            },
            {
              summary: 'Lakshay(lucky) - Bay 2',
              start: { dateTime: '2025-02-11T15:00:00+07:00' },
              end: { dateTime: '2025-02-11T16:00:00+07:00' },
              organizer: { email: 'bay2@calendar.com' }
            },
            {
              summary: 'Lakshay(lucky) - Bay 2',
              start: { dateTime: '2025-02-11T16:00:00+07:00' },
              end: { dateTime: '2025-02-11T18:00:00+07:00' },
              organizer: { email: 'bay2@calendar.com' }
            },
            {
              summary: 'An - Bay 2',
              start: { dateTime: '2025-02-11T18:00:00+07:00' },
              end: { dateTime: '2025-02-11T20:00:00+07:00' },
              organizer: { email: 'bay2@calendar.com' }
            },
            {
              summary: 'Jump Boontaveeklt - Bay 2',
              start: { dateTime: '2025-02-11T20:00:00+07:00' },
              end: { dateTime: '2025-02-11T21:00:00+07:00' },
              organizer: { email: 'bay2@calendar.com' }
            }
          ]
        }
      },
      // Bay 3 events
      {
        data: {
          items: [
            {
              summary: 'Fred - Bay 3',
              start: { dateTime: '2025-02-11T10:00:00+07:00' },
              end: { dateTime: '2025-02-11T12:00:00+07:00' },
              organizer: { email: 'bay3@calendar.com' }
            },
            {
              summary: 'Peach C. - Bay 3',
              start: { dateTime: '2025-02-11T18:00:00+07:00' },
              end: { dateTime: '2025-02-11T20:00:00+07:00' },
              organizer: { email: 'bay3@calendar.com' }
            },
            {
              summary: 'KORN J - Bay 3',
              start: { dateTime: '2025-02-11T20:00:00+07:00' },
              end: { dateTime: '2025-02-11T23:00:00+07:00' },
              organizer: { email: 'bay3@calendar.com' }
            }
          ]
        }
      }
    ];

    // Create a copy of mockEvents for each calendar.events.list call
    const mockEventsCopy = [...mockEvents];
    (calendar.events.list as jest.Mock).mockImplementation(() => 
      Promise.resolve(mockEventsCopy.shift())
    );

    const request = new Request('http://localhost/api/availability', {
      method: 'POST',
      body: JSON.stringify({
        date: '2025-02-11',
        currentTimeInBangkok: new Date('2025-02-10T20:47:21+07:00').toISOString()
      })
    });

    const response = await POST(request);
    const data = await response.json();

    // Verify the slots
    expect(data.slots).toBeDefined();
    
    // Helper function to find a slot by start time
    const findSlot = (startTime: string) => 
      data.slots.find((slot: any) => slot.startTime === startTime);

    // Test morning slots (10:00-12:00)
    const slot10 = findSlot('10:00');
    expect(slot10).toBeDefined();
    expect(slot10.maxHours).toBe(2); // Bay 1 is available for 2 hours until 12:00

    // Test early afternoon slots (12:00-15:00)
    const slot13 = findSlot('13:00');
    expect(slot13).toBeDefined(); // Bay 3 should be available
    expect(slot13.maxHours).toBe(5); // Available until 18:00 when Peach C. starts in Bay 3

    // Test mid-afternoon slots (15:00-18:00)
    const slot14 = findSlot('14:00');
    expect(slot14).toBeDefined(); // Bay 3 still available
    expect(slot14.maxHours).toBe(4); // Available until 18:00 when all bays are booked
    
    // Test evening slots (18:00-21:00)
    const slot18 = findSlot('18:00');
    expect(slot18).toBeUndefined(); // All bays are booked

    // Test late evening slots (21:00-23:00)
    const slot22 = findSlot('22:00');
    expect(slot22).toBeDefined(); // Bay 1 and Bay 2 are available
    expect(slot22.maxHours).toBe(1); // Only 1 hour until closing

    // Test edge cases
    const slot15 = findSlot('15:00');
    expect(slot15).toBeDefined(); // Bay 3 still available
    expect(slot15.maxHours).toBe(3); // Available until 18:00
    
    const slot2045 = findSlot('20:45');
    expect(slot2045).toBeUndefined(); // Should not create slots with less than 15 min until next booking

    // Log all slots for debugging
    console.log('Available slots:', JSON.stringify(data.slots, null, 2));
  });
}); 



==== __tests__\sample.test.ts (5 lines) ====

describe('Sample Test', () => {
  it('should pass', () => {
    expect(true).toBe(true)
  })
}) 

